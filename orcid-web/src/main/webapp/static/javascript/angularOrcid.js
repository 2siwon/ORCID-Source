/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	//npm install -g typescript

	function requireAll(requireContext) {
	  return requireContext.keys().map(requireContext);
	}

	__webpack_require__(1);
	//require('./app/main.ts');
	requireAll(__webpack_require__(2));
	requireAll(__webpack_require__(14));
	requireAll(__webpack_require__(15));
	requireAll(__webpack_require__(21));
	requireAll(__webpack_require__(22));
	requireAll(__webpack_require__(24));
	requireAll(__webpack_require__(49));
	requireAll(__webpack_require__(61));

/***/ },
/* 1 */
/***/ function(module, exports) {

	/*
	 * =============================================================================
	 *
	 * ORCID (R) Open Source
	 * http://orcid.org
	 *
	 * Copyright (c) 2012-2014 ORCID, Inc.
	 * Licensed under an MIT-Style License (MIT)
	 * http://orcid.org/open-source-license
	 *
	 * This copyright and license information (including a link to the full license)
	 * shall be included in its entirety in all copies or substantial portion of
	 * the software.
	 *
	 * =============================================================================
	 */

	/*
	 * Structure of this file:
	 * 
	 *  - 1 - Utility functions
	 *  - 2 - Groupings logic
	 *  - 3 - Angular Services
	 *  - 4 - Angular Controllers
	 *  - 5 - Angular Filters
	 *  - 6 - Angular Directives
	 *  - 7 - Angular Multiselect Module
	 *  
	 */

	var orcidNgModule = angular.module('orcidApp', ['ngCookies','ngSanitize', 'ui.multiselect', 'vcRecaptcha']);

	angular.element(function() {
	    angular.bootstrap(
	        document, 
	        ['orcidApp']
	    );
	});
	//angular.bootstrap(document.body, ['orcidApp'], {});


	/*
	 * 1 - Utility functions 
	 */
	function openImportWizardUrl(url) {
	    var win = window.open(url, "_target");
	    setTimeout( function() {
	        if(!win || win.outerHeight === 0) {
	            //First Checking Condition Works For IE & Firefox
	            //Second Checking Condition Works For Chrome
	            window.location.href = url;
	        }
	    }, 250);
	    $.colorbox.close();
	}

	function contains(arr, obj) {
	    var index = arr.length;
	    while (index--) {
	       if (arr[index] === obj) {
	           return true;
	       }
	    }
	    return false;
	}

	function formatDate(oldDate) {
	    var date = new Date(oldDate);
	    var day = date.getDate();
	    var month = date.getMonth() + 1;
	    var year = date.getFullYear();
	    if(month < 10) {
	        month = '0' + month;
	    }
	    if(day < 10) {
	        day = '0' + day;
	    }
	    return (year + '-' + month + '-' + day);
	}

	function getScripts(scripts, callback) {
	    var progress = 0;
	    var internalCallback = function () {        
	        if (++progress == scripts.length - 1) {
	            callback();
	        }
	    };    
	    scripts.forEach(function(script) {        
	        $.getScript(script, internalCallback);        
	    });
	}

	function formColorBoxWidth() {
	    return isMobile()? '100%': '800px';
	}

	function formColorBoxResize() {
	    if (isMobile())
	        $.colorbox.resize({width: formColorBoxWidth(), height: '100%'});
	    else
	        // IE8 and below doesn't take auto height
	        // however the default div height
	        // is auto anyway
	        $.colorbox.resize({width:'800px'});
	}

	function fixZindexIE7(target, zindex){
	    if(isIE() == 7){
	        $(target).each(function(){
	            $(this).css('z-index', zindex);
	            --zindex;
	        });
	    }
	}

	function emptyTextField(field) {
	    if (field != null
	        && field.value != null
	        && field.value.trim() != '') {
	        return false;
	    }
	    return true;
	}

	function addComma(str) {
	    if (str.length > 0) return str + ', ';
	    return str;
	}

	//Needs refactor for dw object
	function removeBadContributors(dw) {
	    for (var idx in dw.contributors) {
	        if (dw.contributors[idx].contributorSequence == null
	            && dw.contributors[idx].email == null
	            && dw.contributors[idx].orcid == null
	            && dw.contributors[idx].creditName == null
	            && dw.contributors[idx].contributorRole == null
	            && dw.contributors[idx].creditNameVisibility == null) {
	                dw.contributors.splice(idx,1);
	            }
	    }
	}

	//Needs refactor for dw object
	function removeBadExternalIdentifiers(dw) {
	    for(var idx in dw.workExternalIdentifiers) {
	        if(dw.workExternalIdentifiers[idx].workExternalIdentifierType == null
	            && dw.workExternalIdentifiers[idx].workExternalIdentifierId == null) {
	            dw.workExternalIdentifiers.splice(idx,1);
	        }
	    }
	}

	function isEmail(email) {
	    var re = /\S+@\S+\.\S+/;
	    return re.test(email);
	}

	function getParameterByName(name) {
	    name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
	    var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
	        results = regex.exec(location.search);
	    return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
	}


	/*************************************************
	 * 3 - Angular Services
	 *************************************************/

	//Dependencie: removeBadContributors, dw object. Can't move yet
	angular.module('orcidApp').factory("worksSrvc", ['$rootScope', function ($rootScope) {
	    var worksSrvc = {
	        bibtexJson: {},
	        blankWork: null,
	        constants: { 'access_type': { 'USER': 'user', 'ANONYMOUS': 'anonymous'}},
	        details: new Object(), // we should think about putting details in the
	        groups: new Array(),
	        labelsMapping: {
	            "default": {
	                types: [
	                    {
	                        type: "all",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.defaultTitle"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.defaultTitlePlaceholder")
	                    }
	                ]
	            }, 
	            "publication": {
	                types: [
	                    {
	                        type: "book",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisher"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisherPlaceholder")
	                    },
	                    {
	                        type: "book-chapter",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitleBook"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitleBookPlaceholder")
	                    },
	                    {
	                        type: "book-review",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisher"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisherPlaceholder")
	                    },
	                    {
	                        type: "dictionary-entry",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisher"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisherPlaceholder")
	                    },
	                    {
	                        type: "dissertation",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitleInstitution"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitleInstitutionPlaceholder")
	                    },
	                    {
	                        type: "edited-book",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisher"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisherPlaceholder")
	                    },
	                    {
	                        type: "encyclopedia-entry",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisher"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisherPlaceholder")
	                    },
	                    {
	                        type: "journal-article",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.journalTitle"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.journalTitlePlaceholder")
	                    },
	                    {
	                        type: "journal-issue",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.journalTitle"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.journalTitlePlaceholder")
	                    },
	                    {
	                        type: "magazine-article",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitleMagazineArticle"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitleMagazineArticlePlaceholder")
	                    },
	                    {
	                        type: "manual",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisher"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisherPlaceholder")
	                    },
	                    {
	                        type: "newsletter-article",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitleNewsletter"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitleNewsletterPlaceholder")
	                    },
	                    {
	                        type: "newspaper-article",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitleNewspaper"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitleNewspaperPlaceholder")
	                    },
	                    {
	                        type: "online-resource",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisher"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisherPlaceholder")
	                    },
	                    {
	                        type: "report",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitleInstitution"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitleInstitutionPlaceholder")
	                    },
	                    {
	                        type: "research-tool",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitleInstitution"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitleInstitutionPlaceholder")
	                    },
	                    {
	                        type: "supervised-student-publication",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitleInstitution"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitleInstitutionPlaceholder")
	                    },
	                    {
	                        type: "test",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitleInstitution"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitleInstitutionPlaceholder")
	                    },
	                    {
	                        type: "translation",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisher"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisherPlaceholder")
	                    },
	                    {
	                        type: "website",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisher"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisherPlaceholder")
	                    },
	                    {
	                        type: "working-paper",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitleInstitution"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitleInstitutionPlaceholder")
	                    }
	                ]
	            },
	            "conference": {
	                types: [
	                    {
	                        type: "conference-abstract",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitleConference"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitleConferencePlaceholder")
	                    },
	                    {
	                        type: "conference-paper",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitleConference"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitleConferencePlaceholder")
	                    },
	                    {
	                        type: "conference-poster",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitleConference"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitleConferencePlaceholder")
	                    }
	                ]
	            },
	            "intellectual_property": {
	                types: [
	                    {
	                        type: "disclosure",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisher"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisherPlaceholder")
	                    },
	                    {
	                        type: "license",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisher"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisherPlaceholder")
	                    },
	                    {
	                        type: "patent",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisher"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisherPlaceholder")
	                    },
	                    {
	                        type: "registered-copyright",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisher"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisherPlaceholder")
	                    }
	                ]
	            },
	            "other_output": {
	                types: [
	                    {
	                        type: "artistic-performance",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisher"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisherPlaceholder")
	                    },
	                    {
	                        type: "data-set",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisher"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisherPlaceholder")
	                    },
	                    {
	                        type: "invention",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisher"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisherPlaceholder")
	                    },
	                    {
	                        type: "lecture-speech",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisher"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisherPlaceholder")
	                    },
	                    {
	                        type: "research-technique",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisher"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisherPlaceholder")
	                    },
	                    {
	                        type: "spin-off-company",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisher"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisherPlaceholder")
	                    },
	                    {
	                        type: "standards-and-policy",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisher"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisherPlaceholder")
	                    },
	                    {
	                        type: "technical-standard",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisher"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisherPlaceholder")
	                    },
	                    {
	                        type: "other",
	                        titleLabel: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisher"),
	                        titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.labelTitlePublisherPlaceholder")
	                    }
	                ]
	            }
	        },
	        loading: false,
	        loadingDetails: false,
	        quickRef: {},
	        worksToAddIds: null,

	        getLabelMapping: function(workCategory, workType){
	            var result = this.labelsMapping.default.types[0];
	            var tempI = null;

	            if( this.labelsMapping[workCategory] != undefined ){
	                tempI = this.labelsMapping[workCategory].types;
	                for( var i = 0; i < tempI.length; i++) {
	                    if( tempI[i].type == workType ) {
	                        result = tempI[i];
	                    }
	                }
	            }
	            return result;
	        },   
	        addBibtexJson: function(dw) {
	            if (dw.citation && dw.citation.citationType && dw.citation.citationType.value == 'bibtex') {
	                try {
	                    worksSrvc.bibtexJson[dw.putCode.value] = bibtexParse.toJSON(dw.citation.citation.value);
	                } catch (err) {
	                    worksSrvc.bibtexJson[dw.putCode.value] = null;
	                    console.log("couldn't parse bibtex: " + dw.citation.citation.value);
	                };
	            };
	        },
	        addAbbrWorksToScope: function(type) {
	            if (type == worksSrvc.constants.access_type.USER)
	                var url = getBaseUri() + '/works/works.json?workIds=';
	            else // use the anonymous url
	                var url = getBaseUri() + '/' + orcidVar.orcidId +'/works.json?workIds='; // public
	            if(worksSrvc.worksToAddIds.length != 0 ) {
	                worksSrvc.loading = true;
	                var workIds = worksSrvc.worksToAddIds.splice(0,20).join();
	                $.ajax({
	                    'url': url + workIds,
	                    'dataType': 'json',
	                    'success': function(data) {
	                        $rootScope.$apply(function(){
	                            for (i in data) {
	                                var dw = data[i];
	                                removeBadContributors(dw);
	                                removeBadExternalIdentifiers(dw);
	                                worksSrvc.addBibtexJson(dw);
	                                groupedActivitiesUtil.group(dw,GroupedActivities.ABBR_WORK,worksSrvc.groups);
	                            };
	                        });
	                        if(worksSrvc.worksToAddIds.length == 0 ) {
	                            worksSrvc.loading = false;
	                            $rootScope.$apply();
	                            fixZindexIE7('.workspace-public workspace-body-list li',99999);
	                            fixZindexIE7('.workspace-toolbar',9999);
	                        } else {
	                            $rootScope.$apply();
	                            setTimeout(function(){
	                                worksSrvc.addAbbrWorksToScope(type);
	                            },50);
	                        }
	                    }
	                }).fail(function(e) {
	                    //$rootScope.$apply(function() {
	                        worksSrvc.loading = false;
	                    //});
	                    console.log("Error fetching works: " + workIds);
	                    logAjaxError(e);
	                });
	            } else {
	                worksSrvc.loading = false;
	            };
	        },
	        createNew: function(work) {
	            var cloneW = JSON.parse(JSON.stringify(work));
	            cloneW.source = null;
	            cloneW.putCode = null;
	            cloneW.contributors = [];
	            return cloneW;
	        },
	        copyEIs: function(from, to) {
	            // add all identiifers
	            if (to.workExternalIdentifiers == undefined)
	                to.workExternalIdentifiers = new Array();
	            for (var idx in from.workExternalIdentifiers)
	                to.workExternalIdentifiers.push(JSON.parse(JSON.stringify(from.workExternalIdentifiers[idx])));
	            return to;
	        },
	        getBlankWork: function(callback) {
	            // if cached return clone of blank
	            if (worksSrvc.blankWork != null)
	                callback(JSON.parse(JSON.stringify(worksSrvc.blankWork)));
	            $.ajax({
	                url: getBaseUri() + '/works/work.json',
	                dataType: 'json',
	                success: function(data) {
	                    blankWork =  data;
	                    callback(data);
	                }
	            }).fail(function() {
	                console.log("Error fetching blank work");
	            });
	        },
	        getDetails: function(putCode, type, callback) {
	            if (type == worksSrvc.constants.access_type.USER)
	                var url = getBaseUri() + '/works/getWorkInfo.json?workId=';
	            else // use the anonymous url
	                var url = getBaseUri() + '/' + orcidVar.orcidId + '/getWorkInfo.json?workId='; // public
	            if(worksSrvc.details[putCode] == undefined) {
	                $.ajax({
	                    url: url + putCode,
	                    dataType: 'json',
	                    success: function(data) {
	                        $rootScope.$apply(function () {
	                            removeBadContributors(data);
	                            removeBadExternalIdentifiers(data);
	                            worksSrvc.addBibtexJson(data);
	                            worksSrvc.details[putCode] = data;
	                            if (callback != undefined) callback(worksSrvc.details[putCode]);
	                        });
	                    }
	                }).fail(function(e){
	                    // something bad is happening!
	                    console.log("error fetching works");
	                    logAjaxError(e);
	                });
	            } else {
	                if (callback != undefined) callback(worksSrvc.details[putCode]);
	            };
	        },
	        getEditable: function(putCode, callback) {
	            // first check if they are the current source
	            var work = worksSrvc.getDetails(putCode, worksSrvc.constants.access_type.USER, function(data) {
	                if (data.source == orcidVar.orcidId)
	                    callback(data);
	                else
	                    worksSrvc.getGroupDetails(putCode, worksSrvc.constants.access_type.USER, function () {
	                        // in this case we want to open their version
	                        // if they don't have a version yet then copy
	                        // the current one
	                        var bestMatch = null;
	                        for (var idx in worksSrvc.details)
	                            if (worksSrvc.details[idx].source == orcidVar.orcidId) {
	                                bestMatch = worksSrvc.details[idx];
	                                break;
	                            }
	                        if (bestMatch == null) {
	                            bestMatch = worksSrvc.createNew(worksSrvc.details[putCode]);
	                        }
	                        callback(bestMatch);
	                    });
	            });
	        },
	        getGroup: function(putCode) {
	            for (var idx in worksSrvc.groups) {
	                    if (worksSrvc.groups[idx].hasPut(putCode))
	                        return worksSrvc.groups[idx];
	            }
	            return null;
	        },
	        getGroupDetails: function(putCode, type, callback) {
	            var group = worksSrvc.getGroup(putCode);
	            var needsLoading =  new Array();
	            for (var idx in group.activities) {
	                needsLoading.push(group.activities[idx].putCode.value)
	            }

	            var popFunct = function () {
	                if (needsLoading.length > 0)
	                    worksSrvc.getDetails(needsLoading.pop(), type, popFunct);
	                else if (callback != undefined)
	                    callback();
	            };
	            popFunct();
	        },
	        getWork: function(putCode) {
	            for (var idx in worksSrvc.groups) {
	                    if (worksSrvc.groups[idx].hasPut(putCode))
	                        return worksSrvc.groups[idx].getByPut(putCode);
	            }
	            return null;
	        },
	        deleteGroupWorks: function(putCodes) {
	            var rmWorks = [];
	            var rmGroups = [];
	            for (var i in putCodes) {
	                for (var j in worksSrvc.groups) {
	                    if (worksSrvc.groups[j].hasPut(putCodes[i])) {
	                        rmGroups.push(j);
	                        for (var k in worksSrvc.groups[j].activities){
	                            rmWorks.push(worksSrvc.groups[j].activities[k].putCode.value);
	                        }
	                    };
	                }
	            }
	            while (rmGroups.length > 0) {
	                worksSrvc.groups.splice(rmGroups.pop(),1);
	            }
	            worksSrvc.removeWorks(rmWorks);
	        },
	        deleteWork: function(putCode) {
	            worksSrvc.removeWorks([putCode], function() {
	                groupedActivitiesUtil.rmByPut(putCode, GroupedActivities.ABBR_WORK, worksSrvc.groups);
	                $rootScope.$apply();
	            });
	        },
	        makeDefault: function(group, putCode) {
	            group.makeDefault(putCode);
	            $.ajax({
	                url: getBaseUri() + '/works/updateToMaxDisplay.json?putCode=' + putCode,
	                dataType: 'json',
	                success: function(data) {
	                }
	            }).fail(function(){
	                // something bad is happening!
	                console.log("some bad is hppending");
	            });
	        },
	        loadAbbrWorks: function(access_type) {
	            if (access_type == worksSrvc.constants.access_type.ANONYMOUS) {
	                worksSrvc.worksToAddIds = orcidVar.workIds;
	                worksSrvc.addAbbrWorksToScope(worksSrvc.constants.access_type.ANONYMOUS);
	            } else {
	                worksSrvc.worksToAddIds = null;
	                worksSrvc.loading = true;
	                worksSrvc.groups = new Array();
	                worksSrvc.details = new Object();
	                $.ajax({
	                    url: getBaseUri() + '/works/workIds.json',
	                    dataType: 'json',
	                    success: function(data) {
	                        worksSrvc.worksToAddIds = data;
	                        worksSrvc.addAbbrWorksToScope(worksSrvc.constants.access_type.USER);
	                        $rootScope.$apply();
	                    }
	                }).fail(function(e){
	                    // something bad is happening!
	                    console.log("error fetching works");
	                    logAjaxError(e);
	                });
	            };
	        },
	        putWork: function(work,sucessFunc, failFunc) {
	            $.ajax({
	                url: getBaseUri() + '/works/work.json',
	                contentType: 'application/json;charset=UTF-8',
	                dataType: 'json',
	                type: 'POST',
	                data: angular.toJson(work),
	                success: function(data) {
	                    sucessFunc(data);
	                }
	            }).fail(function(){
	                failFunc();
	            });
	        },
	        removeWorks: function(putCodes,callback) {
	            $.ajax({
	                url: getBaseUri() + '/works/' + putCodes.splice(0,150).join(),
	                type: 'DELETE',
	                contentType: 'application/json;charset=UTF-8',
	                dataType: 'json',
	                success: function(data) {
	                    if (putCodes.length > 0) 
	                        worksSrvc.removeWorks(putCodes,callback);
	                    else if (callback)
	                        callback(data);
	                }
	            }).fail(function() {
	                console.log("Error deleting works.");
	            });
	        },
	        setGroupPrivacy: function(putCode, priv) {
	            var group = worksSrvc.getGroup(putCode);
	            var putCodes = new Array();
	            for (var idx in group.activities) {
	                putCodes.push(group.activities[idx].putCode.value);
	                group.activities[idx].visibility = priv;
	            }
	            worksSrvc.updateVisibility(putCodes, priv);
	        },
	        setPrivacy: function(putCode, priv) {
	            worksSrvc.updateVisibility([putCode], priv);
	        },
	        updateVisibility: function(putCodes, priv) {
	            $.ajax({
	                url: getBaseUri() + '/works/' + putCodes.splice(0,150).join() + '/visibility/'+priv,
	                type: 'GET',
	                contentType: 'application/json;charset=UTF-8',
	                dataType: 'json',
	                success: function(data) {
	                    if (putCodes.length > 0)
	                        worksSrvc.updateVisibility(putCodes, priv);
	                }
	            }).fail(function() {
	                console.log("Error updating profile work.");
	            });
	        },
	        workCount: function() {
	            var count = 0;
	            for (var idx in worksSrvc.groups) {
	                count += worksSrvc.groups[idx].activitiesCount;
	            }
	            return count;
	        },
	        worksValidate: function(works,sucessFunc, failFunc) {
	            $.ajax({
	                url: getBaseUri() + '/works/worksValidate.json',
	                contentType: 'application/json;charset=UTF-8',
	                dataType: 'json',
	                type: 'POST',
	                data: angular.toJson(works),
	                success: function(data) {
	                    sucessFunc(data);
	                }
	            }).fail(function(){
	                failFunc();
	            });
	        },
	        getUniqueDois : function(putCode){
	            var dois = [];              
	            var group = worksSrvc.getGroup(putCode);
	            for (var idx in group.activities) {                 
	                for (i = 0; i <= group.activities[idx].workExternalIdentifiers.length - 1; i++) {
	                    if (group.activities[idx].workExternalIdentifiers[i].workExternalIdentifierType.value == 'doi'){
	                        if (isIndexOf.call(dois, group.activities[idx].workExternalIdentifiers[i].workExternalIdentifierId.value) == -1){
	                            dois.push(group.activities[idx].workExternalIdentifiers[i].workExternalIdentifierId.value);
	                        }
	                    }
	                }
	            }
	            
	            return dois;
	        }
	    };
	    return worksSrvc;
	}]);

	angular.module('orcidApp').factory("emailSrvc", function ($rootScope, $location, $timeout) {
	    var serv = {
	        emails: null,            
	        delEmail: null,
	        displayModalWarningFlag: false,
	        inputEmail: null,
	        popUp: false,
	        primaryEmail: null,
	        
	        addEmail: function() {              
	            $.ajax({
	                url: getBaseUri() + '/account/addEmail.json',
	                data:  angular.toJson(serv.inputEmail),
	                contentType: 'application/json;charset=UTF-8',
	                type: 'POST',
	                dataType: 'json',
	                success: function(data) {
	                    serv.inputEmail = data;
	                    if (serv.inputEmail.errors.length == 0) {
	                        serv.initInputEmail();
	                        serv.getEmails();
	                    }
	                    $rootScope.$apply();
	                }
	            }).fail(function() {
	                // something bad is happening!
	                console.log("error with multi email");
	            });
	        },
	        
	        deleteEmail: function (callback) {
	            $.ajax({
	                url: getBaseUri() + '/account/deleteEmail.json',
	                type: 'DELETE',
	                data:  angular.toJson(serv.delEmail),
	                contentType: 'application/json;charset=UTF-8',
	                dataType: 'json',
	                success: function(data) {
	                    serv.getEmails();
	                    if (callback)
	                           callback();
	                }
	            }).fail(function() {
	                // something bad is happening!
	                console.log("emailSrvc.deleteEmail() error");
	            });
	        },
	        
	        getEmails: function(callback) {
	            $.ajax({
	                url: getBaseUri() + '/account/emails.json',
	                type: 'GET',
	                dataType: 'json',
	                success: function(data) {                       
	                    serv.emails = data;
	                    for (var i in data.emails){
	                        if (data.emails[i].primary){
	                            serv.primaryEmail = data.emails[i];
	                        }
	                    }                                                
	                    $rootScope.$apply();
	                    if (callback) {
	                       callback(data);
	                    }
	                }
	            }).fail(function(e) {
	                // something bad is happening!
	                console.log("error with multi email");
	                logAjaxError(e);
	            });
	        },
	        

	        initInputEmail: function() {
	            serv.inputEmail = {"value":"","primary":false,"current":true,"verified":false,"visibility":"PRIVATE","errors":[]};
	        },

	        saveEmail: function(callback) {
	            $.ajax({
	                url: getBaseUri() + '/account/emails.json',
	                type: 'POST',
	                data: angular.toJson(serv.emails),
	                contentType: 'application/json;charset=UTF-8',
	                dataType: 'json',
	                success: function(data) {
	                    serv.data;
	                    $rootScope.$apply();
	                    if (callback)
	                        callback(data);
	                }
	            }).fail(function() {
	                // something bad is happening!
	                console.log("error with multi email");
	            });
	        },

	        setPrimary: function(email) {
	            for (i in serv.emails.emails) {
	                if (serv.emails.emails[i] == email) {
	                    serv.emails.emails[i].primary = true;
	                } else {
	                    serv.emails.emails[i].primary = false;
	                }
	            }
	            serv.saveEmail();
	        },
	        
	        setPrivacy: function(email, priv) {
	            email.visibility = priv;
	            serv.saveEmail();
	        },
	        
	        verifyEmail: function(email, callback) {
	            $.ajax({
	                url: getBaseUri() + '/account/verifyEmail.json',
	                type: 'get',
	                data:  { "email": email.value },
	                contentType: 'application/json;charset=UTF-8',
	                dataType: 'json',
	                success: function(data) {
	                    if (callback)
	                        callback(data);
	                }
	            }).fail(function() {
	                // something bad is happening!
	                console.log("error with multi email");
	            });
	        }

	    };

	    return serv;
	});

	angular.module('orcidApp').factory("prefsSrvc", function ($rootScope) {
	    var serv = {
	        prefs: null,
	        saved: false,
	        getPrivacyPreferences: function() {
	            $.ajax({
	                url: getBaseUri() + '/account/preferences.json',
	                dataType: 'json',
	                success: function(data) {
	                    serv.prefs = data;
	                    $rootScope.$apply();
	                }
	            }).fail(function() {
	                // something bad is happening!
	                console.log("error with prefs");
	            });
	        },
	        savePrivacyPreferences: function() {
	            $.ajax({
	                url: getBaseUri() + '/account/preferences.json',
	                type: 'POST',
	                data: angular.toJson(serv.prefs),
	                contentType: 'application/json;charset=UTF-8',
	                dataType: 'json',
	                success: function(data) {
	                    serv.prefs = data;
	                    serv.saved = true;
	                    $rootScope.$apply();
	                }
	            }).fail(function() {
	                // something bad is happening!
	                console.log("error with prefs");
	            });
	        },
	        clearMessage: function(){
	            serv.saved = false;
	        }
	    };

	    // populate the prefs
	    serv.getPrivacyPreferences();

	    return serv; 
	});



	angular.module('orcidApp').factory("widgetSrvc", ['$rootScope', function ($rootScope) {
	    var widgetSrvc = {
	        locale: 'en',
	        setLocale: function (locale) {
	            widgetSrvc.locale = locale;
	        }
	    };
	    return widgetSrvc;
	}]);

	angular.module('orcidApp').factory("discoSrvc", ['$rootScope', 'widgetSrvc', function ($rootScope, widgetSrvc) {
	    var serv = {
	        feed: null,
	        getDiscoFeed: function() {
	            $.ajax({
	                url: getBaseUri() + '/Shibboleth.sso/DiscoFeed',
	                dataType: 'json',
	                cache: true,
	                success: function(data) {
	                    serv.feed = data;
	                    $rootScope.$apply();
	                }
	            }).fail(function(e) {
	                // something bad is happening!
	                console.log("error with disco feed");
	                logAjaxError(e);
	                serv.feed = [];
	                $rootScope.$apply();
	            });
	        },
	        getIdPName: function(entityId) {
	            var locale = widgetSrvc.locale != null ? widgetSrvc.locale : "en";
	            for(i in serv.feed) {
	                var idp = serv.feed[i];
	                if(entityId === idp.entityID) {
	                    var name = idp.DisplayNames[0].value;
	                    for(j in idp.DisplayNames){
	                        var displayName = idp.DisplayNames[j];
	                        if(locale === displayName.lang){
	                            name = displayName.value;
	                        }
	                    }
	                    return name;
	                }
	            }
	            if(entityId === "facebook" || entityId === "google"){
	                return entityId.charAt(0).toUpperCase() + entityId.slice(1);
	            }
	            return entityId;
	        }
	    };

	    // populate the disco feed
	    serv.getDiscoFeed();
	    return serv; 
	}]);

	angular.module('orcidApp').factory("membersListSrvc", ['$rootScope', function ($rootScope) {
	    var serv = {
	        membersList: null,
	        memberDetails: {},
	        currentMemberDetails: null,
	        consortiaList: null,
	        getMembersList: function() {
	            $.ajax({
	                url: getBaseUri() + '/members/members.json',
	                dataType: 'json',
	                cache: true,
	                success: function(data) {
	                    serv.membersList = data;
	                    $rootScope.$apply();
	                }
	            }).fail(function() {
	                // something bad is happening!
	                console.log("error with members list");
	                serv.feed = [];
	                $rootScope.$apply();
	            });
	        },
	        getDetails: function(memberId, consortiumLeadId) {
	            if(serv.memberDetails[memberId] == null){
	                var url = getBaseUri() + '/members/details.json?memberId=' + encodeURIComponent(memberId);
	                if(consortiumLeadId != null){
	                    url += '&consortiumLeadId=' + encodeURIComponent(consortiumLeadId);
	                }
	                $.ajax({
	                    url: url,
	                    dataType: 'json',
	                    cache: true,
	                    success: function(data) {
	                        serv.memberDetails[memberId] = data;
	                        $rootScope.$apply();
	                    }
	                }).fail(function() {
	                    // something bad is happening!
	                    console.log("error with member details");
	                    serv.feed = [];
	                    $rootScope.$apply();
	                });
	            }
	        },
	        getCurrentMemberDetailsBySlug: function(memberSlug) {
	            if(serv.currentMemberDetails == null){
	                var url = getBaseUri() + '/members/detailsBySlug.json?memberSlug=' + encodeURIComponent(memberSlug);
	                $.ajax({
	                    url: url,
	                    dataType: 'json',
	                    cache: true,
	                    success: function(data) {
	                        serv.currentMemberDetails = data;
	                        $rootScope.$apply();
	                    }
	                }).fail(function() {
	                    // something bad is happening!
	                    console.log("error with member details by slug");
	                    serv.feed = [];
	                    $rootScope.$apply();
	                });
	            }
	        },
	        getConsortiaList: function() {
	            $.ajax({
	                url: getBaseUri() + '/consortia/consortia.json',
	                dataType: 'json',
	                cache: true,
	                success: function(data) {
	                    serv.consortiaList = data;
	                    $rootScope.$apply();
	                }
	            }).fail(function() {
	                // something bad is happening!
	                console.log("error with consortia list");
	                serv.feed = [];
	                $rootScope.$apply();
	            });
	        },
	        getMemberPageUrl: function(slug) {
	            return orcidVar.baseUri + '/members/' + slug;
	        }
	    };

	    return serv; 
	}]);

	angular.module('orcidApp').factory("clearMemberListFilterSrvc", ['$rootScope', function ($rootScope) {
	    return {
	          clearFilters : function ($scope){
	              $scope.by_country = undefined;
	              $scope.by_researchCommunity = undefined;
	              $scope.activeLetter = '';
	         }
	     };
	 }]);

	angular.module('orcidApp').factory("peerReviewSrvc", ['$rootScope', function ($rootScope) {
	    var peerReviewSrvc = {
	            constants: { 'access_type': { 'USER': 'user', 'ANONYMOUS': 'anonymous'}},
	            groups: new Array(),            
	            loading: false,
	            loadingDetails: false,
	            quickRef: {},            
	            loadingDetails: false,
	            blankPeerReview: null,
	            details: new Object(), // we should think about putting details in the
	            peerReviewsToAddIds: null,
	            peerReviewGroupDetailsRequested: new Array(),
	            getBlankPeerReview: function(callback) {
	                 // if cached return clone of blank
	                if (peerReviewSrvc.blankPeerReview != null)
	                    callback(JSON.parse(JSON.stringify(peerReviewSrvc.blankPeerReview)));
	                $.ajax({
	                    url: getBaseUri() + '/peer-reviews/peer-review.json',
	                    dataType: 'json',
	                    success: function(data) {
	                        callback(data);
	                        $rootScope.$apply();
	                    }
	                }).fail(function() {
	                    console.log("Error fetching blank Peer Review");
	                });                
	            },
	            postPeerReview: function(peer_review, successFunc, failFunc) {              
	                $.ajax({
	                    url: getBaseUri() + '/peer-reviews/peer-review.json',
	                    contentType: 'application/json;charset=UTF-8',
	                    dataType: 'json',
	                    type: 'POST',
	                    data: angular.toJson(peer_review),
	                    success: function(data) {
	                        successFunc(data);
	                    }
	                }).fail(function(){
	                    failFunc();
	                });
	            },
	            createNew: function(peerReview) {
	                var cloneF = JSON.parse(JSON.stringify(peerReview));
	                cloneF.source = null;
	                cloneF.putCode = null;
	                for (var idx in cloneF.externalIdentifiers)
	                    cloneF.externalIdentifiers[idx].putCode = null;
	                return cloneF;
	            },                   
	            loadPeerReviews: function(access_type) {
	                if (access_type == peerReviewSrvc.constants.access_type.ANONYMOUS) {                    
	                    peerReviewSrvc.peerReviewsToAddIds = orcidVar.PeerReviewIds;
	                    peerReviewSrvc.addPeerReviewsToScope(peerReviewSrvc.constants.access_type.ANONYMOUS);
	                } else {
	                    peerReviewSrvc.peerReviewsToAddIds = null;
	                    peerReviewSrvc.loading = true;
	                    peerReviewSrvc.groups = new Array();
	                    peerReviewSrvc.details = new Object();
	                    $.ajax({
	                        url: getBaseUri() + '/peer-reviews/peer-review-ids.json',
	                        dataType: 'json',
	                        success: function(data) {
	                            peerReviewSrvc.peerReviewsToAddIds = data;                          
	                            peerReviewSrvc.addPeerReviewsToScope(peerReviewSrvc.constants.access_type.USER);
	                            $rootScope.$apply();
	                        }
	                    }).fail(function(e){
	                        // something bad is happening!
	                        console.log("error fetching Peer Review");
	                        logAjaxError(e);
	                    });
	                };
	            },          
	            addPeerReviewsToScope: function(type) {
	                if (type == peerReviewSrvc.constants.access_type.USER)
	                    var url = getBaseUri() + '/peer-reviews/get-peer-reviews.json?peerReviewIds=';
	                else // use the anonymous url
	                    var url = getBaseUri() + '/' + orcidVar.orcidId +'/peer-reviews.json?peerReviewIds=';
	                if(peerReviewSrvc.peerReviewsToAddIds.length != 0 ) {
	                    peerReviewSrvc.loading = true;
	                    var peerReviewIds = peerReviewSrvc.peerReviewsToAddIds.splice(0,20).join();
	                    $.ajax({
	                        'url': url + peerReviewIds,
	                        'dataType': 'json',
	                        'success': function(data) {
	                            $rootScope.$apply(function(){
	                                for (i in data) {
	                                    var dw = data[i];                                    
	                                    removeBadExternalIdentifiers(dw);                                       
	                                    groupedActivitiesUtil.group(dw,GroupedActivities.PEER_REVIEW,peerReviewSrvc.groups);
	                                };
	                            });
	                            if(peerReviewSrvc.peerReviewsToAddIds.length == 0 ) {
	                                peerReviewSrvc.loading = false;
	                                $rootScope.$apply();
	                            } else {
	                                $rootScope.$apply();
	                                setTimeout(function(){
	                                    peerReviewSrvc.addPeerReviewsToScope(type);
	                                },50);
	                            }
	                        }
	                    }).fail(function(e) {
	                        //$rootScope.$apply(function() {
	                            peerReviewSrvc.loading = false;
	                        //});
	                        console.log("Error fetching Peer Review: " + peerReviewIds);
	                        logAjaxError(e);
	                    });
	                } else {
	                    peerReviewSrvc.loading = false;
	                };
	            },
	            getGroup: function(putCode) {
	                for (var idx in peerReviewSrvc.groups) {
	                        if (peerReviewSrvc.groups[idx].hasPut(putCode))
	                            return peerReviewSrvc.groups[idx];
	                }
	                return null;
	            },
	            getEditable: function(putCode, callback) {
	                // first check if they are the current source
	                var peerReview = peerReviewSrvc.getPeerReview(putCode);
	                if (peerReview.source == orcidVar.orcidId)
	                    callback(peerReview);
	                else {
	                    var bestMatch = null;
	                    var group = peerReviewSrvc.getGroup(putCode);
	                    for (var idx in group.activitiess) {
	                        if (group[idx].source == orcidVar.orcidId) {
	                            bestMatch = callback(group[idx]);
	                            break;
	                        }
	                    }
	                    if (bestMatch == null) 
	                        bestMatch = peerReviewSrvc.createNew(peerReview);
	                        callback(bestMatch);
	                    };
	            },
	            getPeerReview: function(putCode) {
	                for (var idx in peerReviewSrvc.groups) {
	                        if (peerReviewSrvc.groups[idx].hasPut(putCode))
	                            return peerReviewSrvc.groups[idx].getByPut(putCode);
	                }
	                return null;
	            },
	            deleteGroupPeerReview: function(putCodes) {
	                var rmPeerReview = new Array();
	                var rmGroups = new Array();
	                for (var idj in putCodes)
	                    for (var idx in peerReviewSrvc.groups) {
	                        if (peerReviewSrvc.groups[idx].hasPut(putCodes[idj])) {
	                            rmGroups.push(idx);
	                            for (var idj in peerReviewSrvc.groups[idx].activities)
	                                rmPeerReview.push(peerReviewSrvc.groups[idx].activities[idj].putCode.value);
	                        };
	                    }
	                while (rmGroups.length > 0) 
	                    peerReviewSrvc.groups.splice(rmGroups.pop(),1);
	                peerReviewSrvc.removePeerReview(rmPeerReview);
	            },
	            deletePeerReview: function(putCode) {
	                peerReviewSrvc.removePeerReview([putCode], function() {peerReviewSrvc.loadPeerReviews(peerReviewSrvc.constants.access_type.USER);});
	            },
	            makeDefault: function(group, putCode) {
	                group.makeDefault(putCode);
	                $.ajax({
	                    url: getBaseUri() + '/peer-reviews/updateToMaxDisplay.json?putCode=' + putCode,
	                    type: 'GET',
	                    dataType: 'json',
	                    success: function(data) {
	                    }
	                }).fail(function(){
	                    // something bad is happening!
	                    console.log("Error: peerReviewSrvc.makeDefault method");
	                });
	            },
	            removePeerReview: function(putCodes,callback) {
	                $.ajax({
	                    url: getBaseUri() + '/peer-reviews/' + putCodes.splice(0,150).join(),
	                    type: 'DELETE',
	                    contentType: 'application/json;charset=UTF-8',
	                    dataType: 'json',
	                    success: function(data) {
	                        if (putCodes.length > 0) 
	                            peerReviewSrvc.removePeerReview(putCodes,callback);
	                        else if (callback)
	                            callback(data);
	                    }
	                }).fail(function() {
	                    console.log("Error deleting Peer Review.");
	                });
	            },
	            setGroupPrivacy: function(putCode, priv) {
	                var group = peerReviewSrvc.getGroup(putCode);
	                var putCodes = new Array();
	                for (var idx in group.activities) {
	                    putCodes.push(group.activities[idx].putCode.value);
	                    group.activities[idx].visibility = priv;
	                }
	                peerReviewSrvc.updateVisibility(putCodes, priv);
	            },
	            setPrivacy: function(putCode, priv) {
	                peerReviewSrvc.updateVisibility([putCode], priv);
	            },
	            updateVisibility: function(putCodes, priv) {
	                $.ajax({
	                    url: getBaseUri() + '/peer-reviews/' + putCodes.splice(0,150).join() + '/visibility/'+priv.toLowerCase(),
	                    type: 'GET',
	                    contentType: 'application/json;charset=UTF-8',
	                    dataType: 'json',
	                    success: function(data) {
	                        if (putCodes.length > 0)
	                            peerReviewSrvc.updateVisibility(putCodes, priv);
	                    }
	                }).fail(function() {
	                    console.log("Error updating profile Peer Review.");
	                });
	            },
	            peerReviewCount: function() {
	                var count = 0;
	                for (var idx in peerReviewSrvc.groups) {
	                    count += peerReviewSrvc.groups[idx].activitiesCount;
	                }
	                return count;
	            },
	            getPeerReviewGroupDetails: function(groupIDPutCode, putCode){
	                if(groupIDPutCode != undefined) {
	                    if (peerReviewSrvc.peerReviewGroupDetailsRequested.indexOf(groupIDPutCode) < 0){                    
	                        peerReviewSrvc.peerReviewGroupDetailsRequested.push(groupIDPutCode);                    
	                        var group = peerReviewSrvc.getGroup(putCode);
	                        $.ajax({
	                            url: getBaseUri() + '/public/group/' + groupIDPutCode,
	                            dataType: 'json',
	                            contentType: 'application/json;charset=UTF-8',
	                            type: 'GET',
	                            success: function(data) {
	                                $rootScope.$apply(function(){
	                                    console.log(angular.toJson(data));
	                                    group.groupName = data.name;
	                                    group.groupDescription = data.description;
	                                    group.groupType = data.type;
	                                });
	                            }
	                        }).fail(function(xhr, status, error){
	                            console.log("Error: " + status + "\nError: " + error + "\nError detail: " + xhr.responseText);
	                        });
	                        
	                    }
	                } else {
	                    console.log("Error: undefined group id for peer review with put code: " + putCode);  
	                }       
	            }
	    };
	    return peerReviewSrvc;
	}]);

	/*
	 * CONTROLLERS
	 */

	angular.module('orcidApp').controller('EditTableCtrl', ['$scope', function ($scope) {

	    // email edit row
	    $scope.emailUpdateToggleText = function () {
	        if ($scope.showEditEmail) $scope.emailToggleText = om.get("manage.editTable.hide");
	        else $scope.emailToggleText = om.get("manage.editTable.edit");
	    };

	    $scope.toggleEmailEdit = function() {
	        $scope.showEditEmail = !$scope.showEditEmail;
	        $scope.emailUpdateToggleText();
	    };
	    
	    $scope.openEmailEdit = function() {
	        $scope.showEditEmail = true;
	        $scope.emailUpdateToggleText();
	        window.location.hash = "#editEmail"
	    };
	    
	    /* Language preferences */
	    $scope.toggleLanguageEdit = function() {
	        $scope.showEditLanguage = !$scope.showEditLanguage;
	        $scope.languageUpdateToggleText();
	    };    
	    
	    $scope.languageUpdateToggleText = function () {
	        if ($scope.showEditLanguage) $scope.languageToggleText = om.get("manage.editTable.hide");
	        else $scope.languageToggleText = om.get("manage.editTable.edit");
	    };
	    
	    $scope.languageUpdateToggleText();

	    // init email edit row
	    $scope.showEditEmail = (window.location.hash === "#editEmail");
	    $scope.emailUpdateToggleText();

	    // password edit row
	    $scope.passwordUpdateToggleText = function () {
	        if ($scope.showEditPassword) $scope.passwordToggleText = om.get("manage.editTable.hide");
	        else $scope.passwordToggleText = om.get("manage.editTable.edit");
	    };

	    $scope.togglePasswordEdit = function() {
	        $scope.showEditPassword = !$scope.showEditPassword;
	        $scope.passwordUpdateToggleText();
	    };

	    // init password row
	    $scope.showEditPassword = (window.location.hash === "#editPassword");
	    $scope.passwordUpdateToggleText();

	    // deactivate edit row
	    $scope.deactivateUpdateToggleText = function () {
	        if ($scope.showEditDeactivate) $scope.deactivateToggleText = om.get("manage.editTable.hide");
	        else $scope.deactivateToggleText = om.get("manage.editTable.deactivateRecord");
	    };

	    $scope.toggleDeactivateEdit = function() {
	        $scope.showEditDeactivate = !$scope.showEditDeactivate;
	        $scope.deactivateUpdateToggleText();
	    };

	    $scope.fixIE7zIndexes = function() {
	        fixZindexIE7('tr', 999999);
	        fixZindexIE7('#privacy-settings', 5000);
	    };

	    // init deactivate and Z-Indexes Fix
	    $scope.showEditDeactivate = (window.location.hash === "#editDeactivate");
	    $scope.deactivateUpdateToggleText();
	    $scope.fixIE7zIndexes();

	    // privacy preferences edit row
	    $scope.privacyPreferencesUpdateToggleText = function () {
	        if ($scope.showEditPrivacyPreferences) $scope.privacyPreferencesToggleText = om.get("manage.editTable.hide");
	        else $scope.privacyPreferencesToggleText = om.get("manage.editTable.edit");
	    };

	    $scope.togglePrivacyPreferencesEdit = function() {
	        $scope.showEditPrivacyPreferences = !$scope.showEditPrivacyPreferences;
	        $scope.privacyPreferencesUpdateToggleText();
	    };

	    // init privacy preferences
	    $scope.showEditPrivacyPreferences = (window.location.hash === "#editPrivacyPreferences");
	    $scope.privacyPreferencesUpdateToggleText();

	    // email preferences edit row
	    $scope.emailPreferencesUpdateToggleText = function () {
	        if ($scope.showEditEmailPreferences) $scope.emailPreferencesToggleText = om.get("manage.editTable.hide");
	        else $scope.emailPreferencesToggleText = om.get("manage.editTable.edit");
	    };

	    $scope.toggleEmailPreferencesEdit = function() {
	        $scope.showEditEmailPreferences = !$scope.showEditEmailPreferences;
	        $scope.emailPreferencesUpdateToggleText();
	    };
	    
	    // init email preferences
	    $scope.showEditEmailPreferences = (window.location.hash === "#editEmailPreferences");
	    $scope.emailPreferencesUpdateToggleText();
	    
	    // security question edit row
	    $scope.securityQuestionUpdateToggleText = function () {
	        if ($scope.showEditSecurityQuestion) $scope.securityQuestionToggleText = om.get("manage.editTable.hide");
	        else $scope.securityQuestionToggleText = om.get("manage.editTable.edit");
	    };

	    $scope.toggleSecurityQuestionEdit = function() {
	        $scope.showEditSecurityQuestion = !$scope.showEditSecurityQuestion;
	        $scope.securityQuestionUpdateToggleText();
	    };

	    // init security question
	    $scope.showEditSecurityQuestion = (window.location.hash === "#editSecurityQuestion");
	    $scope.securityQuestionUpdateToggleText();

	    /* Social Networks */

	    $scope.socialNetworksUpdateToggleText = function () {
	        if ($scope.showEditSocialSettings) $scope.socialNetworksToggleText = om.get("manage.socialNetworks.hide");
	        else $scope.socialNetworksToggleText = om.get("manage.socialNetworks.edit");
	    };

	    $scope.toggleSocialNetworksEdit = function(){
	        $scope.showEditSocialSettings = !$scope.showEditSocialSettings;
	        $scope.socialNetworksUpdateToggleText();
	    };   
	    

	    //init social networks row
	    $scope.showEditSocialSettings = (window.location.hash === "#editSocialNetworks");
	    $scope.socialNetworksUpdateToggleText();
	}]);

	angular.module('orcidApp').controller('NotificationPreferencesCtrl',['$scope', '$compile', 'emailSrvc', 'prefsSrvc', 'emailSrvc',function ($scope, $compile, emailSrvc, prefsSrvc, emailSrvc) {
	    $scope.prefsSrvc = prefsSrvc;
	    $scope.emailSrvc = emailSrvc;
	}]);

	angular.module('orcidApp').controller('EmailFrequencyCtrl',['$scope', '$compile', 'emailSrvc', 'prefsSrvc', function ($scope, $compile, emailSrvc, prefsSrvc) {
	    $scope.prefsSrvc = prefsSrvc;
	    $scope.emailSrvc = emailSrvc;
	    
	}]);

	angular.module('orcidApp').controller('EmailFrequencyLinkCtrl',['$scope','$rootScope', function ($scope, $rootScope) {
	    $scope.getEmailFrequencies = function() {
	        $.ajax({
	            url: window.location.href + '/email-frequencies.json',
	            type: 'GET',
	            dataType: 'json',
	            success: function(data) {
	                $scope.emailFrequency = data;
	                $rootScope.$apply();
	            }
	        }).fail(function() {
	            console.log("error with frequency");
	        });
	    };
	    
	    $scope.saveEmailFrequencies = function() {
	        $.ajax({
	            url: window.location.href + '/email-frequencies.json',
	            type: 'POST',
	            data: angular.toJson($scope.emailFrequency),
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                $scope.emailFrequency = data;
	                $rootScope.$apply();
	            }
	        }).fail(function() {
	            console.log("error with frequency");
	        });
	    };
	    
	    $scope.getEmailFrequencies();
	}]);

	angular.module('orcidApp').controller('WorksPrivacyPreferencesCtrl',['$scope', 'prefsSrvc', 'commonSrvc', function ($scope, prefsSrvc, commonSrvc) {
	    $scope.prefsSrvc = prefsSrvc;
	    $scope.privacyHelp = {};
	    $scope.showElement = {};
	    $scope.commonSrvc = commonSrvc;

	    $scope.toggleClickPrivacyHelp = function(key) {
	        if (!document.documentElement.className.contains('no-touch'))
	            $scope.privacyHelp[key]=!$scope.privacyHelp[key];
	    };

	    $scope.updateActivitiesVisibilityDefault = function(priv, $event) {
	        $scope.prefsSrvc.prefs.activitiesVisibilityDefault.value = priv;
	        $scope.prefsSrvc.savePrivacyPreferences();
	    };
	    
	    $scope.showTooltip = function(el){
	        $scope.showElement[el] = true;
	    };
	    
	    $scope.hideTooltip = function(el){
	        $scope.showElement[el] = false;
	    };
	}]);

	angular.module('orcidApp').controller('EmailPreferencesCtrl',['$scope', 'prefsSrvc', function ($scope, prefsSrvc) {
	    $scope.prefsSrvc = prefsSrvc;
	}]);

	angular.module('orcidApp').controller('DeactivateAccountCtrl', ['$scope', '$compile', function ($scope, $compile) {
	    $scope.sendDeactivateEmail = function() {
	        orcidGA.gaPush(['send', 'event', 'Disengagement', 'Deactivate_Initiate', 'Website']);
	        $.ajax({
	            url: getBaseUri() + '/account/send-deactivate-account.json',
	            dataType: 'json',
	            success: function(data) {
	                $scope.primaryEmail = data.value;
	                $.colorbox({
	                    html : $compile($('#deactivate-account-modal').html())($scope)
	                });
	                $scope.$apply();
	                $.colorbox.resize();
	            }
	        }).fail(function() {
	            // something bad is happening!
	            console.log("error with change DeactivateAccount");
	        });
	    };

	    $scope.closeModal = function() {
	        $.colorbox.close();
	    };
	}]);

	angular.module('orcidApp').controller('SecurityQuestionEditCtrl', ['$scope', '$compile', function ($scope, $compile) {
	    $scope.errors = null;
	    $scope.password = null;
	    $scope.securityQuestions = [];

	    $scope.getSecurityQuestion = function() {
	        $.ajax({
	            url: getBaseUri() + '/account/security-question.json',
	            dataType: 'json',
	            success: function(data) {               
	                $scope.securityQuestionPojo = data;
	                $scope.$apply();
	            }
	        }).fail(function() {
	            // something bad is happening!
	            console.log("error with security question.json");
	        });
	    };

	    $scope.getSecurityQuestion();

	    $scope.checkCredentials = function() {
	        $scope.password=null;
	        if(orcidVar.isPasswordConfirmationRequired){
	            $.colorbox({
	                html: $compile($('#check-password-modal').html())($scope)
	            });
	            $.colorbox.resize();
	        }
	        else{
	            $scope.submitModal();
	        }
	    };

	    $scope.submitModal = function() {
	        $scope.securityQuestionPojo.password=$scope.password;
	        $.ajax({
	            url: getBaseUri() + '/account/security-question.json',
	            type: 'POST',
	            data: angular.toJson($scope.securityQuestionPojo),
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                
	                if(data.errors.length != 0) {
	                    $scope.errors=data.errors;
	                } else {
	                    $scope.errors=null;
	                }
	                $scope.getSecurityQuestion();
	                $scope.$apply();
	            }
	        }).fail(function() {
	            // something bad is happening!
	            console.log("error with security question");
	        });
	        $scope.password=null;
	        $.colorbox.close();
	    };

	    $scope.closeModal = function() {
	        $.colorbox.close();
	    };
	}]);

	angular.module('orcidApp').controller('PasswordEditCtrl', ['$scope', '$http', function ($scope, $http) {
	    $scope.getChangePassword = function() {
	        $.ajax({
	            url: getBaseUri() + '/account/change-password.json',
	            dataType: 'json',
	            success: function(data) {
	                $scope.changePasswordPojo = data;
	                $scope.$apply();
	                $scope.zIndexfixIE7();
	            }
	        }).fail(function() {
	            // something bad is happening!
	            console.log("error with change password");
	        });
	    };

	    $scope.getChangePassword();

	    $scope.zIndexfixIE7 = function(){
	        fixZindexIE7('#password-edit', 999999);
	        fixZindexIE7('#password-edit .relative', 99999);
	    };

	    $scope.saveChangePassword = function() {
	        $.ajax({
	            url: getBaseUri() + '/account/change-password.json',
	            type: 'POST',
	            data: angular.toJson($scope.changePasswordPojo),
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                $scope.changePasswordPojo = data;
	                $scope.$apply();
	            }
	        }).fail(function() {
	            // something bad is happening!
	            console.log("error with edit password");
	        });
	    };
	}]);




	angular.module('orcidApp').controller('ExternalIdentifierCtrl', ['$scope', '$compile', 'bioBulkSrvc', 'commonSrvc', function ($scope, $compile, bioBulkSrvc, commonSrvc){
	    bioBulkSrvc.initScope($scope);
	    $scope.externalIdentifiersForm = null;
	    $scope.orcidId = orcidVar.orcidId;
	    $scope.primary = true;
	    $scope.showElement = [];
	    $scope.scrollTop = 0;
	    $scope.commonSrvc = commonSrvc;
	    
	    $scope.getExternalIdentifiersForm = function(){
	        $.ajax({
	            url: getBaseUri() + '/my-orcid/externalIdentifiers.json',
	            dataType: 'json',
	            success: function(data) {
	                $scope.externalIdentifiersForm = data;
	                $scope.displayIndexInit();
	                $scope.$apply();
	            }
	        }).fail(function(e){
	            // something bad is happening!
	            console.log("error fetching external identifiers");
	            logAjaxError(e);
	        });
	    }

	    $scope.setExternalIdentifiersForm = function(){     
	        $scope.externalIdentifiersForm.visibility = null;
	        $.ajax({
	            url: getBaseUri() + '/my-orcid/externalIdentifiers.json',
	            type: 'POST',
	            data:  angular.toJson($scope.externalIdentifiersForm),
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                $scope.externalIdentifiersForm = data;
	                if ($scope.externalIdentifiersForm.errors.length == 0){                    
	                    $scope.getExternalIdentifiersForm();                
	                    $scope.closeEditModal();
	                }else{
	                    console.log($scope.externalIdentifiersForm.errors);
	                }
	                
	                $scope.$apply();
	            }
	        }).fail(function() {
	            // something bad is happening!
	            console.log("ExternalIdentifierCtrl.serverValidate() error");
	        });
	    }
	    
	    
	    $scope.setPrivacy = function(priv, $event) {
	        $event.preventDefault();
	        $scope.externalIdentifiersForm.visibility.visibility = priv;
	    };
	    
	    $scope.setPrivacyModal = function(priv, $event, externalIdentifier) {        
	        $event.preventDefault();        
	        
	        var externalIdentifiers = $scope.externalIdentifiersForm.externalIdentifiers;
	        var len = externalIdentifiers.length;
	        
	        while (len--)
	            if (externalIdentifiers[len] == externalIdentifier)            
	                externalIdentifiers[len].visibility.visibility = priv;        
	    };  
	    
	    
	    $scope.openEditModal = function(){      
	        $scope.bulkEditShow = false;
	        $.colorbox({
	            scrolling: true,
	            html: $compile($('#edit-external-identifiers').html())($scope),
	            onLoad: function() {
	                $('#cboxClose').remove();
	            },
	            width: formColorBoxResize(),
	            onComplete: function() {

	            },
	            onClosed: function() {
	                $scope.getExternalIdentifiersForm();
	            }
	        });
	        $.colorbox.resize();
	    }
	    
	    $scope.deleteExternalIdentifierConfirmation = function(idx){
	        $scope.removeExternalIdentifierIndex = idx;
	        $scope.removeExternalModalText = $scope.externalIdentifiersForm.externalIdentifiers[idx].reference;
	        if ($scope.externalIdentifiersForm.externalIdentifiers[idx].commonName != null)
	            $scope.removeExternalModalText = $scope.externalIdentifiersForm.externalIdentifiers[idx].commonName + ' ' + $scope.removeExternalModalText;
	        $.colorbox({
	            html: $compile($('#delete-external-id-modal').html())($scope)
	        });
	        $.colorbox.resize();
	    }
	    
	    $scope.removeExternalIdentifier = function() {
	        var externalIdentifier = $scope.externalIdentifiersForm.externalIdentifiers[$scope.removeExternalIdentifierIndex];
	        $.ajax({
	            url: getBaseUri() + '/my-orcid/externalIdentifiers.json',
	            type: 'DELETE',
	            data: angular.toJson(externalIdentifier),
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                if(data.errors.length != 0){
	                    console.log("Unable to delete external identifier.");
	                } else {
	                    $scope.externalIdentifiersForm.externalIdentifiers.splice($scope.removeExternalIdentifierIndex, 1);
	                    $scope.removeExternalIdentifierIndex = null;
	                    $scope.$apply();
	                }
	            }
	        }).fail(function() {
	            console.log("Error deleting external identifier.");
	        });
	        $.colorbox.close();
	    };
	    
	    //Person 2
	    $scope.deleteExternalIdentifier = function(externalIdentifier){
	        var externalIdentifiers = $scope.externalIdentifiersForm.externalIdentifiers;
	        var len = externalIdentifiers.length;
	        while (len--) {
	            if (externalIdentifiers[len] == externalIdentifier){
	                externalIdentifiers.splice(len,1);
	                $scope.externalIdentifiersForm.externalIdentifiers = externalIdentifiers;
	            }       
	        }
	    };
	    
	    $scope.swapUp = function(index){
	        if (index > 0) {
	            var temp = $scope.externalIdentifiersForm.externalIdentifiers[index];
	            var tempDisplayIndex = $scope.externalIdentifiersForm.externalIdentifiers[index]['displayIndex'];
	            temp['displayIndex'] = $scope.externalIdentifiersForm.externalIdentifiers[index - 1]['displayIndex']
	            $scope.externalIdentifiersForm.externalIdentifiers[index] = $scope.externalIdentifiersForm.externalIdentifiers[index - 1];
	            $scope.externalIdentifiersForm.externalIdentifiers[index]['displayIndex'] = tempDisplayIndex;
	            $scope.externalIdentifiersForm.externalIdentifiers[index - 1] = temp;
	        }
	    };

	    $scope.swapDown = function(index){
	        if (index < $scope.externalIdentifiersForm.externalIdentifiers.length - 1) {
	            var temp = $scope.externalIdentifiersForm.externalIdentifiers[index];
	            var tempDisplayIndex = $scope.externalIdentifiersForm.externalIdentifiers[index]['displayIndex'];
	            temp['displayIndex'] = $scope.externalIdentifiersForm.externalIdentifiers[index + 1]['displayIndex']
	            $scope.externalIdentifiersForm.externalIdentifiers[index] = $scope.externalIdentifiersForm.externalIdentifiers[index + 1];
	            $scope.externalIdentifiersForm.externalIdentifiers[index]['displayIndex'] = tempDisplayIndex;
	            $scope.externalIdentifiersForm.externalIdentifiers[index + 1] = temp;
	        }
	    };           
	   
	   //To fix displayIndex values that comes with -1
	   $scope.displayIndexInit = function(){
	       for (var idx in $scope.externalIdentifiersForm.externalIdentifiers) {            
	           $scope.externalIdentifiersForm.externalIdentifiers[idx]['displayIndex'] = $scope.externalIdentifiersForm.externalIdentifiers.length - idx;
	       }       
	   };
	    
	   $scope.closeEditModal = function(){
	       $.colorbox.close();
	   };
	   
	   $scope.setBulkGroupPrivacy = function(priv) {
	       for (var idx in $scope.externalIdentifiersForm.externalIdentifiers)     
	           $scope.externalIdentifiersForm.externalIdentifiers[idx].visibility.visibility = priv;        
	   };

	   //init
	   $scope.getExternalIdentifiersForm();  
	}]);

	angular.module('orcidApp').controller('ResetPasswordCtrl', ['$scope', '$compile', 'commonSrvc',function ($scope, $compile, commonSrvc) {
	    $scope.getResetPasswordForm = function(){
	        $.ajax({
	            url: getBaseUri() + '/password-reset.json',
	            dataType: 'json',
	            success: function(data) {
	                $scope.resetPasswordForm = data;
	                $scope.$apply();
	            }
	        }).fail(function(){
	        // something bad is happening!
	            console.log("error fetching password-reset.json");
	        });
	    };

	    $scope.serverValidate = function () {
	        $.ajax({
	            url: getBaseUri() + '/reset-password-form-validate.json',
	            type: 'POST',
	            data:  angular.toJson($scope.resetPasswordForm),
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                commonSrvc.copyErrorsLeft($scope.resetPasswordForm, data);
	                $scope.$apply();
	            }
	        }).fail(function() {
	            // something bad is happening!
	            console.log("ResetPasswordCtrl.serverValidate() error");
	        });
	    };

	    //init
	    $scope.getResetPasswordForm();
	}]);

	angular.module('orcidApp').controller('RegistrationCtrl', ['$scope', '$compile', 'commonSrvc', 'vcRecaptchaService', function ($scope, $compile, commonSrvc, vcRecaptchaService) {
	    $scope.privacyHelp = {};
	    $scope.recaptchaWidgetId = null;
	    $scope.recatchaResponse = null;
	    $scope.showDeactivatedError = false;
	    $scope.showReactivationSent = false;
	    
	    $scope.model = {
	        key: orcidVar.recaptchaKey
	    };
	    
	    var loadDate = new Date();
	    $scope.loadTime = loadDate.getTime();

	    $scope.toggleClickPrivacyHelp = function(key) {
	        if (!document.documentElement.className.contains('no-touch'))
	            $scope.privacyHelp[key]=!$scope.privacyHelp[key];
	    };
	    
	    $scope.getRegister = function(givenName, familyName, email, linkFlag){
	        $.ajax({
	            url: getBaseUri() + '/register.json',
	            dataType: 'json',
	            success: function(data) {
	               $scope.register = data;
	               $scope.register.givenNames.value=givenName;
	               $scope.register.familyNames.value=familyName;
	               $scope.register.email.value=email;
	               $scope.register.linkType=linkFlag;
	               $scope.$apply();               
	    
	                // make sure inputs stayed trimmed
	                $scope.$watch('register.email.value', function(newValue, oldValue) {
	                    if(newValue !== oldValue) {
	                        trimAjaxFormText($scope.register.email);
	                    }
	                }); // initialize the watch
	                
	                // special handling of deactivation error
	                $scope.$watch('register.email.errors', function(newValue, oldValue) {
	                        $scope.showDeactivatedError = ($.inArray('orcid.frontend.verify.deactivated_email', $scope.register.email.errors) != -1);
	                        $scope.showReactivationSent = false;
	                }); // initialize the watch     
	                
	                // make sure email is trimmed
	                $scope.$watch('register.emailConfirm.value', function(newValue, oldValue) {
	                    if(newValue !== oldValue){
	                        trimAjaxFormText($scope.register.emailConfirm);
	                        $scope.serverValidate('EmailConfirm');
	                    }
	                }); // initialize the watch
	    
	                $scope.$watch('register.givenNames.value', function() {
	                    trimAjaxFormText($scope.register.givenNames);
	                }); // initialize the watch
	    
	                $scope.$watch('register.familyNames.value', function() {
	                     trimAjaxFormText($scope.register.familyNames);
	                }); // initialize the watch
	            }
	        }).fail(function(){
	        // something bad is happening!
	            console.log("error fetching register.json");
	        });
	    };
	    
	    $scope.getDuplicates = function(){
	        $.ajax({
	            //url: getBaseUri() + 'dupicateResearcher.json?familyNames=test&givenNames=test',
	            url: getBaseUri() + '/dupicateResearcher.json?familyNames=' + $scope.register.familyNames.value + '&givenNames=' + $scope.register.givenNames.value,
	            dataType: 'json',
	            success: function(data) {
	                $scope.duplicates = data;
	                $scope.$apply();
	                var diffDate = new Date();
	                // reg was filled out to fast reload the page
	                if ($scope.loadTime + 5000 > diffDate.getTime()) {
	                    window.location.reload();
	                    return;
	                }
	                if ($scope.duplicates.length > 0 ) {
	                    $scope.showDuplicatesColorBox();
	                } else {
	                    $scope.postRegisterConfirm();
	                }
	            }
	        }).fail(function(){
	            // something bad is happening!
	            console.log("error fetching dupicateResearcher.json");
	            // continue to registration, as solr dup lookup failed.
	            $scope.postRegisterConfirm();
	        });
	    };


	    $scope.updateActivitiesVisibilityDefault = function(priv, $event) {
	        $scope.register.activitiesVisibilityDefault.visibility = priv;
	    };

	    $scope.postRegister = function (linkFlag) {
	        if (basePath.startsWith(baseUrl + 'oauth')) {
	            var clientName = $('div#RegistrationCtr input[name="client_name"]').val();
	            $scope.register.referredBy = $('div#RegistrationCtr input[name="client_id"]').val();
	            var clientGroupName = $('div#RegistrationCtr input[name="client_group_name"]').val();
	            orcidGA.gaPush(['send', 'event', 'RegGrowth', 'New-Registration-Submit' , 'OAuth ' + orcidGA.buildClientString(clientGroupName, clientName)]);
	            $scope.register.creationType.value = "Member-referred";
	        } else {
	            orcidGA.gaPush(['send', 'event', 'RegGrowth', 'New-Registration-Submit', 'Website']);
	            $scope.register.creationType.value = "Direct";
	        }        
	        
	        $scope.register.grecaptcha.value = $scope.recatchaResponse; //Adding the response to the register object
	        $scope.register.grecaptchaWidgetId.value = $scope.recaptchaWidgetId;
	        console.log('link flag is : '+ linkFlag);
	        $scope.register.linkType = linkFlag;
	        $.ajax({
	            url: getBaseUri() + '/register.json',
	            type: 'POST',
	            data:  angular.toJson($scope.register),
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                console.log(data);
	                $scope.register = data;             
	                $scope.$apply();                
	                if ($scope.register.errors == undefined || $scope.register.errors == undefined || $scope.register.errors.length == 0) {
	                    if ($scope.register.errors.length == 0) {
	                        
	                        $scope.showProcessingColorBox();
	                        $scope.getDuplicates();
	                    }
	                } else {
	                    if ($scope.register.grecaptcha.errors.length == 0) angular.element(document.querySelector('#recaptcha')).remove();
	                }
	            }
	        }).fail(function() {
	            // something bad is happening!
	            console.log("RegistrationCtrl.postRegister() error");
	        });
	    };

	    $scope.postRegisterConfirm = function () {
	        $scope.showProcessingColorBox();
	        $scope.register.valNumClient = $scope.register.valNumServer / 2;
	        var baseUri = getBaseUri();
	        if($scope.register.linkType === 'shibboleth'){
	            baseUri += '/shibboleth';
	        }
	        $.ajax({
	            url: baseUri + '/registerConfirm.json',
	            type: 'POST',
	            data:  angular.toJson($scope.register),
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                if(data != null && data.errors != null && data.errors.length > 0) {
	                    $scope.generalRegistrationError = data.errors[0];
	                    console.log($scope.generalRegistrationError);
	                    $scope.$apply();
	                    $.colorbox.close();
	                } else {
	                    if (basePath.startsWith(baseUrl + 'oauth')) {
	                        var clientName = $('div#RegistrationCtr input[name="client_name"]').val();
	                        var clientGroupName = $('div#RegistrationCtr input[name="client_group_name"]').val();
	                        orcidGA.gaPush(['send', 'event', 'RegGrowth', 'New-Registration', 'OAuth '+ orcidGA.buildClientString(clientGroupName, clientName)]);
	                    } else {
	                        orcidGA.gaPush(['send', 'event', 'RegGrowth', 'New-Registration', 'Website']);
	                    }                        
	                    orcidGA.windowLocationHrefDelay(data.url);
	                }                
	            }
	        }).fail(function() {
	            // something bad is happening!
	            console.log("RegistrationCtrl.postRegister() error");
	        });
	    };

	    $scope.serverValidate = function (field) {        
	        if (field === undefined) field = '';
	        $.ajax({
	            url: getBaseUri() + '/register' + field + 'Validate.json',
	            type: 'POST',
	            data:  angular.toJson($scope.register),
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                commonSrvc.copyErrorsLeft($scope.register, data);
	                $scope.$apply();
	            }
	        }).fail(function() {
	            // something bad is happening!
	            console.log("RegistrationCtrl.serverValidate() error");
	        });
	    };

	    $scope.showProcessingColorBox = function () {
	        $.colorbox({
	            html : $('<div style="font-size: 50px; line-height: 60px; padding: 20px; text-align:center">' + om.get('common.processing') + '&nbsp;<i id="ajax-loader" class="glyphicon glyphicon-refresh spin green"></i></div>'),
	            width: '400px',
	            height:"100px",
	            close: '',
	            escKey:false,
	            overlayClose:false,
	            onComplete: function() {
	                $.colorbox.resize({width:"400px" , height:"100px"});
	            }
	        });
	    };

	    $scope.showDuplicatesColorBox = function () {
	        $.colorbox({
	            html : $compile($('#duplicates').html())($scope),
	            escKey:false,
	            overlayClose:false,
	            transition: 'fade',
	            close: '',
	            scrolling: true
	            });
	        $scope.$apply();
	        $.colorbox.resize({width:"780px" , height:"400px"});
	    };

	    $scope.hideProcessingColorBox = function () {
	        $.colorbox.close();
	    };

	    $scope.isValidClass = function (cur) {
	        if (cur === undefined) return '';
	        var valid = true;
	        if (cur.required && (cur.value == null || cur.value.trim() == '')) valid = false;
	        if (cur.errors !== undefined && cur.errors.length > 0) valid = false;
	        return valid ? '' : 'text-error';
	    };
	        
	    $scope.setRecaptchaWidgetId = function (widgetId) {  
	        $scope.recaptchaWidgetId = widgetId;
	    };

	    $scope.setRecatchaResponse = function (response) {
	        $scope.recatchaResponse = response;
	    };
	    
	    $scope.sendReactivationEmail = function () {
	        $scope.showDeactivatedError = false;
	        $scope.showReactivationSent = true;
	        $.ajax({
	            url: getBaseUri() + '/sendReactivation.json',
	            type: "POST",
	            data: { email: $scope.register.email.value },
	            dataType: 'json',
	        }).fail(function(){
	        // something bad is happening!
	            console.log("error sending reactivation email");
	        });
	    };
	    
	}]);

	angular.module('orcidApp').controller('ReactivationCtrl', ['$scope', '$compile', 'commonSrvc', 'vcRecaptchaService', function ($scope, $compile, commonSrvc, vcRecaptchaService) {
	    
	    $scope.privacyHelp = {};

	    $scope.toggleClickPrivacyHelp = function(key) {
	        if (!document.documentElement.className.contains('no-touch'))
	            $scope.privacyHelp[key]=!$scope.privacyHelp[key];
	    };

	    $scope.updateActivitiesVisibilityDefault = function(priv, $event) {
	        $scope.register.activitiesVisibilityDefault.visibility = priv;
	    };

	    $scope.getReactivation = function(resetParams, linkFlag){
	        $.ajax({
	            url: getBaseUri() + '/register.json',
	            dataType: 'json',
	            success: function(data) {
	               $scope.register = data;
	               $scope.register.resetParams = resetParams;
	               $scope.$apply();               
	    
	               $scope.$watch('register.givenNames.value', function() {
	                   trimAjaxFormText($scope.register.givenNames);
	               }); // initialize the watch
	    
	               $scope.$watch('register.familyNames.value', function() {
	                    trimAjaxFormText($scope.register.familyNames);
	               }); // initialize the watch
	            }
	        }).fail(function(){
	        // something bad is happening!
	            console.log("error fetching register.json");
	        });
	    };
	    
	    $scope.postReactivationConfirm = function () {
	        $scope.register.valNumClient = $scope.register.valNumServer / 2;
	        var baseUri = getBaseUri();
	        if($scope.register.linkType === 'shibboleth'){
	            baseUri += '/shibboleth';
	        }
	        $.ajax({
	            url: baseUri + '/reactivationConfirm.json',
	            type: 'POST',
	            data:  angular.toJson($scope.register),
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                if(data.errors.length == 0){
	                    window.location.href = data.url;
	                }
	                else{
	                    $scope.register = data;
	                    $scope.$apply();
	                }
	            }
	        }).fail(function() {
	            // something bad is happening!
	            console.log("ReactivationCtrl.postReactivationConfirm() error");
	        });
	    };

	    $scope.serverValidate = function (field) {        
	        if (field === undefined) field = '';
	        $.ajax({
	            url: getBaseUri() + '/register' + field + 'Validate.json',
	            type: 'POST',
	            data:  angular.toJson($scope.register),
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                commonSrvc.copyErrorsLeft($scope.register, data);
	                $scope.$apply();
	            }
	        }).fail(function() {
	            // something bad is happening!
	            console.log("RegistrationCtrl.serverValidate() error");
	        });
	    };

	    $scope.isValidClass = function (cur) {
	        if (cur === undefined) return '';
	        var valid = true;
	        if (cur.required && (cur.value == null || cur.value.trim() == '')) valid = false;
	        if (cur.errors !== undefined && cur.errors.length > 0) valid = false;
	        return valid ? '' : 'text-error';
	    };
	        
	}]);


	angular.module('orcidApp').controller('ClaimCtrl', ['$scope', '$compile', 'commonSrvc', function ($scope, $compile, commonSrvc) {
	    $scope.postingClaim = false;
	    $scope.getClaim = function(){
	        $.ajax({
	            url: $scope.getClaimAjaxUrl(),
	            dataType: 'json',
	            success: function(data) {
	               $scope.register = data;
	            $scope.$apply();
	            }
	        }).fail(function(){
	        // something bad is happening!
	            console.log("error fetching register.json");
	        });
	    };

	    $scope.postClaim = function () {
	        if ($scope.postingClaim) return;
	        $scope.postingClaim = true;
	        $.ajax({
	            url: $scope.getClaimAjaxUrl(),
	            type: 'POST',
	            data:  angular.toJson($scope.register),
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                $scope.register = data;

	                if ($scope.register.errors.length == 0) {
	                    if ($scope.register.url != null) {
	                        orcidGA.gaPush(['send', 'event', 'RegGrowth', 'New-Registration', 'Website']);
	                        orcidGA.windowLocationHrefDelay($scope.register.url);
	                    }
	                }
	                $scope.postingClaim = false;
	                $scope.$apply();
	            }
	        }).fail(function() {
	            // something bad is happening!
	            console.log("RegistrationCtrl.postRegister() error");
	            $scope.postingClaim = false;
	        });
	    };

	    $scope.getClaimAjaxUrl = function () {
	        return window.location.href.split("?")[0]+".json";
	    };

	    $scope.updateActivitiesVisibilityDefault = function(priv, $event) {
	        $scope.register.activitiesVisibilityDefault.visibility = priv;
	    };

	    $scope.serverValidate = function (field) {
	        if (field === undefined) field = '';
	        $.ajax({
	            url: getBaseUri() + '/claim' + field + 'Validate.json',
	            type: 'POST',
	            data:  angular.toJson($scope.register),
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                //alert(angular.toJson(data));
	                commonSrvc.copyErrorsLeft($scope.register, data);
	                $scope.$apply();
	            }
	        }).fail(function() {
	            // something bad is happening!
	            console.log("RegistrationCtrl.postRegisterValidate() error");
	        });
	    };

	    $scope.isValidClass = function (cur) {
	        if (cur === undefined) return '';
	        var valid = true;
	        if (cur.required && (cur.value == null || cur.value.trim() == '')) valid = false;
	        if (cur.errors !== undefined && cur.errors.length > 0) valid = false;
	        return valid ? '' : 'text-error';
	    };

	    //init
	    $scope.getClaim();
	}]);

	angular.module('orcidApp').controller('VerifyEmailCtrl', ['$scope', '$compile', 'emailSrvc', 'initialConfigService', function ($scope, $compile, emailSrvc, initialConfigService) {
	    $scope.loading = true;
	    $scope.getEmails = function() {
	        $.ajax({
	            url: getBaseUri() + '/account/emails.json',
	            //type: 'POST',
	            //data: $scope.emailsPojo,
	            dataType: 'json',
	            success: function(data) {
	                var configuration = initialConfigService.getInitialConfiguration();
	                var primeVerified = false;

	                $scope.verifiedModalEnabled = configuration.showModalManualEditVerificationEnabled;
	                $scope.emailsPojo = data;
	                $scope.$apply();
	                for (i in $scope.emailsPojo.emails) {
	                    if ($scope.emailsPojo.emails[i].primary) {
	                        $scope.primaryEmail = $scope.emailsPojo.emails[i].value;
	                        if ($scope.emailsPojo.emails[i].verified) {
	                            primeVerified = true;
	                        }
	                    };
	                };
	                if (!primeVerified && !getBaseUri().contains("sandbox")) {
	                    var colorboxHtml = $compile($('#verify-email-modal').html())($scope);
	                    $scope.$apply();
	                    $.colorbox({
	                        html : colorboxHtml,
	                        escKey:false,
	                        overlayClose:false,
	                        transition: 'fade',
	                        close: '',
	                        scrolling: false
	                    });
	                    $.colorbox.resize();
	                };
	                $scope.loading = false;
	                $scope.$apply();
	            }
	        }).fail(function() {
	            // something bad is happening!
	            console.log("error with multi email");
	        });
	    };

	    $scope.verifyEmail = function() {
	        var colorboxHtml = null;
	        $.ajax({
	            url: getBaseUri() + '/account/verifyEmail.json',
	            type: 'get',
	            data:  { "email": $scope.primaryEmail },
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                //alert( "Verification Email Send To: " + $scope.emailsPojo.emails[idx].value);
	            }
	        }).fail(function() {
	            // something bad is happening!
	            console.log("error with multi email");
	        });
	        
	        colorboxHtml = $compile($('#verify-email-modal-sent').html())($scope);

	        $scope.emailSent = true;
	        $.colorbox({
	            html : colorboxHtml,
	            escKey: true,
	            overlayClose: true,
	            transition: 'fade',
	            close: '',
	            scrolling: false
	                    });
	        $.colorbox.resize({height:"200px", width:"500px"});
	    };

	    $scope.closeColorBox = function() {
	        $.ajax({
	            url: getBaseUri() + '/account/delayVerifyEmail.json',
	            type: 'get',
	            contentType: 'application/json;charset=UTF-8',
	            success: function(data) {
	                //alert( "Verification Email Send To: " + $scope.emailsPojo.emails[idx].value);
	            }
	        }).fail(function() {
	            // something bad is happening!
	            console.log("error with multi email");
	        });
	        $.colorbox.close();
	    };

	    $scope.emailSent = false;
	    $scope.getEmails();
	}]);

	angular.module('orcidApp').controller('ClaimThanks', ['$scope', '$compile', function ($scope, $compile) {
	    $scope.showThanks = function () {
	        var colorboxHtml;
	            if ($scope.sourceGrantReadWizard.url == null)
	                colorboxHtml = $compile($('#claimed-record-thanks').html())($scope);
	            else
	                colorboxHtml = $compile($('#claimed-record-thanks-source-grand-read').html())($scope);
	        $.colorbox({
	            html : colorboxHtml,
	            escKey: true,
	            overlayClose: true,
	            transition: 'fade',
	            close: '',
	            scrolling: false
	                    });
	        $scope.$apply(); // this seems to make sure angular renders in the colorbox
	        $.colorbox.resize();
	    };

	    $scope.getSourceGrantReadWizard = function(){
	        $.ajax({
	            url: getBaseUri() + '/my-orcid/sourceGrantReadWizard.json',
	            dataType: 'json',
	            success: function(data) {
	                $scope.sourceGrantReadWizard = data;
	                $scope.$apply();
	                $scope.showThanks();
	            }
	        }).fail(function(){
	            // something bad is happening!
	            console.log("error fetching external identifiers");
	        });

	    };

	    $scope.yes = function () {
	        $.colorbox.close();
	        var newWin = window.open($scope.sourceGrantReadWizard.url);
	        if (!newWin) window.location.href = $scope.sourceGrantReadWizard.url;
	        else newWin.focus();
	    };

	    $scope.close = function () {
	        $.colorbox.close();
	    };

	    $scope.getSourceGrantReadWizard();
	}]);

	angular.module('orcidApp').controller('PersonalInfoCtrl', ['$scope', '$compile', 'workspaceSrvc',function ($scope, $compile, workspaceSrvc){
	    $scope.displayInfo = workspaceSrvc.displayPersonalInfo;
	    $scope.toggleDisplayInfo = function () {
	        $scope.displayInfo = !$scope.displayInfo;
	    };
	}]);

	angular.module('orcidApp').controller('WorkspaceSummaryCtrl', ['$scope', '$compile', 'affiliationsSrvc', 'fundingSrvc', 'worksSrvc', 'peerReviewSrvc', 'workspaceSrvc',function ($scope, $compile, affiliationsSrvc, fundingSrvc, worksSrvc, peerReviewSrvc, workspaceSrvc){
	    $scope.workspaceSrvc = workspaceSrvc;
	    $scope.worksSrvc = worksSrvc;
	    $scope.affiliationsSrvc = affiliationsSrvc;
	    $scope.fundingSrvc = fundingSrvc;
	    $scope.peerReviewSrvc = peerReviewSrvc;
	    $scope.showAddAlert = function () {
	        if (worksSrvc.loading == false && affiliationsSrvc.loading == false && peerReviewSrvc.loading == false
	                && worksSrvc.groups.length == 0
	                && affiliationsSrvc.educations.length == 0
	                && affiliationsSrvc.employments.length == 0
	                && fundingSrvc.groups.length == 0
	                && peerReviewSrvc.groups.lenght == 0)
	            return true;
	        return false;
	    };
	}]);

	angular.module('orcidApp').controller('PublicEduAffiliation', ['$scope', '$compile', '$filter', 'workspaceSrvc', 'affiliationsSrvc', function ($scope, $compile, $filter, workspaceSrvc , affiliationsSrvc){
	    $scope.workspaceSrvc = workspaceSrvc;
	    $scope.affiliationsSrvc = affiliationsSrvc;
	    $scope.moreInfo = {};

	    $scope.sortState = new ActSortState(GroupedActivities.AFFILIATION);
	    $scope.sort = function(key) {       
	        $scope.sortState.sortBy(key);
	    };

	    // remove once grouping is live
	    $scope.toggleClickMoreInfo = function(key) {
	        if (!document.documentElement.className.contains('no-touch'))
	            $scope.moreInfo[key]=!$scope.moreInfo[key];
	    };

	    // remove once grouping is live
	    $scope.moreInfoMouseEnter = function(key, $event) {
	        $event.stopPropagation();
	        if (document.documentElement.className.contains('no-touch'))
	            $scope.moreInfo[key]=true;
	    };

	    $scope.showDetailsMouseClick = function(key, $event) {
	        $event.stopPropagation();
	        $scope.moreInfo[key] = !$scope.moreInfo[key];
	    };

	    $scope.closeMoreInfo = function(key) {
	        $scope.moreInfo[key]=false;
	    };

	}]);

	angular.module('orcidApp').controller('PublicEmpAffiliation', ['$scope', '$compile', '$filter', 'workspaceSrvc', 'affiliationsSrvc', function ($scope, $compile, $filter, workspaceSrvc, affiliationsSrvc){
	    $scope.workspaceSrvc = workspaceSrvc;
	    $scope.affiliationsSrvc = affiliationsSrvc;
	    $scope.moreInfo = {};

	    $scope.sortState = new ActSortState(GroupedActivities.AFFILIATION);
	    $scope.sort = function(key) {
	        $scope.sortState.sortBy(key);
	    };

	    $scope.toggleClickMoreInfo = function(key) {
	        if (!document.documentElement.className.contains('no-touch'))
	            $scope.moreInfo[key]=!$scope.moreInfo[key];
	    };

	    // remove once grouping is live
	    $scope.moreInfoMouseEnter = function(key, $event) {
	        $event.stopPropagation();
	        if (document.documentElement.className.contains('no-touch'))
	            $scope.moreInfo[key]=true;
	    };

	    // remove once grouping is live
	    $scope.showDetailsMouseClick = function(key, $event) {
	        $event.stopPropagation();
	        $scope.moreInfo[key]=!$scope.moreInfo[key];
	    };

	    $scope.closeMoreInfo = function(key) {
	        $scope.moreInfo[key]=false;
	    };

	    affiliationsSrvc.setIdsToAdd(orcidVar.affiliationIdsJson);
	    affiliationsSrvc.addAffiliationToScope(orcidVar.orcidId +'/affiliations.json');
	}]);

	angular.module('orcidApp').controller('AffiliationCtrl', ['$scope', '$rootScope', '$compile', '$filter', 'affiliationsSrvc', 'workspaceSrvc', 'commonSrvc', 'emailSrvc', 'initialConfigService', function ($scope, $rootScope, $compile, $filter, affiliationsSrvc, workspaceSrvc, commonSrvc, emailSrvc, initialConfigService){
	    $scope.affiliationsSrvc = affiliationsSrvc;
	    $scope.editAffiliation;
	    $scope.emailSrvc = emailSrvc;
	    $scope.moreInfo = {};
	    $scope.moreInfoCurKey = null;
	    $scope.privacyHelp = {};
	    $scope.privacyHelpCurKey = null;
	    $scope.showElement = {};
	    $scope.workspaceSrvc = workspaceSrvc;

	    /////////////////////// Begin of verified email logic for work
	    var configuration = initialConfigService.getInitialConfiguration();
	    var emailVerified = false;
	    var emails = {};


	    var showEmailVerificationModal = function(){
	        $rootScope.$broadcast('emailVerifiedObj', {flag: emailVerified, emails: emails});
	    };
	    
	    $scope.emailSrvc.getEmails(
	        function(data) {
	            emails = data.emails;
	            data.emails.forEach(
	                function(element){
	                    if(element.verified == true) {
	                        emailVerified = true;
	                    }
	                }
	            );
	        }
	    );
	    /////////////////////// End of verified email logic for work

	    $scope.sortState = new ActSortState(GroupedActivities.AFFILIATION);
	    $scope.sort = function(key) {       
	        $scope.sortState.sortBy(key);
	    };

	    $scope.toggleClickPrivacyHelp = function(key) {
	        if (!document.documentElement.className.contains('no-touch')) {
	            if ($scope.privacyHelpCurKey != null
	                    && $scope.privacyHelpCurKey != key) {
	                $scope.privacyHelp[$scope.privacyHelpCurKey]=false;
	            }
	            $scope.privacyHelpCurKey = key;
	            $scope.privacyHelp[key]=!$scope.privacyHelp[key];
	        }

	    };

	    // remove once grouping is live
	    $scope.toggleClickMoreInfo = function(key) {
	        if (!document.documentElement.className.contains('no-touch')) {
	            if ($scope.moreInfoCurKey != null
	                    && $scope.moreInfoCurKey != key) {
	                $scope.moreInfo[$scope.moreInfoCurKey]=false;
	            }
	            $scope.moreInfoCurKey = key;
	            $scope.moreInfo[key]=!$scope.moreInfo[key];
	        }
	    };

	    // remove once grouping is live
	    $scope.moreInfoMouseEnter = function(key, $event) {
	        $event.stopPropagation();
	        if (document.documentElement.className.contains('no-touch')) {
	            if ($scope.moreInfoCurKey != null
	                    && $scope.moreInfoCurKey != key) {
	                $scope.privacyHelp[$scope.moreInfoCurKey]=false;
	            }
	            $scope.moreInfoCurKey = key;
	            $scope.moreInfo[key]=true;
	        }
	    };

	    $scope.showDetailsMouseClick = function(key, $event) {
	        $event.stopPropagation();
	        $scope.moreInfo[key]=!$scope.moreInfo[key];
	    };

	    $scope.closeMoreInfo = function(key) {
	        $scope.moreInfo[key]=false;
	    };


	    $scope.showAddModal = function(){
	        var numOfResults = 25;
	        $.colorbox({
	            html: $compile($('#add-affiliation-modal').html())($scope),            
	            onComplete: function() {
	                //resize to insure content fits
	                formColorBoxResize();
	                $scope.bindTypeahead();
	            }
	        });
	    };

	    $scope.bindTypeahead = function () {
	        var numOfResults = 100;

	        $("#affiliationName").typeahead({
	            name: 'affiliationName',
	            limit: numOfResults,
	            remote: {
	                url: getBaseUri()+'/affiliations/disambiguated/name/%QUERY?limit=' + numOfResults
	            },
	            template: function (datum) {
	                   var forDisplay =
	                       '<span style=\'white-space: nowrap; font-weight: bold;\'>' + datum.value+ '</span>'
	                      +'<span style=\'font-size: 80%;\'>'
	                      + ' <br />' + datum.city;
	                   if(datum.region){
	                       forDisplay += ", " + datum.region;
	                   }
	                   if (datum.orgType != null && datum.orgType.trim() != '')
	                      forDisplay += ", " + datum.orgType;
	                   forDisplay += '</span><hr />';
	                   return forDisplay;
	            }
	        });
	        $("#affiliationName").bind("typeahead:selected", function(obj, datum) {
	            $scope.selectAffiliation(datum);
	            $scope.$apply();
	        });
	    };

	    $scope.unbindTypeahead = function () {
	        $('#affiliationName').typeahead('destroy');
	    };

	    $scope.selectAffiliation = function(datum) {
	        if (datum != undefined && datum != null) {
	            $scope.editAffiliation.affiliationName.value = datum.value;
	            $scope.editAffiliation.city.value = datum.city;
	            if(datum.city)
	                $scope.editAffiliation.city.errors = [];
	            $scope.editAffiliation.region.value = datum.region;
	            if(datum.region)
	                $scope.editAffiliation.region.errors = [];
	            if(datum.country != undefined && datum.country != null) {
	                $scope.editAffiliation.country.value = datum.country;
	                $scope.editAffiliation.country.errors = [];
	            }

	            if (datum.disambiguatedAffiliationIdentifier != undefined && datum.disambiguatedAffiliationIdentifier != null) {
	                $scope.getDisambiguatedAffiliation(datum.disambiguatedAffiliationIdentifier);
	                $scope.unbindTypeahead();
	            }
	        }
	    };

	    $scope.getDisambiguatedAffiliation = function(id) {
	        $.ajax({
	            url: getBaseUri() + '/affiliations/disambiguated/id/' + id,
	            dataType: 'json',
	            type: 'GET',
	            success: function(data) {
	                if (data != null) {
	                    $scope.disambiguatedAffiliation = data;
	                    $scope.editAffiliation.orgDisambiguatedId.value = id;
	                    $scope.editAffiliation.disambiguatedAffiliationSourceId = data.sourceId;
	                    $scope.editAffiliation.disambiguationSource = data.sourceType;
	                    $scope.$apply();
	                }
	            }
	        }).fail(function(){
	            console.log("error getDisambiguatedAffiliation(id)");
	        });
	    };

	    $scope.removeDisambiguatedAffiliation = function() {
	        $scope.bindTypeahead();
	        if ($scope.disambiguatedAffiliation != undefined) delete $scope.disambiguatedAffiliation;
	        if ($scope.editAffiliation != undefined && $scope.editAffiliation.disambiguatedAffiliationSourceId != undefined) delete $scope.editAffiliation.disambiguatedAffiliationSourceId;
	        if ($scope.editAffiliation != undefined && $scope.editAffiliation.orgDisambiguatedId != undefined) delete $scope.editAffiliation.orgDisambiguatedId;
	    };

	    $scope.addAffiliationModal = function(type, affiliation){
	        if(emailVerified === true || configuration.showModalManualEditVerificationEnabled == false){
	            $scope.addAffType = type;
	            if(affiliation === undefined) {
	                $scope.removeDisambiguatedAffiliation();
	                $.ajax({
	                    url: getBaseUri() + '/affiliations/affiliation.json',
	                    dataType: 'json',
	                    success: function(data) {
	                        $scope.editAffiliation = data;
	                        if (type != null)
	                            $scope.editAffiliation.affiliationType.value = type;
	                        $scope.$apply(function() {
	                            $scope.showAddModal();
	                        });
	                    }
	                }).fail(function() {
	                    console.log("Error fetching affiliation: " + value);
	                });
	            } else {
	                $scope.editAffiliation = affiliation;
	                if($scope.editAffiliation.orgDisambiguatedId != null)
	                    $scope.getDisambiguatedAffiliation($scope.editAffiliation.orgDisambiguatedId.value);

	                $scope.showAddModal();
	            }
	        }else{
	            showEmailVerificationModal();
	        }
	    };

	    $scope.addAffiliation = function(){
	        if ($scope.addingAffiliation) return; // don't process if adding affiliation
	        $scope.addingAffiliation = true;
	        $scope.editAffiliation.errors.length = 0;
	        $.ajax({
	            url: getBaseUri() + '/affiliations/affiliation.json',
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            type: 'POST',
	            data:  angular.toJson($scope.editAffiliation),
	            success: function(data) {
	                if (data.errors.length == 0){
	                    $.colorbox.close();
	                    $scope.addingAffiliation = false;
	                    affiliationsSrvc.getAffiliations('affiliations/affiliationIds.json');
	                } else {
	                    $scope.editAffiliation = data;
	                    commonSrvc.copyErrorsLeft($scope.editAffiliation, data);
	                    $scope.addingAffiliation = false;
	                    $scope.$apply();
	                }
	            }
	        }).fail(function(){
	            // something bad is happening!
	            $scope.addingAffiliation = false;
	            console.log("error adding affiliations");
	        });
	    };

	    //For resizing color box in case of error
	    $scope.$watch('addingAffiliation', function() {
	         setTimeout(function(){
	             $.colorbox.resize();;
	         }, 50);
	    });

	    $scope.deleteAffiliation = function(aff) {
	        $scope.deleAff = aff;

	        if (aff.affiliationName && aff.affiliationName.value)
	            $scope.fixedTitle = aff.affiliationName.value;
	        else $scope.fixedTitle = '';
	        var maxSize = 100;
	        if($scope.fixedTitle.length > maxSize)
	            $scope.fixedTitle = $scope.fixedTitle.substring(0, maxSize) + '...';
	        $.colorbox({
	            html : $compile($('#delete-affiliation-modal').html())($scope),
	            onComplete: function() {$.colorbox.resize();}
	        });
	    };

	    $scope.deleteAff = function(delAff) {
	        affiliationsSrvc.deleteAffiliation(delAff);
	        $.colorbox.close();
	    };

	    $scope.closeModal = function() {
	        $.colorbox.close();
	    };

	    $scope.setAddAffiliationPrivacy = function(priv, $event) {
	        $event.preventDefault();
	        $scope.editAffiliation.visibility.visibility = priv;
	    };

	    $scope.setPrivacy = function(aff, priv, $event) {
	        $event.preventDefault();
	        aff.visibility.visibility = priv;
	        affiliationsSrvc.updateProfileAffiliation(aff);
	    };

	    $scope.serverValidate = function (relativePath) {
	        $.ajax({
	            url: getBaseUri() + '/' + relativePath,
	            type: 'POST',
	            data:  angular.toJson($scope.editAffiliation),
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                commonSrvc.copyErrorsLeft($scope.editAffiliation, data);
	                $scope.$apply();
	            }
	        }).fail(function() {
	            // something bad is happening!
	            console.log("RegistrationCtrl.serverValidate() error");
	        });
	    };

	    $scope.isValidClass = function (cur) {
	        if (cur === undefined) return '';
	        var valid = true;
	        if (cur.required && (cur.value == null || cur.value.trim() == '')) valid = false;
	        if (cur.errors !== undefined && cur.errors.length > 0) valid = false;
	        return valid ? '' : 'text-error';
	    };

	    //init
	    affiliationsSrvc.getAffiliations('affiliations/affiliationIds.json');

	    $scope.openEditAffiliation = function(affiliation) {
	        $scope.addAffiliationModal(affiliation.affiliationType.value, affiliation);
	    };
	    
	    $scope.showTooltip = function (element){        
	        $scope.showElement[element] = true;
	    };

	    $scope.hideTooltip = function (element){        
	        $scope.showElement[element] = false;
	    };
	}]);



	angular.module('orcidApp').controller('PublicFundingCtrl',['$scope', '$compile', '$filter', 'workspaceSrvc', 'fundingSrvc', function ($scope, $compile, $filter, workspaceSrvc, fundingSrvc){
	    $scope.fundingSrvc = fundingSrvc;
	    $scope.workspaceSrvc = workspaceSrvc;
	    $scope.moreInfo = {};
	    $scope.editSources = {};
	    $scope.showElement = {};
	    $scope.displayURLPopOver = {};

	    $scope.sortState = new ActSortState(GroupedActivities.FUNDING);
	    $scope.sort = function(key) {
	        $scope.sortState.sortBy(key);
	    };
	    
	    // remove once grouping is live
	    $scope.toggleClickMoreInfo = function(key) {
	        if (!document.documentElement.className.contains('no-touch'))
	            $scope.moreInfo[key]=!$scope.moreInfo[key];
	    };

	    // remove once grouping is live
	    $scope.moreInfoMouseEnter = function(key, $event) {
	        $event.stopPropagation();
	        if (document.documentElement.className.contains('no-touch'))
	            $scope.moreInfo[key]=true;
	    };

	    $scope.showDetailsMouseClick = function(key, $event) {              
	        $event.stopPropagation();
	        $scope.moreInfo[key] = !$scope.moreInfo[key];
	    };

	    $scope.closeMoreInfo = function(key) {
	        $scope.moreInfo[key]=false;
	    };

	    fundingSrvc.setIdsToAdd(orcidVar.fundingIdsJson);
	    fundingSrvc.addFundingToScope(orcidVar.orcidId +'/fundings.json');

	    $scope.renderTranslatedTitleInfo = function(funding) {
	        var info = null;
	        if(funding != null && funding.fundingTitle != null && funding.fundingTitle.translatedTitle != null) {
	            info = funding.fundingTitle.translatedTitle.content + ' - ' + funding.fundingTitle.translatedTitle.languageName;
	        }
	        return info;
	    };
	    
	    $scope.showTooltip = function (key){
	        $scope.showElement[key] = true;
	    };

	    $scope.hideTooltip = function (key){        
	        $scope.showElement[key] = false;
	    };
	    
	    $scope.showSources = function(group) {
	        $scope.editSources[group.groupId] = true;
	    };
	    
	    $scope.hideSources = function(group) {
	        $scope.editSources[group.groupId] = false;
	        group.activePutCode = group.defaultPutCode;
	    };
	    
	    $scope.hideURLPopOver = function(id){
	        $scope.displayURLPopOver[id] = false;
	    };
	    
	    $scope.showURLPopOver = function(id){
	        $scope.displayURLPopOver[id] = true;
	    };

	}]);

	angular.module('orcidApp').controller('PublicPeerReviewCtrl',['$scope', '$compile', '$filter', 'workspaceSrvc', 'peerReviewSrvc',function ($scope, $compile, $filter, workspaceSrvc, peerReviewSrvc) {
	     $scope.peerReviewSrvc = peerReviewSrvc;
	     $scope.workspaceSrvc  = workspaceSrvc;
	     $scope.showDetails = {};
	     $scope.showElement = {};
	     $scope.showPeerReviewDetails = new Array();
	     $scope.sortHideOption = true;
	     
	     $scope.sortState = new ActSortState(GroupedActivities.PEER_REVIEW);
	     
	     $scope.sort = function(key) {
	        $scope.sortState.sortBy(key);
	     };
	     
	     $scope.showDetailsMouseClick = function(groupId, $event){
	        $event.stopPropagation();
	        $scope.showDetails[groupId] = !$scope.showDetails[groupId];
	     };
	    
	    $scope.showTooltip = function (element){        
	        $scope.showElement[element] = true;
	    };

	    $scope.hideTooltip = function (element){        
	        $scope.showElement[element] = false;
	    };
	    
	    
	    $scope.showMoreDetails = function(putCode){  
	        $scope.showPeerReviewDetails.length = 0;
	        $scope.showPeerReviewDetails[putCode] = true;   
	    };
	    
	    $scope.hideMoreDetails = function(putCode){
	        $scope.showPeerReviewDetails.length = 0;
	        $scope.showPeerReviewDetails[putCode] = false;
	    };
	    
	    //Init
	    $scope.peerReviewSrvc.loadPeerReviews(peerReviewSrvc.constants.access_type.ANONYMOUS);       
	}]);

	angular.module('orcidApp').controller('PublicWorkCtrl',['$scope', '$compile', '$filter', 'workspaceSrvc', 'worksSrvc',function ($scope, $compile, $filter, workspaceSrvc, worksSrvc) {
	    $scope.worksSrvc = worksSrvc;
	    $scope.workspaceSrvc = workspaceSrvc;
	    $scope.showBibtex = {};
	    $scope.moreInfoOpen = false;
	    $scope.moreInfo = {};
	    $scope.editSources = {};
	    $scope.showElement = {};
	    $scope.displayURLPopOver = {};
	    $scope.badgesRequested = {};

	    $scope.sortState = new ActSortState(GroupedActivities.ABBR_WORK);
	    $scope.sort = function(key) {
	        $scope.sortState.sortBy(key);
	    };
	    
	    $scope.bibtexShowToggle = function (putCode) {
	        $scope.showBibtex[putCode] = !($scope.showBibtex[putCode]);
	    };

	    $scope.renderTranslatedTitleInfo = function(putCode) {
	        var info = null;

	        if(putCode != null && $scope.worksSrvc.details[putCode] != null && $scope.worksSrvc.details[putCode].translatedTitle != null) {
	            info = $scope.worksSrvc.details[putCode].translatedTitle.content + ' - ' + $scope.worksSrvc.details[putCode].translatedTitle.languageName;
	        }

	        return info;
	    };

	    $scope.worksSrvc.loadAbbrWorks(worksSrvc.constants.access_type.ANONYMOUS);

	    // remove once grouping is live
	    $scope.moreInfoClick = function(work, $event) {
	        if (!document.documentElement.className.contains('no-touch'))
	            $scope.moreInfoOpen?$scope.closePopover():$scope.loadWorkInfo(work.putCode.value, $event);
	    };

	    // remove once grouping is live
	    $scope.moreInfoMouseEnter = function(work, $event) {
	        $event.stopPropagation();
	        if (document.documentElement.className.contains('no-touch'))
	            $scope.loadWorkInfo(work.putCode.value, $event);
	        else
	            $scope.moreInfoOpen?$scope.closePopover():$scope.loadWorkInfo(work.putCode.value, $event);
	    };

	    $scope.showDetailsMouseClick = function(group, $event) {
	            $event.stopPropagation();
	        //if (document.documentElement.className.contains('no-touch'))
	            $scope.moreInfo[group.groupId] = !$scope.moreInfo[group.groupId];
	            //$scope.loadWorkInfo(work, $event);
	            for (var idx in group.activities)
	                $scope.loadDetails(group.activities[idx].putCode.value, $event);
	        //else
	            //$scope.moreInfoOpen?$scope.closePopover():$scope.loadWorkInfo(work.putCode.value, $event);
	    };

	    $scope.loadDetails = function(putCode, event) {
	        //Close any open popover
	        $scope.closePopover(event);
	        $scope.moreInfoOpen = true;
	        //Display the popover
	        $(event.target).next().css('display','inline');
	        $scope.worksSrvc.getGroupDetails(putCode, worksSrvc.constants.access_type.ANONYMOUS);
	    };

	    $scope.hideSources = function(group) {
	        $scope.editSources[group.groupId] = false;
	        group.activePutCode = group.defaultPutCode;
	    };

	    $scope.showSources = function(group) {
	        $scope.editSources[group.groupId] = true;
	    };

	    $scope.loadWorkInfo = function(putCode, event) {
	        //Close any open popover
	        $scope.closePopover(event);
	        $scope.moreInfoOpen = true;
	        //Display the popover
	        $(event.target).next().css('display','inline');
	        if($scope.worksSrvc.details[putCode] == null) {
	            $scope.worksSrvc.getGroupDetails(putCode, worksSrvc.constants.access_type.ANONYMOUS);
	        } else {
	            $(event.target).next().css('display','inline');
	        }
	    };

	    $scope.closePopover = function(event) {
	        $scope.moreInfoOpen = false;
	        $('.work-more-info-container').css('display', 'none');
	    };

	    $scope.showTooltip = function (element){        
	        $scope.showElement[element] = true;
	    };

	    $scope.hideTooltip = function (element){        
	        $scope.showElement[element] = false;
	    };
	    
	    $scope.hideURLPopOver = function(id){
	        $scope.displayURLPopOver[id] = false;
	    };
	    
	    $scope.showURLPopOver = function(id){
	        $scope.displayURLPopOver[id] = true;
	    };
	    
	    $scope.showMozillaBadges = function(putCode){
	        $scope.$watch(
	            function () { 
	                return document.getElementsByClassName('badge-container-' + putCode).length; 
	            },
	            function (newValue, oldValue) {
	                if (newValue !== oldValue) {
	                    if ($scope.badgesRequested[putCode] == null){
	                        var dois = worksSrvc.getUniqueDois(putCode);
	                        var c = document.getElementsByClassName('badge-container-' + putCode);
	                        for (i = 0; i <= dois.length - 1; i++){
	                            var code = 'var conf={"article-doi": "' + dois[i] + '", "container-class": "badge-container-' + putCode + '"};showBadges(conf);';
	                            var s = document.createElement('script');
	                            s.type = 'text/javascript';
	                            try {
	                              s.appendChild(document.createTextNode(code));
	                              c[0].appendChild(s);
	                            } catch (e) {
	                              s.text = code;
	                              c[0].appendChild(s);
	                            }
	                        }
	                        $scope.badgesRequested[putCode] = true;
	                    }
	                }
	            }
	        );  
	    };
	    
	}]);



	angular.module('orcidApp').controller('PeerReviewCtrl', ['$scope', '$compile', '$filter', 'workspaceSrvc', 'commonSrvc', 'peerReviewSrvc', function ($scope, $compile, $filter, workspaceSrvc, commonSrvc, peerReviewSrvc){
	    $scope.workspaceSrvc = workspaceSrvc;
	    $scope.peerReviewSrvc = peerReviewSrvc;
	    $scope.editPeerReview = null;
	    $scope.disambiguatedOrganization = null;
	    $scope.addingPeerReview = false;
	    $scope.editTranslatedTitle = false;
	    $scope.editSources = {};
	    $scope.showDetails = {};
	    $scope.showPeerReviewDetails = new Array();
	    $scope.showElement = {};
	    $scope.sortState = new ActSortState(GroupedActivities.PEER_REVIEW);
	    $scope.sortHideOption = true;
	    $scope.displayURLPopOver = {};
	    $scope.peerReviewImportWizard = false;
	    $scope.wizardDescExpanded = {};
	    $scope.noLinkFlag = true;
	    
	    $scope.sort = function(key) {
	        $scope.sortState.sortBy(key);
	    };
	    
	    $scope.addPeerReviewModal = function(data){
	        if (data == undefined) {
	            peerReviewSrvc.getBlankPeerReview(function(data) {
	                $scope.editPeerReview = data;
	                $scope.$apply(function() {                    
	                    $scope.showAddPeerReviewModal();
	                    $scope.bindTypeaheadForOrgs();
	                });
	            });
	        }else{
	            $scope.editPeerReview = data;
	            $scope.showAddPeerReviewModal();    
	        }       
	    };
	    
	    $scope.showAddPeerReviewModal = function(data){
	        $scope.editTranslatedTitle = false;
	        $.colorbox({
	            scrolling: true,
	            html: $compile($('#add-peer-review-modal').html())($scope),
	            onLoad: function() {$('#cboxClose').remove();},
	            // start the colorbox off with the correct width
	            width: formColorBoxResize(),
	            onComplete: function() {
	                //resize to insure content fits
	            },
	            onClosed: function() {
	                //$scope.closeAllMoreInfo();
	                $scope.peerReviewSrvc.loadPeerReviews(peerReviewSrvc.constants.access_type.USER);
	            }
	        });
	    };
	    
	    $scope.addAPeerReview = function() {
	        if ($scope.addingPeerReview) return; 
	        $scope.addingPeerReview = true;
	        $scope.editPeerReview.errors.length = 0;
	        peerReviewSrvc.postPeerReview($scope.editPeerReview,
	            function(data){             
	                if (data.errors.length == 0) {
	                    $scope.addingPeerReview = false;
	                    $scope.$apply();
	                    $.colorbox.close();
	                    $scope.peerReviewSrvc.loadPeerReviews(peerReviewSrvc.constants.access_type.USER);                    
	                } else {
	                    $scope.editPeerReview = data;
	                    commonSrvc.copyErrorsLeft($scope.editPeerReview, data);
	                    $scope.addingPeerReview = false;
	                    $scope.$apply();
	                }
	            },
	            function() {
	                // something bad is happening!
	                $scope.addingPeerReview = false;
	                console.log("error creating peer review");
	            }
	        );
	    };
	    
	    $scope.openEditPeerReview = function(putCode){
	        peerReviewSrvc.getEditable(putCode, function(data) {$scope.addPeerReviewModal(data);});        
	    };
	    
	    $scope.closeModal = function() {
	        $.colorbox.close();
	    };
	    
	    $scope.serverValidate = function (relativePath) {
	        $.ajax({
	            url: getBaseUri() + '/' + relativePath,
	            type: 'POST',
	            data:  angular.toJson($scope.editPeerReview),
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                commonSrvc.copyErrorsLeft($scope.editPeerReview, data);                
	                $scope.$apply();
	            }
	        }).fail(function() {
	            // something bad is happening!
	            console.log("PeerReviewCtrl.serverValidate() error");
	        });
	    };
	    
	    $scope.removeDisambiguatedOrganization = function() {
	        $scope.bindTypeaheadForOrgs();
	        if ($scope.disambiguatedOrganization != undefined) delete $scope.disambiguatedOrganization;
	        if ($scope.editPeerReview != undefined && $scope.editPeerReview.disambiguatedOrganizationSourceId != undefined) delete $scope.editPeerReview.disambiguatedOrganizationSourceId;
	    };
	    
	    $scope.unbindTypeaheadForOrgs = function () {
	        $('#organizationName').typeahead('destroy');
	    };
	    
	    $scope.bindTypeaheadForOrgs = function () {
	        var numOfResults = 100;
	        $("#organizationName").typeahead({
	            name: 'organizationName',
	            limit: numOfResults,
	            remote: {
	                replace: function () {
	                    var q = getBaseUri()+'/peer-reviews/disambiguated/name/';
	                    if ($('#organizationName').val()) {
	                        q += encodeURIComponent($('#organizationName').val());
	                    }
	                    q += '?limit=' + numOfResults;
	                    return q;
	                }
	            },
	            template: function (datum) {
	                   var forDisplay =
	                       '<span style=\'white-space: nowrap; font-weight: bold;\'>' + datum.value+ '</span>'
	                      +'<span style=\'font-size: 80%;\'>'
	                      + ' <br />' + datum.city;
	                   if(datum.region){
	                       forDisplay += ", " + datum.region;
	                   }
	                   if (datum.orgType != null && datum.orgType.trim() != '')
	                      forDisplay += ", " + datum.orgType;
	                   forDisplay += '</span><hr />';

	                   return forDisplay;
	            }
	        });
	        $("#organizationName").bind("typeahead:selected", function(obj, datum) {
	            $scope.selectOrganization(datum);
	            $scope.$apply();
	        });
	    };
	    
	    $scope.selectOrganization = function(datum) {
	        if (datum != undefined && datum != null) {
	            $scope.editPeerReview.orgName.value = datum.value;
	            if(datum.value)
	                $scope.editPeerReview.orgName.errors = [];
	            $scope.editPeerReview.city.value = datum.city;
	            if(datum.city)
	                $scope.editPeerReview.city.errors = [];
	            if(datum.region)
	                $scope.editPeerReview.region.value = datum.region;

	            if(datum.country != undefined && datum.country != null) {
	                $scope.editPeerReview.country.value = datum.country;
	                $scope.editPeerReview.country.errors = [];
	            }

	            if (datum.disambiguatedOrganizationIdentifier != undefined && datum.disambiguatedOrganizationIdentifier != null) {
	                $scope.getDisambiguatedOrganization(datum.disambiguatedOrganizationIdentifier);
	                $scope.unbindTypeaheadForOrgs();
	            }
	        }
	    };
	    
	    $scope.getDisambiguatedOrganization = function(id) {
	        $.ajax({
	            url: getBaseUri() + '/peer-reviews/disambiguated/id/' + id,
	            dataType: 'json',
	            type: 'GET',
	            success: function(data) {
	                if (data != null) {
	                    $scope.disambiguatedOrganization = data;
	                    $scope.editPeerReview.disambiguatedOrganizationSourceId = data.sourceId;
	                    $scope.editPeerReview.disambiguationSource = data.sourceType;
	                    $scope.$apply();
	                }
	            }
	        }).fail(function(){
	            console.log("error getDisambiguatedOrganization(id)");
	        });
	    };
	    
	    $scope.toggleTranslatedTitleModal = function(){
	        $scope.editTranslatedTitle = !$scope.editTranslatedTitle;
	        $('#translatedTitle').toggle();
	        $.colorbox.resize();
	    };

	    $scope.addExternalIdentifier = function () {
	        $scope.editPeerReview.externalIdentifiers.push({workExternalIdentifierId: {value: ""}, workExternalIdentifierType: {value: ""}, relationship: {value: "self"}, url: {value: ""}});
	    };
	    
	    $scope.addSubjectExternalIdentifier = function () {
	        $scope.editPeerReview.subjectForm.workExternalIdentifiers.push({workExternalIdentifierId: {value: ""}, workExternalIdentifierType: {value: ""}, relationship: {value: "self"}, url: {value: ""}});
	    };
	    
	    $scope.deleteExternalIdentifier = function(obj) {
	        var index = $scope.editPeerReview.externalIdentifiers.indexOf(obj);
	        $scope.editPeerReview.externalIdentifiers.splice(index,1);
	    };
	    
	    $scope.deleteSubjectExternalIdentifier = function(obj) {
	        var index = $scope.editPeerReview.subjectForm.workExternalIdentifiers.indexOf(obj);
	        $scope.editPeerReview.subjectForm.workExternalIdentifiers.splice(index,1);        
	    };
	   
	    $scope.showDetailsMouseClick = function(groupId, $event){
	        $event.stopPropagation();
	        $scope.showDetails[groupId] = !$scope.showDetails[groupId];
	    };
	    
	    $scope.showMoreDetails = function(putCode){
	        $scope.showPeerReviewDetails.length = 0;
	        $scope.showPeerReviewDetails[putCode] = true;   
	    };
	    
	    $scope.hideMoreDetails = function(putCode){
	        $scope.showPeerReviewDetails.length = 0;
	        $scope.showPeerReviewDetails[putCode] = false;
	    };
	    
	    $scope.deletePeerReviewConfirm = function(putCode, deleteGroup) {
	        var peerReview = peerReviewSrvc.getPeerReview(putCode);
	        var maxSize = 100;
	        
	        $scope.deletePutCode = putCode;
	        $scope.deleteGroup = deleteGroup;
	        
	        if (peerReview.subjectName)
	            $scope.fixedTitle = peerReview.subjectName.value;
	        else {
	            $scope.fixedTitle = '';
	        }
	        
	        if($scope.fixedTitle.length > maxSize)
	            $scope.fixedTitle = $scope.fixedTitle.substring(0, maxSize) + '...';
	        $.colorbox({
	            html : $compile($('#delete-peer-review-modal').html())($scope),
	            onComplete: function() {$.colorbox.resize();}
	        });
	    };
	    
	    $scope.deleteByPutCode = function(putCode, deleteGroup) {
	        if (deleteGroup)
	           peerReviewSrvc.deleteGroupPeerReview(putCode);
	        else
	            peerReviewSrvc.deletePeerReview(putCode);
	        $.colorbox.close();
	    };
	    
	    $scope.userIsSource = function(peerReview) {
	        if (peerReview.source == orcidVar.orcidId)
	            return true;
	        return false;
	    };
	    
	    $scope.showTooltip = function (element){        
	        $scope.showElement[element] = true;
	    };

	    $scope.hideTooltip = function (element){        
	        $scope.showElement[element] = false;
	    };
	    
	    $scope.fillUrl = function(extId) {
	        if(extId != null) {
	            var url = workIdLinkJs.getLink(extId.workExternalIdentifierId.value, extId.workExternalIdentifierType.value);           
	            if(extId.url == null) {
	                extId.url = {value:""};
	            }
	            extId.url.value=url;
	        }
	    };
	    
	    $scope.hideURLPopOver = function(id){
	        $scope.displayURLPopOver[id] = false;
	    };
	    
	    $scope.showURLPopOver = function(id){
	        $scope.displayURLPopOver[id] = true;
	    };
	    
	    $scope.moreInfoActive = function(groupID){
	        if ($scope.moreInfo[groupID] == true || $scope.moreInfo[groupID] != null) return 'truncate-anchor';
	    };
	    
	    $scope.showPeerReviewImportWizard = function(){
	        if(!$scope.peerReviewImportWizard) {
	            loadPeerReviewLinks();
	        }
	        $scope.peerReviewImportWizard = !$scope.peerReviewImportWizard;
	    };
	    
	    $scope.toggleWizardDesc = function(id){
	        $scope.wizardDescExpanded[id] = !$scope.wizardDescExpanded[id];
	    };
	    
	    $scope.openImportWizardUrlFilter = function(url, param) {
	        url = url + '?client_id='+param.clientId+'&response_type=code&scope='+param.redirectUris.redirectUri[0].scopeAsSingleString+'&redirect_uri='+param.redirectUris.redirectUri[0].value;
	        openImportWizardUrl(url);
	    };
	        
	    //Init
	    $scope.peerReviewSrvc.loadPeerReviews(peerReviewSrvc.constants.access_type.USER);
	    loadPeerReviewLinks();
	    
	    function loadPeerReviewLinks() {
	        $.ajax({
	            url: getBaseUri() + '/workspace/retrieve-peer-review-import-wizards.json',
	            type: 'GET',
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                $scope.peerReviewImportWizardList = data;
	                if(data == null || data.length == 0) {
	                    $scope.noLinkFlag = false;
	                }
	                $scope.peerReviewImportWizardList.sort(function(obj1, obj2){
	                    if(obj1.displayName < obj2.displayName) {
	                        return -1;
	                    }
	                    if(obj1.displayName > obj2.displayName) {
	                        return 1;
	                    }
	                    return 0;
	                });
	                $scope.$apply();
	            }
	        }).fail(function(e) {
	            // something bad is happening!
	            console.log("PeerReviewImportWizardError");
	            logAjaxError(e);
	        });
	    }
	}]);

	angular.module('orcidApp').controller('SearchCtrl',['$scope', '$compile', function ($scope, $compile){
	    $scope.hasErrors = false;
	    $scope.results = new Array();
	    $scope.numFound = 0;
	    $scope.input = {};
	    $scope.input.start = 0;
	    $scope.input.rows = 10;
	    $scope.input.text = $('#SearchCtrl').data('search-query');

	    $scope.getResults = function(){
	        $.ajax({
	            url: orcidSearchUrlJs.buildUrl($scope.input),
	            dataType: 'json',
	            headers: { Accept: 'application/json'},
	            success: function(data) {
	                $('#ajax-loader').hide();
	                var resultsContainer = data['orcid-search-results'];
	                $scope.numFound = resultsContainer['num-found'];
	                if(resultsContainer['orcid-search-result']){
	                    $scope.results = $scope.results.concat(resultsContainer['orcid-search-result']);
	                }
	                if(!$scope.numFound){
	                    $('#no-results-alert').fadeIn(1200);
	                }
	                $scope.areMoreResults = $scope.numFound > ($scope.input.start + $scope.input.rows);
	                $scope.$apply();
	                var newSearchResults = $('.new-search-result');
	                if(newSearchResults.length > 0){
	                    newSearchResults.fadeIn(1200);
	                    newSearchResults.removeClass('new-search-result');
	                    var newSearchResultsTop = newSearchResults.offset().top;
	                    var showMoreButtonTop = $('#show-more-button-container').offset().top;
	                    var bottom = $(window).height();
	                    if(showMoreButtonTop > bottom){
	                        $('html, body').animate(
	                            {
	                                scrollTop: newSearchResultsTop
	                            },
	                            1000,
	                            'easeOutQuint'
	                        );
	                    }
	                }
	            }
	        }).fail(function(){
	            // something bad is happening!
	            console.log("error doing search");
	        });
	    };

	    $scope.getFirstResults = function(){
	        $('#no-results-alert').hide();
	        $scope.results = new Array();
	        $scope.numFound = 0;
	        $scope.input.start = 0;
	        $scope.input.rows = 10;
	        $scope.areMoreResults = false;
	        if($scope.isValid()){
	            $scope.hasErrors = false;
	            $('#ajax-loader').show();
	            $scope.getResults();
	        }
	        else{
	            $scope.hasErrors = true;
	        }
	    };

	    $scope.getMoreResults = function(){
	        $('#ajax-loader').show();
	        $scope.input.start += 10;
	        $scope.getResults();
	    };

	    $scope.concatPropertyValues = function(array, propertyName){
	        if(typeof array === 'undefined'){
	            return '';
	        }
	        else{
	            return $.map(array, function(o){ return o[propertyName]; }).join(', ');
	        }
	    };

	    $scope.areResults = function(){
	        return $scope.results.length > 0;
	    };

	    $scope.isValid = function(){
	        return orcidSearchUrlJs.isValidInput($scope.input);
	    };

	    $scope.isValidOrcidId = function(){
	        if(typeof $scope.input.text === 'undefined' || $scope.input.text === null || $scope.input.text === '' || orcidSearchUrlJs.isValidOrcidId($scope.input.text)){
	            return true;
	        }
	        return false;
	    }

	    // init
	    if(typeof $scope.input.text !== 'undefined'){
	        $('#ajax-loader').show();
	        $scope.getResults();
	    }
	}]);

	// Controller for delegate permissions that have been granted BY the current user
	angular.module('orcidApp').controller('DelegatesCtrl',['$scope', '$compile', function DelegatesCtrl($scope, $compile){
	    $scope.results = new Array();
	    $scope.numFound = 0;
	    $scope.input = {};
	    $scope.input.start = 0;
	    $scope.input.rows = 10;
	    $scope.showInitLoader = true;
	    $scope.showLoader = false;
	    $scope.effectiveUserOrcid = orcidVar.orcidId;
	    $scope.realUserOrcid = orcidVar.realOrcidId;
	    $scope.sort = {
	        column: 'delegateSummary.creditName.content',
	        descending: false
	    };
	    $scope.isPasswordConfirmationRequired = orcidVar.isPasswordConfirmationRequired;

	    $scope.changeSorting = function(column) {
	        var sort = $scope.sort;
	        if (sort.column === column) {
	            sort.descending = !sort.descending;
	        } else {
	            sort.column = column;
	            sort.descending = false;
	        }
	    };

	    $scope.search = function(){
	        $scope.results = new Array();
	        $scope.showLoader = true;
	        $('#no-results-alert').hide();
	        if(isEmail($scope.input.text)){
	            $scope.numFound = 0;
	            $scope.start = 0;
	            $scope.areMoreResults = 0;
	            $scope.searchByEmail();
	        }
	        else{
	            $scope.getResults();
	        }
	    };

	    $scope.searchByEmail = function(){
	        $.ajax({
	            url: $('body').data('baseurl') + "manage/search-for-delegate-by-email/" + encodeURIComponent($scope.input.text) + '/',
	            dataType: 'json',
	            headers: { Accept: 'application/json'},
	            success: function(data) {
	                $scope.confirmAddDelegateByEmail(data);
	                $scope.showLoader = false;
	                $scope.$apply();
	            }
	        }).fail(function(){
	            // something bad is happening!
	            console.log("error doing search for delegate by email");
	        });

	    };

	    $scope.getResults = function(rows){
	        $.ajax({
	            url: orcidSearchUrlJs.buildUrl($scope.input)+'&callback=?',
	            dataType: 'json',
	            headers: { Accept: 'application/json'},
	            success: function(data) {
	                var resultsContainer = data['orcid-search-results'];
	                $scope.numFound = resultsContainer['num-found'];
	                if(resultsContainer['orcid-search-result']){
	                    $scope.numFound = resultsContainer['num-found'];
	                    $scope.results = $scope.results.concat(resultsContainer['orcid-search-result']);
	                }
	                var tempResults = $scope.results;
	                for(var index = 0; index < tempResults.length; index ++) {
	                    if($scope.results[index]['orcid-profile']['orcid-bio']['personal-details'] == null) {
	                        $scope.results.splice(index, 1);
	                    } 
	                }
	                $scope.numFound = $scope.results.length;
	                if(!$scope.numFound){
	                    $('#no-results-alert').fadeIn(1200);
	                }
	                $scope.areMoreResults = $scope.numFound >= ($scope.start + $scope.rows);
	                $scope.showLoader = false;
	                $scope.$apply();
	                var newSearchResults = $('.new-search-result');
	                if(newSearchResults.length > 0){
	                    newSearchResults.fadeIn(1200);
	                    newSearchResults.removeClass('new-search-result');
	                    var newSearchResultsTop = newSearchResults.offset().top;
	                    var showMoreButtonTop = $('#show-more-button-container').offset().top;
	                    var bottom = $(window).height();
	                    if(showMoreButtonTop > bottom){
	                        $('html, body').animate(
	                            {
	                                scrollTop: newSearchResultsTop
	                            },
	                            1000,
	                            'easeOutQuint'
	                        );
	                    }
	                }
	            }
	        }).fail(function(){
	            // something bad is happening!
	            console.log("error doing search for delegates");
	        });
	    };

	    $scope.getMoreResults = function(){
	        $scope.showLoader = true;
	        $scope.start += 10;
	        $scope.getResults();
	    };

	    $scope.concatPropertyValues = function(array, propertyName){
	        if(typeof array === 'undefined'){
	            return '';
	        }
	        else{
	            return $.map(array, function(o){ return o[propertyName]; }).join(', ');
	        }
	    };

	    $scope.areResults = function(){
	        return $scope.numFound != 0;
	    };

	    $scope.getDisplayName = function(result){
	        var personalDetails = result['orcid-profile']['orcid-bio']['personal-details'];
	        var name = "";
	        if(personalDetails != null) {
	            var creditName = personalDetails['credit-name'];
	            if(creditName != null){
	                return creditName.value;
	            }
	            name = personalDetails['given-names'].value;
	            if(personalDetails['family-name'] != null) {
	                name = name + ' ' + personalDetails['family-name'].value;
	            }
	        }
	        return name;
	    };

	    $scope.confirmAddDelegateByEmail = function(emailSearchResult){
	        $scope.errors = [];
	        $scope.emailSearchResult = emailSearchResult;
	        $.colorbox({
	            html : $compile($('#confirm-add-delegate-by-email-modal').html())($scope),
	            transition: 'fade',
	            close: '',
	            onLoad: function() {
	                $('#cboxClose').remove();
	            },
	            onComplete: function() {$.colorbox.resize();},
	            scrolling: true
	        });
	    };

	    $scope.confirmAddDelegate = function(delegateName, delegateId, delegateIdx){
	        $scope.errors = [];
	        $scope.delegateNameToAdd = delegateName;
	        $scope.delegateToAdd = delegateId;
	        $scope.delegateIdx = delegateIdx;
	        $.colorbox({
	            html : $compile($('#confirm-add-delegate-modal').html())($scope),
	            transition: 'fade',
	            close: '',
	            onLoad: function() {
	                $('#cboxClose').remove();
	            },
	            onComplete: function() {$.colorbox.resize();},
	            scrolling: true
	        });
	    };

	    $scope.addDelegateByEmail = function(delegateEmail) {
	        $scope.errors = [];
	        var addDelegate = {};
	        addDelegate.delegateEmail = $scope.input.text;
	        addDelegate.password = $scope.password;
	        $.ajax({
	            url: $('body').data('baseurl') + 'account/addDelegateByEmail.json',
	            type: 'POST',
	            data: angular.toJson(addDelegate),
	            contentType: 'application/json;charset=UTF-8',
	            success: function(data) {
	                if(data.errors.length === 0){
	                    $scope.getDelegates();
	                    $scope.$apply();
	                    $scope.closeModal();
	                }
	                else{
	                    $scope.errors = data.errors;
	                    $scope.$apply();
	                }
	            }
	        }).fail(function() {
	            console.log("Error adding delegate.");
	        });
	    };

	    $scope.addDelegate = function() {
	        var addDelegate = {};
	        addDelegate.delegateToManage = $scope.delegateToAdd;
	        addDelegate.password = $scope.password;
	        $.ajax({
	            url: getBaseUri() + '/account/addDelegate.json',
	            type: 'POST',
	            data: angular.toJson(addDelegate),
	            contentType: 'application/json;charset=UTF-8',
	            success: function(data) {
	                if(data.errors.length === 0){
	                    $scope.getDelegates();
	                    $scope.results.splice($scope.delegateIdx, 1);
	                    $scope.$apply();
	                    $scope.closeModal();
	                }
	                else{
	                    $scope.errors = data.errors;
	                    $scope.$apply();
	                }
	            }
	        }).fail(function() {
	            console.log("Error adding delegate.");
	        });
	    };

	    $scope.confirmRevoke = function(delegateName, delegateId) {
	        $scope.errors = [];
	        $scope.delegateNameToRevoke = delegateName;
	        $scope.delegateToRevoke = delegateId;
	        $.colorbox({
	            html : $compile($('#revoke-delegate-modal').html())($scope)

	        });
	        $.colorbox.resize();
	    };

	    $scope.revoke = function () {
	        var revokeDelegate = {};
	        revokeDelegate.delegateToManage = $scope.delegateToRevoke;
	        revokeDelegate.password = $scope.password;
	        $.ajax({
	            url: getBaseUri() + '/account/revokeDelegate.json',
	            type: 'POST',
	            data:  angular.toJson(revokeDelegate),
	            contentType: 'application/json;charset=UTF-8',
	            success: function(data) {
	                if(data.errors.length === 0){
	                    $scope.getDelegates();
	                    $scope.$apply();
	                    $scope.closeModal();
	                }
	                else{
	                    $scope.errors = data.errors;
	                    $scope.$apply();
	                }
	            }
	        }).fail(function() {
	            // something bad is happening!
	            console.log("$DelegateCtrl.revoke() error");
	        });
	    };

	    $scope.getDelegates = function() {
	        $.ajax({
	            url: getBaseUri() + '/account/delegates.json',
	            dataType: 'json',
	            success: function(data) {
	                $scope.delegatesByOrcid = {};
	                $scope.delegation = data;
	                if(data != null && data.givenPermissionTo != null){
	                    for(var i=0; i < data.givenPermissionTo.delegationDetails.length; i++){
	                        var delegate = data.givenPermissionTo.delegationDetails[i];
	                        $scope.delegatesByOrcid[delegate.delegateSummary.orcidIdentifier.path] = delegate;
	                    }
	                }
	                $scope.showInitLoader = false;
	                $scope.$apply();
	            }
	        }).fail(function() {
	            $scope.showInitLoader = false;
	            // something bad is happening!
	            console.log("error with delegates");
	        });
	    };

	    $scope.closeModal = function() {
	        $.colorbox.close();
	    };

	    // init
	    $scope.getDelegates();

	}]);

	// Controller for delegate permissions that have been granted TO the current user
	angular.module('orcidApp').controller('DelegatorsCtrl',['$scope', '$compile', function ($scope, $compile){

	    $scope.sort = {
	            column: 'delegateSummary.creditName.content',
	            descending: false
	    };

	    $scope.changeSorting = function(column) {
	        var sort = $scope.sort;
	        if (sort.column === column) {
	            sort.descending = !sort.descending;
	        } else {
	            sort.column = column;
	            sort.descending = false;
	        }
	    };

	    $scope.getDelegators = function() {
	        $.ajax({
	            url: getBaseUri() + '/delegators/delegators-and-me.json',
	            dataType: 'json',
	            success: function(data) {
	                $scope.delegators = data.delegators;
	                $scope.$apply();
	            }
	        }).fail(function(e) {
	            // something bad is happening!
	            console.log("error with delegates");
	            logAjaxError(e);
	        });
	    };

	    $scope.selectDelegator = function(datum) {
	        window.location.href = getBaseUri() + '/switch-user?j_username=' + datum.orcid;
	    };

	    $("#delegatorsSearch").typeahead({
	        name: 'delegatorsSearch',
	        remote: {
	            url: getBaseUri()+'/delegators/search-for-data/%QUERY?limit=' + 10
	        },
	        template: function (datum) {
	            var forDisplay;
	            if(datum.noResults){
	                forDisplay = "<span class=\'no-delegator-matches\'>" + om.get('delegators.nomatches') + "</span>";
	            }
	            else{
	                forDisplay =
	                    '<span style=\'white-space: nowrap; font-weight: bold;\'>' + datum.value + '</span>'
	                    +'<span style=\'font-size: 80%;\'> (' + datum.orcid + ')</span>';
	            }
	            return forDisplay;
	        }
	    });
	    $("#delegatorsSearch").bind("typeahead:selected", function(obj, datum) {
	        if(!datum.noResults){
	            $scope.selectDelegator(datum);
	        }
	        $scope.$apply();
	    });

	    // init
	    $scope.getDelegators();

	}]);

	angular.module('orcidApp').controller('SocialCtrl',['$scope', '$compile', 'discoSrvc', function SocialCtrl($scope, $compile, discoSrvc){
	    $scope.showLoader = false;
	    $scope.sort = {
	        column: 'providerUserId',
	        descending: false
	    };
	    $scope.isPasswordConfirmationRequired = orcidVar.isPasswordConfirmationRequired;

	    $scope.changeSorting = function(column) {
	        var sort = $scope.sort;
	        if (sort.column === column) {
	            sort.descending = !sort.descending;
	        } else {
	            sort.column = column;
	            sort.descending = false;
	        }
	    };

	    $scope.confirmRevoke = function(socialAccount) {
	        $scope.errors = [];
	        $scope.socialAccount = socialAccount;
	        $scope.idToManage = socialAccount.id;
	        $.colorbox({
	            html : $compile($('#revoke-social-account-modal').html())($scope),            
	            onComplete: function() {
	                $.colorbox.resize({height:"200px", width:"500px"});        
	            }
	        });
	        
	    };

	    $scope.revoke = function () {
	        var revokeSocialAccount = {};
	        revokeSocialAccount.idToManage = $scope.idToManage;
	        revokeSocialAccount.password = $scope.password;
	        $.ajax({
	            url: getBaseUri() + '/account/revokeSocialAccount.json',
	            type: 'POST',
	            data:  angular.toJson(revokeSocialAccount),
	            contentType: 'application/json;charset=UTF-8',
	            success: function(data) {
	                if(data.errors.length === 0){
	                    $scope.getSocialAccounts();
	                    $scope.$apply();
	                    $scope.closeModal();
	                    $scope.password = "";
	                }
	                else{
	                    $scope.errors = data.errors;
	                    $scope.$apply();
	                }
	            }
	        }).fail(function() {
	            // something bad is happening!
	            console.log("$SocialCtrl.revoke() error");
	        });
	    };

	    $scope.getSocialAccounts = function() {
	        $.ajax({
	            url: getBaseUri() + '/account/socialAccounts.json',
	            dataType: 'json',
	            success: function(data) {
	                $scope.socialAccounts = data;
	                $scope.populateIdPNames();
	                $scope.$apply();
	            }
	        }).fail(function() {
	            // something bad is happening!
	            console.log("error getting social accounts");
	        });
	    };
	    
	    $scope.$watch(function() { return discoSrvc.feed; }, function(){
	        $scope.populateIdPNames();
	        
	    });
	    
	    $scope.populateIdPNames = function() {
	        if(discoSrvc.feed != null) {
	            for(i in $scope.socialAccounts){
	                var account = $scope.socialAccounts[i];
	                var name = discoSrvc.getIdPName(account.id.providerid);
	                account.idpName = name;
	            }
	        }
	    }

	    $scope.closeModal = function() {
	        $.colorbox.close();
	    };
	    // init
	    $scope.getSocialAccounts();

	}]);


	// Controller to show alert for unread notifications
	angular.module('orcidApp').controller('NotificationsAlertCtrl',['$scope', '$compile', 'notificationsSrvc', function ($scope, $compile, notificationsSrvc){
	    $scope.getUnreadCount = notificationsSrvc.getUnreadCount;
	    notificationsSrvc.retrieveUnreadCount();
	}]);

	angular.module('orcidApp').controller('SwitchUserCtrl',['$scope', '$compile', '$document', function ($scope, $compile, $document){
	    $scope.isDroppedDown = false;
	    $scope.searchResultsCache = new Object();

	    $scope.openMenu = function(event){
	        $scope.isDroppedDown = true;
	        event.stopPropagation();
	    };

	    $scope.getDelegates = function() {
	        $.ajax({
	            url: getBaseUri() + '/delegators/delegators-and-me.json',
	            dataType: 'json',
	            success: function(data) {
	                $scope.delegators = data.delegators;
	                $scope.searchResultsCache[''] = $scope.delegators;
	                $scope.me = data.me;
	                $scope.unfilteredLength = $scope.delegators != null ? $scope.delegators.delegationDetails.length : 0;
	                $scope.$apply();
	            }
	        }).fail(function(e) {
	            // something bad is happening!
	            console.log("error with delegates");
	            logAjaxError(e);
	        });
	    };

	    $scope.search = function() {
	        if($scope.searchResultsCache[$scope.searchTerm] === undefined) {
	            if($scope.searchTerm === ''){
	                $scope.getDelegates();
	                $scope.searchResultsCache[$scope.searchTerm] = $scope.delegators;
	            }
	            else {
	                $.ajax({
	                    url: getBaseUri() + '/delegators/search/' + encodeURIComponent($scope.searchTerm) + '?limit=10',
	                    dataType: 'json',
	                    success: function(data) {
	                        $scope.delegators = data;
	                        $scope.searchResultsCache[$scope.searchTerm] = $scope.delegators;
	                        $scope.$apply();
	                    }
	                }).fail(function() {
	                    // something bad is happening!
	                    console.log("error searching for delegates");
	                });
	            }
	        } else {
	            $scope.delegators = $scope.searchResultsCache[$scope.searchTerm];
	        }
	    };

	    $scope.switchUser = function(targetOrcid){
	        $.ajax({
	            url: getBaseUri() + '/switch-user?j_username=' + targetOrcid,
	            dataType: 'json',
	            complete: function(data) {
	                window.location.reload();
	            }
	        });
	    };

	    $document.bind('click',
	        function(event){
	            if(event.target.id !== "delegators-search"){
	                $scope.isDroppedDown = false;
	                $scope.searchTerm = '';
	                $scope.$apply();
	            }
	        });

	    // init
	    $scope.getDelegates();
	}]);

	angular.module('orcidApp').controller('statisticCtrl',['$scope', function ($scope){
	    $scope.liveIds = 0;
	    $scope.getLiveIds = function(){
	        $.ajax({
	            url: getBaseUri()+'/statistics/liveids.json',
	            type: 'GET',
	            dataType: 'html',
	            success: function(data){
	                $scope.liveIds = data;
	                $scope.$apply($scope.liveIds);
	            }
	        }).fail(function(e) {
	            // something bad is happening!
	            console.log("Error getting statistics Live iDs total amount");
	            logAjaxError(e);
	        });
	    };

	    $scope.getLiveIds();
	}]);



	angular.module('orcidApp').controller('adminVerifyEmailCtrl',['$scope','$compile', function ($scope,$compile){
	    $scope.showSection = false;

	    $scope.toggleSection = function(){
	        $scope.showSection = !$scope.showSection;
	        $('#verify_email_section').toggle();
	    };

	    $scope.verifyEmail = function(){
	        $.ajax({
	            url: getBaseUri()+'/admin-actions/admin-verify-email.json',
	            type: 'POST',
	            dataType: 'text',
	            data: $scope.email,
	            contentType: 'application/json;charset=UTF-8',
	            success: function(data){
	                $scope.$apply(function(){
	                    $scope.result = data;
	                });
	            }
	        }).fail(function(error) {
	            // something bad is happening!
	            console.log("Error verifying the email address");
	        });
	    };
	}]);

	angular.module('orcidApp').controller('profileDeactivationAndReactivationCtrl',['$scope', '$compile', function ($scope,$compile){
	    $scope.orcidToDeactivate = null;
	    $scope.orcidToReactivate = null;
	    $scope.deactivatedAccount = null;
	    $scope.reactivatedAccount = null;
	    $scope.successMessage = null;
	    $scope.deactivateMessage = om.get('admin.profile_deactivation.success');
	    $scope.reactivateMessage = om.get('admin.profile_reactivation.success');
	    $scope.showDeactivateModal = false;
	    $scope.showReactivateModal = false;

	    $scope.toggleDeactivationModal = function(){
	        $scope.showDeactivateModal = !$scope.showDeactivateModal;
	        $('#deactivation_modal').toggle();
	    };

	    $scope.toggleReactivationModal = function(){
	        $scope.showReactivateModal = !$scope.showReactivateModal;
	        $('#reactivation_modal').toggle();
	    };

	    $scope.deactivateAccount = function() {
	        $.ajax({
	            url: getBaseUri()+'/admin-actions/deactivate-profile?orcid=' + $scope.orcidToDeactivate,
	            type: 'GET',
	            dataType: 'json',
	            success: function(data){
	                $scope.$apply(function(){
	                    $scope.deactivatedAccount = data;
	                    if($scope.deactivatedAccount.errors != null && $scope.deactivatedAccount.errors.length != 0){
	                        $scope.closeModal();
	                    } else {
	                        $scope.orcidToDeactivate = null;
	                        $scope.showSuccessMessage($scope.deactivateMessage);
	                    }
	                });
	            }
	        }).fail(function(error) {
	            // something bad is happening!
	            console.log("Error deprecating the account");
	        });
	    };

	    $scope.reactivateAccount = function() {
	        $.ajax({
	            url: getBaseUri()+'/admin-actions/reactivate-profile?orcid=' + $scope.orcidToReactivate,
	            type: 'GET',
	            dataType: 'json',
	            success: function(data){
	                $scope.$apply(function(){
	                    $scope.reactivatedAccount = data;
	                    if($scope.reactivatedAccount.errors != null && $scope.reactivatedAccount.errors.length != 0){
	                        $scope.closeModal();
	                    } else {
	                        $scope.orcidToReactivate = null;
	                        $scope.showSuccessMessage($scope.reactivateMessage);
	                    }
	                });
	            }
	        }).fail(function(error) {
	            // something bad is happening!
	            console.log("Error reactivating the account");
	        });
	    };

	    $scope.confirmDeactivateAccount = function() {
	        $.ajax({
	            url: getBaseUri()+'/admin-actions/deactivate-profile/check-orcid.json?orcid=' + $scope.orcidToDeactivate,
	            type: 'GET',
	            dataType: 'json',
	            success: function(data){
	                $scope.deactivatedAccount = data;
	                if($scope.deactivatedAccount.errors != null && $scope.deactivatedAccount.errors.length != 0){
	                    console.log($scope.deactivatedAccount.errors);
	                } else {
	                    $scope.showConfirmModal();
	                }
	                $scope.$apply();
	            }
	            }).fail(function(error) {
	                // something bad is happening!
	                console.log("Error deactivating the account");
	            });
	    };

	    $scope.confirmReactivateAccount = function() {
	        $.colorbox({
	            html : $compile($('#confirm-reactivation-modal').html())($scope),
	                scrolling: true,
	                onLoad: function() {
	                $('#cboxClose').remove();
	            },
	            scrolling: true
	        });

	        $.colorbox.resize({width:"450px" , height:"225px"});
	    };

	    $scope.showConfirmModal = function() {
	        $.colorbox({
	            html : $compile($('#confirm-deactivation-modal').html())($scope),
	                scrolling: true,
	                onLoad: function() {
	                $('#cboxClose').remove();
	            },
	            scrolling: true
	        });

	        $.colorbox.resize({width:"525px" , height:"275px"});
	    };

	    $scope.showSuccessMessage = function(message){
	        $scope.successMessage = message;
	        $.colorbox({
	            html : $compile($('#success-modal').html())($scope),
	                scrolling: true,
	                onLoad: function() {
	                $('#cboxClose').remove();
	            },
	            scrolling: true
	        });

	        $.colorbox.resize({width:"425px" , height:"225px"});
	    };

	    $scope.closeModal = function() {
	        $.colorbox.close();
	    };
	}]);

	angular.module('orcidApp').controller('DeactivateProfileCtrl', ['$scope', function ($scope) {
	    $scope.orcidsToDeactivate = "";
	    $scope.showSection = false;

	    $scope.toggleSection = function(){
	        $scope.showSection = !$scope.showSection;
	        $('#deactivation_modal').toggle();
	    };

	    
	    $scope.deactivateOrcids = function() {
	        $.ajax({
	            url: getBaseUri()+'/admin-actions/deactivate-profiles.json',
	            type: 'POST',
	            dataType: 'json',
	            data: $scope.orcidsToDeactivate,
	            contentType: 'application/json;charset=UTF-8',
	            success: function(data){
	                $scope.$apply(function(){
	                    $scope.result = data;
	                });
	            }
	        }).fail(function(error) {
	            // something bad is happening!
	            console.log("Error re-sending claim emails");
	        });
	    }
	}]);

	angular.module('orcidApp').controller('profileDeprecationCtrl',['$scope','$compile', function profileDeprecationCtrl($scope,$compile){
	    $scope.deprecated_verified = false;
	    $scope.primary_verified = false;
	    $scope.deprecatedAccount = null;
	    $scope.primaryAccount = null;
	    $scope.showModal = false;

	    $scope.toggleDeprecationModal = function(){
	        $scope.showModal = !$scope.showModal;
	        $('#deprecation_modal').toggle();
	    };

	    $scope.cleanup = function(orcid_type){
	        $("#deprecated_orcid").removeClass("orcid-red-background-input");
	        $("#primary_orcid").removeClass("orcid-red-background-input");
	        if(orcid_type == 'deprecated'){
	            if($scope.deprecated_verified == false)
	                $("#deprecated_orcid").addClass("error");
	            else
	                $("#deprecated_orcid").removeClass("error");
	        } else {
	            if($scope.primary_verified == false)
	                $("#primary_orcid").addClass("error");
	            else
	                $("#primary_orcid").removeClass("error");
	        }
	    };

	    $scope.getAccountDetails = function (orcid, callback){
	        $.ajax({
	            url: getBaseUri()+'/admin-actions/deprecate-profile/check-orcid.json?orcid=' + orcid,
	            type: 'GET',
	            dataType: 'json',
	            success: function(data){
	                callback(data);
	                $scope.$apply();
	                }
	            }).fail(function(error) {
	                // something bad is happening!
	                console.log("Error getting account details for: " + orcid);
	            });
	    };

	    $scope.findAccountDetails = function(orcid_type){
	        var orcid;
	        var orcidRegex=new RegExp("(\\d{4}-){3,}\\d{3}[\\dX]");
	        if(orcid_type == 'deprecated') {
	            orcid = $scope.deprecatedAccount.orcid;
	        } else {
	            orcid = $scope.primaryAccount.orcid;
	        }
	        //Reset styles
	        $scope.cleanup(orcid_type);
	        if(orcidRegex.test(orcid)){
	            $scope.getAccountDetails(orcid, function(data){
	                if(orcid_type == 'deprecated') {
	                    $scope.invalid_regex_deprecated = false;
	                    if(data.errors.length != 0){
	                        $scope.deprecatedAccount.errors = data.errors;
	                        $scope.deprecatedAccount.givenNames = null;
	                        $scope.deprecatedAccount.familyName = null;
	                        $scope.deprecatedAccount.primaryEmail = null;
	                        $scope.deprecated_verified = false;
	                    } else {
	                        $scope.deprecatedAccount.errors = null;
	                        $scope.deprecatedAccount.givenNames = data.givenNames;
	                        $scope.deprecatedAccount.familyName = data.familyName;
	                        $scope.deprecatedAccount.primaryEmail = data.email;
	                        $scope.deprecated_verified = true;
	                        $scope.cleanup(orcid_type);
	                    }
	                } else {
	                    $scope.invalid_regex_primary = false;
	                    if(data.errors.length != 0){
	                        $scope.primaryAccount.errors = data.errors;
	                        $scope.primaryAccount.givenNames = null;
	                        $scope.primaryAccount.familyName = null;
	                        $scope.primaryAccount.primaryEmail = null;
	                        $scope.primary_verified = false;
	                    } else {
	                        $scope.primaryAccount.errors = null;
	                        $scope.primaryAccount.givenNames = data.givenNames;
	                        $scope.primaryAccount.familyName = data.familyName;
	                        $scope.primaryAccount.primaryEmail = data.email;
	                        $scope.primary_verified = true;
	                        $scope.cleanup(orcid_type);
	                    }
	                }
	            });
	        } else {
	            if(orcid_type == 'deprecated') {
	                if(!($scope.deprecatedAccount === undefined)){
	                    $scope.invalid_regex_deprecated = true;
	                    $scope.deprecatedAccount.errors = null;
	                    $scope.deprecatedAccount.givenNames = null;
	                    $scope.deprecatedAccount.familyName = null;
	                    $scope.deprecatedAccount.primaryEmail = null;
	                    $scope.deprecated_verified = false;
	                }
	            } else {
	                if(!($scope.primaryAccount === undefined)){
	                    $scope.invalid_regex_primary = true;
	                    $scope.primaryAccount.errors = null;
	                    $scope.primaryAccount.givenNames = null;
	                    $scope.primaryAccount.familyName = null;
	                    $scope.primaryAccount.primaryEmail = null;
	                    $scope.primary_verified = false;
	                }
	            }
	        }
	    };

	    $scope.confirmDeprecateAccount = function(){
	        var isOk = true;
	        $scope.errors = null;
	        if($scope.deprecated_verified === undefined || $scope.deprecated_verified == false){
	            $("#deprecated_orcid").addClass("error orcid-red-background-input");
	            isOk = false;
	        }

	        if($scope.primary_verified === undefined || $scope.primary_verified == false){
	            $("#primary_orcid").addClass("error orcid-red-background-input");
	            isOk = false;
	        }

	        if(isOk){
	            $.colorbox({
	                html : $compile($('#confirm-deprecation-modal').html())($scope),
	                    scrolling: true,
	                    onLoad: function() {
	                    $('#cboxClose').remove();
	                },
	                scrolling: true
	            });

	            $.colorbox.resize({width:"625px" , height:"400px"});
	        }
	    };

	    $scope.deprecateAccount = function(){
	        var deprecatedOrcid = $scope.deprecatedAccount.orcid;
	        var primaryOrcid = $scope.primaryAccount.orcid;
	        $.ajax({
	            url: getBaseUri()+'/admin-actions/deprecate-profile/deprecate-profile.json?deprecated=' + deprecatedOrcid + '&primary=' + primaryOrcid,
	            type: 'GET',
	            dataType: 'json',
	            success: function(data){
	                $scope.$apply(function(){
	                    if(data.errors.length != 0){
	                        $scope.errors = data.errors;
	                    } else {
	                        $scope.showSuccessModal(deprecatedOrcid, primaryOrcid);
	                    }
	                });
	            }
	        }).fail(function(error) {
	            // something bad is happening!
	            console.log("Error deprecating the account");
	        });
	    };

	    $scope.showSuccessModal = function(deprecated, primary){
	        $scope.successMessage = om.get('admin.profile_deprecation.deprecate_account.success_message').replace("{{0}}", deprecated).replace("{{1}}", primary);

	        //Clean fields
	        $scope.deprecated_verified = false;
	        $scope.primary_verified = false;
	        $scope.deprecatedAccount = null;
	        $scope.primaryAccount = null;

	        $.colorbox({
	            html : $compile($('#success-modal').html())($scope),
	                scrolling: true,
	                onLoad: function() {
	                $('#cboxClose').remove();
	            },
	            scrolling: true
	        });

	        $.colorbox.resize({width:"450px" , height:"150px"});
	    };

	    $scope.closeModal = function() {
	        $scope.deprecated_verified = false;
	        $scope.primary_verified = false;
	        $scope.deprecatedAccount = null;
	        $scope.primaryAccount = null;
	        $scope.showModal = false;       
	        $.colorbox.close();
	    };
	}]);

	angular.module('orcidApp').controller('revokeApplicationFormCtrl',['$scope', '$compile', function ($scope,$compile){
	    
	    $scope.applicationSummary = null;
	    $scope.applicationSummaryList = null;
	    
	    $scope.confirmRevoke = function(applicationSummary){
	        $scope.applicationSummary = applicationSummary;
	        $.colorbox({
	            html : $compile($('#confirm-revoke-access-modal').html())($scope),
	            transition: 'fade',
	            close: '',
	            onLoad: function() {
	                $('#cboxClose').remove();
	            },
	            onComplete: function() {$.colorbox.resize();},
	            scrolling: true
	        });
	    };

	    $scope.revokeAccess = function(){
	        $.ajax({
	            url: getBaseUri() + '/account/revoke-application.json?tokenId='+ $scope.applicationSummary.tokenId,
	            type: 'POST',
	            success: function(data) {
	                $scope.getApplications();
	                $scope.closeModal();
	            }
	        }).fail(function() {
	            // something bad is happening!
	            console.log("revokeApplicationFormCtrl.revoke() error");
	        });
	    };

	    $scope.closeModal = function() {
	        $.colorbox.close();
	    };
	    
	    $scope.getApplications = function() {
	        $.ajax({
	            url: getBaseUri()+'/account/get-trusted-orgs.json',
	            type: 'GET',
	            dataType: 'json',
	            success: function(data){                
	                $scope.$apply(function(){
	                    for(var index1 = 0; index1 < data.length; index1 ++) {
	                        data[index1].approvalDate = formatDate(data[index1].approvalDate);                      
	                    }
	                    $scope.applicationSummaryList = data;                   
	                    
	                });
	            }
	        }).fail(function(error) {
	            // something bad is happening!
	            console.log("Error finding the information");
	        });
	    }
	    
	    $scope.getApplicationUrlLink = function(application) {
	        if(application.websiteValue != null) {
	            if(application.websiteValue.lastIndexOf('http://') === -1 && application.websiteValue.lastIndexOf('https://') === -1) {
	                return '//' + application.websiteValue;
	            } else {
	                return application.websiteValue;
	            }
	        }
	        return '';
	    }
	    
	    $scope.getApplications();
	    
	}]);

	/**
	 * Manage members controller
	 * */
	angular.module('orcidApp').controller('manageMembersCtrl',['$scope', '$compile', function manageMembersCtrl($scope, $compile) {    
	    $scope.showFindModal = false;
	    $scope.success_message = null;
	    $scope.client_id = null;
	    $scope.client = null;
	    $scope.showError = false;
	    $scope.availableRedirectScopes = [];
	    $scope.selectedScope = "";
	    $scope.newMember = null;
	    $scope.groups = [];
	    $scope.importWorkWizard = {
	        'actTypeList' : ['Articles','Books','Data','Student Publications'],
	        'geoAreaList' : ['Global', 'Africa', 'Asia', 'Australia', 'Europe', 'North America', 'South America']
	    };

	    $scope.toggleGroupsModal = function() {
	        $scope.showAdminGroupsModal = !$scope.showAdminGroupsModal;
	        $('#admin_groups_modal').toggle();
	    };
	    
	    $scope.toggleFindModal = function() {
	        $scope.showAdminGroupsModal = !$scope.showAdminGroupsModal;
	        $('#find_edit_modal').toggle();
	    };
	    
	    /**
	     * FIND
	     * */
	    $scope.findAny = function() {
	        success_edit_member_message = null;
	        success_message = null;
	        $.ajax({
	            url: getBaseUri()+'/manage-members/find.json?id=' + encodeURIComponent($scope.any_id),
	            type: 'GET',
	            dataType: 'json',
	            success: function(data){
	                $scope.$apply(function(){  
	                    if(data.client == true) {
	                        $scope.client = data.clientObject;
	                        $scope.member = null;
	                        for(var i = 0; i < $scope.client.redirectUris.length; i ++) {
	                            $scope.client.redirectUris[i].actType.value = JSON.parse($scope.client.redirectUris[i].actType.value);
	                            $scope.client.redirectUris[i].geoArea.value = JSON.parse($scope.client.redirectUris[i].geoArea.value);
	                        }
	                    } else {
	                        $scope.client = null;
	                        $scope.member = data.memberObject;
	                    }
	                });
	            }
	        }).fail(function(error) {
	            // something bad is happening!
	            console.log("Error finding the information");
	        });
	    };
	    
	    /**
	     * MEMBERS
	     * */
	    $scope.getMember = function() {
	        $.ajax({
	            url: getBaseUri()+'/manage-members/member.json',
	            type: 'GET',
	            dataType: 'json',
	            success: function(data){
	                $scope.$apply(function(){
	                    $scope.newMember = data;
	                });
	            }
	        }).fail(function(error) {
	            // something bad is happening!
	            console.log("Error getting emtpy group");
	        });
	    };

	    $scope.addMember = function() {
	        $.ajax({
	            url: getBaseUri()+'/manage-members/create-member.json',
	            contentType: 'application/json;charset=UTF-8',
	            type: 'POST',
	            dataType: 'json',
	            data: angular.toJson($scope.newMember),
	            success: function(data){
	                $scope.$apply(function(){
	                    $scope.newMember = data;
	                    if(data.errors.length != 0){

	                    } else {
	                        $scope.showSuccessModal();
	                    }
	                });
	            }
	        }).fail(function(error) {
	            // something bad is happening!
	            console.log("Error deprecating the account");
	        });
	    };

	    $scope.findMember = function() {
	        $scope.success_edit_member_message = null;
	        $.ajax({
	            url: getBaseUri()+'/manage-members/find-member.json?orcidOrEmail=' + $scope.member_id,
	            type: 'GET',
	            dataType: 'json',
	            success: function(data) {
	                $scope.member = data;
	                $scope.$apply();
	            }
	        }).fail(function(error) {
	            // something bad is happening!
	            console.log("Error getting existing groups");
	        });
	    };

	    $scope.updateMember = function() {
	        $.ajax({
	            url: getBaseUri()+'/manage-members/update-member.json',
	            contentType: 'application/json;charset=UTF-8',
	            type: 'POST',
	            dataType: 'json',
	            data: angular.toJson($scope.member),
	            success: function(data){
	                $scope.$apply(function(){
	                    if(data.errors.length == 0){
	                        $scope.member = null;
	                        $scope.success_edit_member_message = om.get('manage_member.edit_member.success');
	                        $scope.member_id = null;
	                    } else {
	                        $scope.member = data;
	                    }
	                });
	                $scope.closeModal();
	            }
	        }).fail(function(error) {
	            // something bad is happening!
	            console.log("Error deprecating the account");
	        });
	    };

	    /**
	     * CLIENTS
	     * */
	    $scope.searchClient = function() {
	        $scope.showError = false;
	        $scope.client = null;
	        $scope.success_message = null;
	        $.ajax({
	            url: getBaseUri()+'/manage-members/find-client.json?orcid=' + $scope.client_id,
	            type: 'GET',
	            dataType: 'json',
	            success: function(data) {
	                $scope.client = data;
	                $scope.$apply();
	            }
	        }).fail(function(error) {
	            // something bad is happening!
	            console.log("Error getting existing groups");
	        });
	    };

	    //Load empty redirect uri
	    $scope.addRedirectUri = function() {
	        $.ajax({
	            url: getBaseUri() + '/manage-members/empty-redirect-uri.json',
	            type: 'GET',
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                $scope.client.redirectUris.push(data);
	                $scope.$apply();
	            }
	        }).fail(function() {
	            console.log("Unable to fetch redirect uri scopes.");
	        });
	    };

	    $scope.deleteRedirectUri = function($index){
	        $scope.client.redirectUris.splice($index,1);
	    };

	    //Load the default scopes based n the redirect uri type selected
	    $scope.loadDefaultScopes = function(rUri) {
	        //Empty the scopes to update the default ones
	        rUri.scopes = [];
	        //Fill the scopes with the default scopes
	        if(rUri.type.value == 'grant-read-wizard'){
	            rUri.scopes.push('/orcid-profile/read-limited');
	        } else if (rUri.type.value == 'import-works-wizard'){
	            rUri.scopes.push('/orcid-profile/read-limited');
	            rUri.scopes.push('/orcid-works/create');
	        } else if (rUri.type.value == 'import-funding-wizard'){
	            rUri.scopes.push('/orcid-profile/read-limited');
	            rUri.scopes.push('/funding/create');
	        } else if (rUri.type.value == 'import-peer-review-wizard'){
	            rUri.scopes.push('/orcid-profile/read-limited');
	            rUri.scopes.push('/peer-review/create');
	        } else if(rUri.type.value == 'institutional-sign-in') {
	            rUri.scopes.push('/authenticate');
	        }
	    };

	    //Load the list of scopes for client redirect uris
	    $scope.loadAvailableScopes = function(){
	        $.ajax({
	            url: getBaseUri() + '/group/developer-tools/get-available-scopes.json',
	            type: 'GET',
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                $scope.availableRedirectScopes = data;
	            }
	        }).fail(function() {
	            console.log("Unable to fetch redirect uri scopes.");
	        });
	    };

	    //Update client
	    $scope.updateClient = function() {
	        var clientClone = JSON.parse(JSON.stringify($scope.client));
	        for(var i = 0; i < clientClone.redirectUris.length; i ++) {
	            clientClone.redirectUris[i].actType.value = JSON.stringify(clientClone.redirectUris[i].actType.value);
	            clientClone.redirectUris[i].geoArea.value = JSON.stringify(clientClone.redirectUris[i].geoArea.value);
	        }
	        $.ajax({
	            url: getBaseUri() + '/manage-members/update-client.json',
	            type: 'POST',
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            data: angular.toJson(clientClone),
	            success: function(data) {
	                if(data.errors.length == 0){
	                    $scope.client = null;
	                    $scope.client_id = "";
	                    $scope.success_message = om.get('admin.edit_client.success');
	                } else {
	                    $scope.client.errors = data.errors;
	                }
	                $scope.$apply();
	                $scope.closeModal();
	            }
	        }).fail(function() {
	            console.log("Unable to update client.");
	        });
	    };

	    //init
	    $scope.loadAvailableScopes();
	    $scope.getMember();

	    /**
	     * Colorbox
	     * */
	    //Confirm updating a client
	    $scope.confirmUpdateClient = function() {
	        $.colorbox({
	            html : $compile($('#confirm-modal-client').html())($scope),
	                scrolling: true,
	                onLoad: function() {
	                $('#cboxClose').remove();
	            },
	            scrolling: true
	        });

	        $.colorbox.resize({width:"450px" , height:"175px"});
	    };

	    //Confirm updating a member
	    $scope.confirmUpdateMember = function() {
	        $.colorbox({
	            html : $compile($('#confirm-modal-member').html())($scope),
	                scrolling: true,
	                onLoad: function() {
	                $('#cboxClose').remove();
	            },
	            scrolling: true
	        });

	        $.colorbox.resize({width:"450px" , height:"175px"});
	    };

	    //Display add member modal
	    $scope.showAddMemberModal = function() {
	        $scope.getMember();
	        $.colorbox({
	            html : $compile($('#add-new-member').html())($scope),
	                onLoad: function() {
	                $('#cboxClose').remove();
	            }
	        });

	        $.colorbox.resize({width:"400px" , height:"500px"});
	    };

	    //Show success modal for groups
	    $scope.showSuccessModal = function() {
	        $.colorbox({
	            html : $compile($('#new-group-info').html())($scope),
	                onLoad: function() {
	                $('#cboxClose').remove();
	            }
	        });

	        $.colorbox.resize({width:"500px" , height:"500px"});
	    };

	    /**
	     * General
	     * */
	    $scope.closeModal = function() {
	        $.colorbox.close();
	    };
	    
	    $scope.selectAll = function($event){
	        $event.target.select();
	    };
	}]);

	/**
	 * Internal consortium controller
	 * */
	angular.module('orcidApp').controller('internalConsortiumCtrl',['$scope', '$compile', function manageConsortiumCtrl($scope, $compile) {    
	    $scope.showFindModal = false;
	    $scope.consortium = null;

	    $scope.toggleFindConsortiumModal = function() {
	        $scope.showFindModal = !$scope.showFindModal;
	    };
	    
	    /**
	     * FIND
	     * */
	    $scope.findConsortium = function() {
	        $.ajax({
	            url: getBaseUri()+'/manage-members/find-consortium.json?id=' + encodeURIComponent($scope.salesForceId),
	            type: 'GET',
	            dataType: 'json',
	            success: function(data){
	                $scope.consortium = data;
	                $scope.$apply();
	            }
	        }).fail(function(error) {
	            // something bad is happening!
	            console.log("Error finding the consortium");
	        });
	    };
	    
	    $scope.confirmUpdateConsortium = function() {
	        $.colorbox({
	            html : $compile($('#confirm-modal-consortium').html())($scope),
	                scrolling: true,
	                onLoad: function() {
	                $('#cboxClose').remove();
	            },
	            scrolling: true
	        });

	        $.colorbox.resize({width:"450px" , height:"175px"});
	    };
	    
	    $scope.updateConsortium = function() {
	        $.ajax({
	            url: getBaseUri()+'/manage-members/update-consortium.json',
	            contentType: 'application/json;charset=UTF-8',
	            type: 'POST',
	            dataType: 'json',
	            data: angular.toJson($scope.consortium),
	            success: function(data){
	                $scope.$apply(function(){
	                    if(data.errors.length == 0){
	                        $scope.consortium = null;
	                        $scope.success_edit_member_message = om.get('manage_member.edit_member.success');
	                    } else {
	                        $scope.consortium = data;
	                    }
	                });
	                $scope.closeModal();
	            }
	        }).fail(function(error) {
	            // something bad is happening!
	            console.log("Error updating the consortium");
	        });
	    };
	    
	    $scope.closeModal = function() {
	        $.colorbox.close();
	    };
	    
	}]);

	/**
	 * External consortium controller
	 */
	angular.module('orcidApp').controller('externalConsortiumCtrl',['$scope', '$compile', function manageConsortiumCtrl($scope, $compile) {    
	   $scope.consortium = null;

	   $scope.toggleFindConsortiumModal = function() {
	       $scope.showFindModal = !$scope.showFindModal;
	   };
	   
	   /**
	    * GET
	    * */
	   $scope.getConsortium = function() {
	       $.ajax({
	           url: getBaseUri()+'/manage-consortium/get-consortium.json',
	           type: 'GET',
	           dataType: 'json',
	           success: function(data){
	               $scope.consortium = data;
	               $scope.$apply();
	           }
	       }).fail(function(error) {
	           // something bad is happening!
	           console.log("Error getting the consortium");
	       });
	   };
	   
	   $scope.confirmUpdateConsortium = function() {
	       $.colorbox({
	           html : $compile($('#confirm-modal-consortium').html())($scope),
	               scrolling: true,
	               onLoad: function() {
	               $('#cboxClose').remove();
	           },
	           scrolling: true
	       });

	       $.colorbox.resize({width:"450px" , height:"175px"});
	   };
	   
	   $scope.updateConsortium = function() {
	       $.ajax({
	           url: getBaseUri()+'/manage-consortium/update-consortium.json',
	           contentType: 'application/json;charset=UTF-8',
	           type: 'POST',
	           dataType: 'json',
	           data: angular.toJson($scope.consortium),
	           success: function(data){
	               $scope.$apply(function(){
	                   if(data.errors.length == 0){
	                       $scope.success_edit_member_message = om.get('manage_member.edit_member.success');
	                   } else {
	                       $scope.consortium = data;
	                   }
	               });
	               $scope.closeModal();
	           }
	       }).fail(function(error) {
	           // something bad is happening!
	           console.log("Error updating the consortium");
	       });
	   };
	   
	   $scope.closeModal = function() {
	       $.colorbox.close();
	   };
	   
	   // Init
	   $scope.getConsortium();
	   
	}]);


	angular.module('orcidApp').controller('findIdsCtrl',['$scope','$compile', function findIdsCtrl($scope,$compile){
	    $scope.emails = "";
	    $scope.emailIdsMap = {};
	    $scope.showSection = false;

	    $scope.toggleSection = function(){
	        $scope.showSection = !$scope.showSection;
	        $('#find_ids_section').toggle();
	    };

	    $scope.findIds = function() {
	        $.ajax({
	            url: getBaseUri()+'/admin-actions/find-id.json',
	            type: 'POST',
	            dataType: 'json',
	            data: $scope.emails,
	            contentType: 'application/json;charset=UTF-8',
	            success: function(data){
	                $scope.$apply(function(){
	                    if(!$.isEmptyObject(data)) {
	                        $scope.profileList = data;
	                    } else {
	                        $scope.profileList = null;
	                    }
	                    $scope.emails='';
	                    $scope.showEmailIdsModal();
	                });
	            }
	        }).fail(function(error) {
	            // something bad is happening!
	            console.log("Error deprecating the account");
	        });
	    };

	    $scope.showEmailIdsModal = function() {
	        $.colorbox({
	            html : $compile($('#email-ids-modal').html())($scope),
	                scrolling: true,
	                onLoad: function() {
	                $('#cboxClose').remove();
	            },
	            scrolling: true
	        });

	        setTimeout(function(){$.colorbox.resize({width:"575px"});},100);
	    };

	    $scope.closeModal = function() {
	        $.colorbox.close();
	    };
	}]);

	angular.module('orcidApp').controller('resetPasswordCtrlModal',['$scope', '$compile', function ($scope,$compile) {
	    $scope.showSection = false;
	    $scope.params = {orcidOrEmail:'',password:''};
	    $scope.result = '';

	    $scope.toggleSection = function(){
	        $scope.showSection = !$scope.showSection;
	        $('#reset_password_section').toggle();
	    };

	    $scope.randomString = function() {
	        $scope.result = '';
	        $.ajax({
	            url: getBaseUri()+'/admin-actions/generate-random-string.json',
	            type: 'GET',
	            dataType: 'text',
	            success: function(data){
	                $scope.$apply(function(){
	                    $scope.params.password=data;
	                });
	            }
	        }).fail(function(e) {
	            // something bad is happening!
	            console.log("Error generating random string");
	            logAjaxError(e);
	        });
	    };

	    $scope.resetPassword = function(){
	        $scope.result = '';
	        $.ajax({
	            url: getBaseUri()+'/admin-actions/reset-password.json',
	            type: 'POST',
	            data: angular.toJson($scope.params),
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'text',
	            success: function(data){
	                $scope.$apply(function(){
	                    $scope.result=data;
	                    $scope.params.orcidOrEmail='';
	                    $scope.params.password='';
	                });
	                $scope.closeModal();
	            }
	        }).fail(function(error) {
	            // something bad is happening!
	            console.log("Error generating random string");
	        });
	    };

	    $scope.confirmResetPassword = function(){
	        if($scope.params.orcidOrEmail != '' && $scope.params.password != '') {
	            $.colorbox({
	                html : $compile($('#confirm-reset-password').html())($scope),
	                    scrolling: true,
	                    onLoad: function() {
	                    $('#cboxClose').remove();
	                },
	                scrolling: true
	            });

	            $.colorbox.resize({width:"450px" , height:"150px"});
	        }
	    };

	    $scope.closeModal = function() {
	        $scope.params.orcidOrEmail='';
	        $scope.params.password='';
	        $scope.result= '';
	        $.colorbox.close();
	    };
	}]);

	angular.module('orcidApp').controller('removeSecQuestionCtrl',['$scope','$compile', function ($scope,$compile) {
	    $scope.showSection = false;
	    $scope.orcidOrEmail = '';
	    $scope.result= '';

	    $scope.toggleSection = function(){
	        $scope.showSection = !$scope.showSection;
	        $('#remove_security_question_section').toggle();
	    };

	    $scope.removeSecurityQuestion = function() {
	        $.ajax({
	            url: getBaseUri()+'/admin-actions/remove-security-question.json',
	            type: 'POST',
	            data: $scope.orcidOrEmail,
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'text',
	            success: function(data){
	                $scope.$apply(function(){
	                    $scope.result=data;
	                    $scope.orcid = '';
	                });
	                $scope.closeModal();
	            }
	        }).fail(function(error) {
	            // something bad is happening!
	            console.log("Error generating random string");
	        });
	    };

	    $scope.confirmRemoveSecurityQuestion = function(){
	        if($scope.orcid != '') {
	            $.colorbox({
	                html : $compile($('#confirm-remove-security-question').html())($scope),
	                    scrolling: true,
	                    onLoad: function() {
	                    $('#cboxClose').remove();
	                },
	                scrolling: true
	            });

	            $.colorbox.resize({width:"450px" , height:"150px"});
	        }
	    };

	    $scope.closeModal = function() {
	        $scope.orcidOrEmail = '';
	        $scope.result= '';
	        $.colorbox.close();
	    };
	}]);

	angular.module('orcidApp').controller('profileLockingCtrl', ['$scope', '$compile', function($scope, $compile){
	    $scope.orcidToLock = '';
	    $scope.orcidToUnlock = '';
	    $scope.showLockModal = false;
	    $scope.showUnlockModal = false;
	    
	    $scope.toggleLockModal = function(){
	        $scope.showLockModal = !$scope.showLockModal;
	        $('#lock_modal').toggle();
	    };
	    
	    $scope.toggleUnlockModal = function(){
	        $scope.showUnlockModal = !$scope.showUnlockModal;
	        $('#unlock_modal').toggle();
	    };
	    
	    $scope.lockAccount = function() {
	        $.ajax({
	            url: getBaseUri()+'/admin-actions/lock-accounts.json',
	            type: 'POST',
	            data: $scope.orcidToLock,
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data){
	                $scope.result = data;
	                $scope.orcidToLock = '';
	                $scope.$apply();
	            }
	        }).fail(function(error) {
	            // something bad is happening!
	            console.log("Error while locking account");
	        });
	    };
	    
	    $scope.unlockAccount = function() {
	        $.ajax({
	            url: getBaseUri()+'/admin-actions/unlock-accounts.json',
	            type: 'POST',
	            data: $scope.orcidToUnlock,
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data){   
	                $scope.result = data;               
	                $scope.orcidToUnlock = '';
	                $scope.$apply();
	            }
	        }).fail(function(error) {
	            // something bad is happening!
	            console.log("Error while unlocking account");
	        });
	    };
	    
	    $scope.closeModal = function() {        
	        $.colorbox.close();
	    };
	}]);

	angular.module('orcidApp').controller('profileReviewCtrl', ['$scope', '$compile', function($scope, $compile){
	    $scope.orcidToReview = '';
	    $scope.orcidToUnreview = '';
	    $scope.showReviewModal = false;
	    $scope.showUnreviewModal = false;
	    
	    $scope.toggleReviewModal = function(){
	        $scope.showReviewModal = !$scope.showReviewModal;
	        $('#review_modal').toggle();
	    };
	    
	    $scope.toggleUnreviewModal = function(){
	        $scope.showUnreviewModal = !$scope.showUnreviewModal;
	        $('#unreview_modal').toggle();
	    };
	    
	    $scope.reviewAccount = function() {
	        $.ajax({
	            url: getBaseUri()+'/admin-actions/review-accounts.json',
	            type: 'POST',
	            data: $scope.orcidToReview,
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data){   
	                $scope.result = data;               
	                $scope.orcidToReview = '';
	                $scope.$apply();
	            }
	        }).fail(function(error) {
	            // something bad is happening!
	            console.log("Error while reviewing account");
	        });
	    };
	    
	    $scope.unreviewAccount = function() {
	        $.ajax({
	            url: getBaseUri()+'/admin-actions/unreview-accounts.json',
	            type: 'POST',
	            data: $scope.orcidToUnreview,
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data){   
	                $scope.result = data;               
	                $scope.orcidToUnreview = '';
	                $scope.$apply();
	            }
	        }).fail(function(error) {
	            // something bad is happening!
	            console.log("Error while unlocking account");
	        });
	    };
	    
	    $scope.closeModal = function() {        
	        $.colorbox.close();
	    };
	}]);

	angular.module('orcidApp').controller('lookupIdOrEmailCtrl',['$scope','$compile', function findIdsCtrl($scope,$compile){
	    $scope.idOrEmails = "";
	    $scope.emailIdsMap = {};
	    $scope.showSection = false;

	    $scope.toggleSection = function(){
	        $scope.showSection = !$scope.showSection;
	        $('#lookup_ids_section').toggle();
	    };

	    $scope.lookupIdOrEmails = function() {
	        $.ajax({
	            url: getBaseUri()+'/admin-actions/lookup-id-or-emails.json',
	            type: 'POST',
	            dataType: 'text',
	            data: $scope.idOrEmails,
	            contentType: 'application/json;charset=UTF-8',
	            success: function(data){
	                $scope.$apply(function(){
	                    console.log(data);
	                    $scope.result = data;
	                    $scope.idOrEmails='';
	                    $scope.showEmailIdsModal();
	                });
	            }
	        }).fail(function(error) {
	            // something bad is happening!
	            console.log("Error deprecating the account");
	        });
	    };

	    $scope.showEmailIdsModal = function() {
	        $.colorbox({
	            html : $compile($('#lookup-email-ids-modal').html())($scope),
	                scrolling: true,
	                onLoad: function() {
	                $('#cboxClose').remove();
	            },
	            scrolling: true
	        });

	        setTimeout(function(){$.colorbox.resize({width:"575px"});},100);
	    };

	    $scope.closeModal = function() {
	        $.colorbox.close();
	    };
	}]);

	angular.module('orcidApp').controller('ResendClaimCtrl', ['$scope', function ($scope) {
	    $scope.emailIds = "";
	    $scope.showSection = false;

	    $scope.toggleSection = function(){
	        $scope.showSection = !$scope.showSection;
	        $('#batch_resend_section').toggle();
	    };

	    
	    $scope.resendClaimEmails = function() {
	        $.ajax({
	            url: getBaseUri()+'/admin-actions/resend-claim.json',
	            type: 'POST',
	            dataType: 'json',
	            data: $scope.emailIds,
	            contentType: 'application/json;charset=UTF-8',
	            success: function(data){
	                $scope.$apply(function(){
	                    $scope.result = data;
	                });
	            }
	        }).fail(function(error) {
	            // something bad is happening!
	            console.log("Error re-sending claim emails");
	        });
	    }
	}]);

	angular.module('orcidApp').controller('SSOPreferencesCtrl',['$scope', '$compile', '$sce', 'emailSrvc', function ($scope, $compile, $sce, emailSrvc) {
	    $scope.noCredentialsYet = true;
	    $scope.userCredentials = null;
	    $scope.editing = false;
	    $scope.hideGoogleUri = false;
	    $scope.hideRunscopeUri = false;
	    $scope.googleUri = 'https://developers.google.com/oauthplayground';
	    $scope.runscopeUri = 'https://www.runscope.com/oauth_tool/callback';
	    $scope.playgroundExample = '';
	    $scope.googleExampleLink = 'https://developers.google.com/oauthplayground/#step1&scopes=/authenticate&oauthEndpointSelect=Custom&oauthAuthEndpointValue=[BASE_URI_ENCODE]/oauth/authorize&oauthTokenEndpointValue=[BASE_URI_ENCODE]/oauth/token&oauthClientId=[CLIENT_ID]&oauthClientSecret=[CLIENT_SECRET]&accessTokenType=bearer';
	    $scope.sampleAuthCurl = '';
	    $scope.sampleAuthCurlTemplate = "curl -i -L -k -H 'Accept: application/json' --data 'client_id=[CLIENT_ID]&client_secret=[CLIENT_SECRET]&grant_type=authorization_code&redirect_uri=[REDIRECT_URI]&code=REPLACE WITH OAUTH CODE' [BASE_URI]/oauth/token";
	    $scope.runscopeExample = '';
	    $scope.runscopeExampleLink = 'https://www.runscope.com/oauth2_tool';
	    $scope.authorizeUrlBase = getBaseUri() + '/oauth/authorize';
	    $scope.authorizeURLTemplate = $scope.authorizeUrlBase + '?client_id=[CLIENT_ID]&response_type=code&scope=/authenticate&redirect_uri=[REDIRECT_URI]';
	    $scope.tokenURL = orcidVar.pubBaseUri + '/oauth/token';
	    $scope.authorizeURL = '';
	    $scope.selectedRedirectUri = '';
	    $scope.creating = false;
	    $scope.emailSrvc = emailSrvc;
	    $scope.nameToDisplay = '';
	    $scope.descriptionToDisplay = '';
	    $scope.verifyEmailSent=false;
	    $scope.accepted=false;
	    $scope.expanded = false;    
	    
	    $scope.verifyEmail = function() {
	        var funct = function() {
	            $scope.verifyEmailObject = emailSrvc.primaryEmail;
	            emailSrvc.verifyEmail(emailSrvc.primaryEmail,function(data) {
	                $scope.verifyEmailSent = true;    
	                $scope.$apply();                    
	           });            
	       };
	       if (emailSrvc.primaryEmail == null)
	              emailSrvc.getEmails(funct);
	       else
	           funct();
	    };

	    $scope.closeModal = function() {
	        $.colorbox.close();
	    };

	    $scope.acceptTerms = function() {
	        $scope.mustAcceptTerms = false;
	        $scope.accepted = false;
	        $.colorbox({
	            html : $compile($('#terms-and-conditions-modal').html())($scope),
	                scrolling: true,
	                onLoad: function() {
	                $('#cboxClose').remove();
	            },
	            scrolling: true
	        });

	        $.colorbox.resize({width:"590px"});
	    };
	    
	    $scope.enableDeveloperTools = function() {
	        if($scope.accepted == true) {
	            $scope.mustAcceptTerms = false;
	            $.ajax({
	                url: getBaseUri()+'/developer-tools/enable-developer-tools.json',
	                contentType: 'application/json;charset=UTF-8',
	                type: 'POST',
	                success: function(data){
	                    if(data == true){
	                        window.location.href = getBaseUri()+'/developer-tools';
	                    };
	                }
	            }).fail(function(error) {
	                // something bad is happening!
	                console.log("Error enabling developer tools");
	            });
	        } else {
	            $scope.mustAcceptTerms = true;
	        }        
	    };

	    $scope.confirmDisableDeveloperTools = function() {
	        $.colorbox({
	            html : $compile($('#confirm-disable-developer-tools').html())($scope),
	                onLoad: function() {
	                $('#cboxClose').remove();
	            }
	        });
	    };

	    $scope.disableDeveloperTools = function() {
	        $.ajax({
	            url: getBaseUri()+'/developer-tools/disable-developer-tools.json',
	            contentType: 'application/json;charset=UTF-8',
	            type: 'POST',
	            success: function(data){
	                if(data == true){
	                    window.location.href = getBaseUri()+'/account';
	                };
	            }
	        }).fail(function(error) {
	            // something bad is happening!
	            console.log("Error enabling developer tools");
	        });
	    };

	    $scope.getSSOCredentials = function() {
	        $.ajax({
	            url: getBaseUri()+'/developer-tools/get-sso-credentials.json',
	            contentType: 'application/json;charset=UTF-8',
	            type: 'GET',
	            success: function(data){
	                $scope.$apply(function(){
	                    if(data != null && data.clientSecret != null) {
	                        $scope.playgroundExample = '';
	                        $scope.userCredentials = data;
	                        $scope.hideGoogleUri = false;                        
	                        $scope.selectedRedirectUri = $scope.userCredentials.redirectUris[0];
	                        for(var i = 0; i < $scope.userCredentials.redirectUris.length; i++) {
	                            if($scope.googleUri == $scope.userCredentials.redirectUris[i].value.value) {
	                                $scope.hideGoogleUri = true;
	                            }

	                            if($scope.userCredentials.redirectUris[i].value.value < $scope.selectedRedirectUri.value.value) {
	                                $scope.selectedRedirectUri = $scope.userCredentials.redirectUris[i];
	                            }
	                        }
	                        $scope.updateSelectedRedirectUri();
	                        $scope.setHtmlTrustedNameAndDescription();
	                    } else {
	                        $scope.createCredentialsLayout();
	                        $scope.noCredentialsYet = true;
	                    }
	                });
	            }
	        }).fail(function(e) {
	            // something bad is happening!
	            console.log("Error obtaining SSO credentials");
	            logAjaxError(e);
	        });
	    };

	    // Get an empty modal to add
	    $scope.createCredentialsLayout = function(){
	        $.ajax({
	            url: getBaseUri() + '/developer-tools/get-empty-sso-credential.json',
	            dataType: 'json',
	            success: function(data) {
	                $scope.$apply(function(){
	                    $scope.hideGoogleUri = false;
	                    $scope.creating = true;
	                    $scope.userCredentials = data;
	                });
	            }
	        }).fail(function() {
	            console.log("Error fetching client");
	        });
	    };

	    $scope.addRedirectURI = function() {
	        $scope.userCredentials.redirectUris.push({value: '',type: 'default'});
	        $scope.hideGoogleUri = false;
	        for(var i = 0; i < $scope.userCredentials.redirectUris.length; i++) {
	            if($scope.googleUri == $scope.userCredentials.redirectUris[i].value.value) {
	                $scope.hideGoogleUri = true;
	            }
	        }
	    };

	    $scope.submit = function() {
	        $.ajax({
	            url: getBaseUri()+'/developer-tools/generate-sso-credentials.json',
	            contentType: 'application/json;charset=UTF-8',
	            type: 'POST',
	            dataType: 'json',
	            data: angular.toJson($scope.userCredentials),
	            success: function(data){
	                $scope.$apply(function(){
	                    $scope.playgroundExample = '';
	                    $scope.userCredentials = data;
	                    if(data.errors.length != 0){
	                        //SHOW ERROR
	                    } else {
	                        $scope.hideGoogleUri = false;
	                        $scope.selectedRedirectUri = $scope.userCredentials.redirectUris[0];
	                        for(var i = 0; i < $scope.userCredentials.redirectUris.length; i++) {
	                            if($scope.googleUri == $scope.userCredentials.redirectUris[i].value.value) {
	                                $scope.hideGoogleUri = true;
	                            }

	                            if($scope.userCredentials.redirectUris[i].value.value < $scope.selectedRedirectUri.value.value) {
	                                $scope.selectedRedirectUri = $scope.userCredentials.redirectUris[i];
	                            }
	                        }
	                        $scope.updateSelectedRedirectUri();
	                        $scope.setHtmlTrustedNameAndDescription();
	                        $scope.creating = false;
	                        $scope.noCredentialsYet = false;
	                    }
	                });
	            }
	        }).fail(function(error) {
	            // something bad is happening!
	            console.log("Error creating SSO credentials");
	        });
	    };

	    $scope.showRevokeModal = function() {
	        $.colorbox({
	            html : $compile($('#revoke-sso-credentials-modal').html())($scope),
	                onLoad: function() {
	                $('#cboxClose').remove();
	            }
	        });

	        $.colorbox.resize({width:"450px" , height:"230px"});
	    };

	    $scope.revoke = function() {
	        $.ajax({
	            url: getBaseUri()+'/developer-tools/revoke-sso-credentials.json',
	            contentType: 'application/json;charset=UTF-8',
	            type: 'POST',
	            success: function(){
	                $scope.$apply(function(){
	                    $scope.userCredentials = null;
	                    $scope.closeModal();
	                    $scope.showReg = true;
	                });
	            }
	        }).fail(function(error) {
	            // something bad is happening!
	            console.log("Error revoking SSO credentials");
	        });
	    };

	    $scope.showEditLayout = function() {
	        //Hide the testing tools if they are already added
	        for(var i = 0; i < $scope.userCredentials.redirectUris.length; i++) {
	            if($scope.googleUri == $scope.userCredentials.redirectUris[i].value.value) {
	                $scope.hideGoogleUri=true;
	            } else if($scope.runscopeUri == $scope.userCredentials.redirectUris[i].value.value) {
	                $scope.hideRunscopeUri=true;
	            }
	        }
	        $scope.editing = true;
	        $('.developer-tools .slidebox').slideDown();
	        $('.tab-container .collapsed').css('display', 'none');
	        $('.tab-container .expanded').css('display', 'inline').parent().css('background','#EBEBEB');
	    };

	    $scope.showViewLayout = function() {
	        //Reset the credentials
	        $scope.getSSOCredentials();
	        $scope.editing = false;
	        $scope.creating = false;
	        $('.edit-details .slidebox').slideDown();
	    };

	    $scope.editClientCredentials = function() {
	        $.ajax({
	            url: getBaseUri()+'/developer-tools/update-user-credentials.json',
	            contentType: 'application/json;charset=UTF-8',
	            type: 'POST',
	            dataType: 'json',
	            data: angular.toJson($scope.userCredentials),
	            success: function(data){
	                $scope.$apply(function(){
	                    $scope.playgroundExample = '';
	                    $scope.userCredentials = data;
	                    if(data.errors.length != 0){
	                        //SHOW ERROR
	                    } else {
	                        $scope.editing = false;
	                        $scope.hideGoogleUri = false;
	                        $scope.selectedRedirectUri = $scope.userCredentials.redirectUris[0];
	                        for(var i = 0; i < $scope.userCredentials.redirectUris.length; i++) {
	                            if($scope.googleUri == $scope.userCredentials.redirectUris[i].value.value) {
	                                $scope.hideGoogleUri = true;
	                            }

	                            if($scope.userCredentials.redirectUris[i].value.value < $scope.selectedRedirectUri.value.value) {
	                                $scope.selectedRedirectUri = $scope.userCredentials.redirectUris[i];
	                            }
	                        }

	                        $scope.updateSelectedRedirectUri();
	                        $scope.setHtmlTrustedNameAndDescription();
	                    }
	                });
	            }
	        }).fail(function(error) {
	            // something bad is happening!
	            console.log("Error updating SSO credentials");
	        });
	    };

	    $scope.deleteRedirectUri = function(idx) {
	        $scope.userCredentials.redirectUris.splice(idx, 1);
	        $scope.hideGoogleUri = false;
	        for(var i = 0; i < $scope.userCredentials.redirectUris.length; i++) {
	            if($scope.googleUri == $scope.userCredentials.redirectUris[i].value.value) {
	                $scope.hideGoogleUri = true;
	            }
	        }
	    };

	    $scope.addTestRedirectUri = function(type) {
	        var rUri = $scope.runscopeUri;
	        if(type == 'google'){
	            rUri = $scope.googleUri;
	        }

	        $.ajax({
	            url: getBaseUri() + '/developer-tools/get-empty-redirect-uri.json',
	            dataType: 'json',
	            success: function(data) {
	                data.value.value=rUri;
	                $scope.$apply(function(){
	                    if($scope.userCredentials.redirectUris.length == 1 && $scope.userCredentials.redirectUris[0].value.value == null) {
	                        $scope.userCredentials.redirectUris[0].value.value = rUri;
	                    } else {
	                        $scope.userCredentials.redirectUris.push(data);
	                    }
	                    if(type == 'google') {
	                        $scope.hideGoogleUri = true;
	                    }
	                });
	            }
	        }).fail(function() {
	            console.log("Error fetching empty redirect uri");
	        });
	    };

	    $scope.updateSelectedRedirectUri = function() {
	        var clientId = $scope.userCredentials.clientOrcid.value;
	        var selectedRedirectUriValue = $scope.selectedRedirectUri.value.value;
	        var selectedClientSecret = $scope.userCredentials.clientSecret.value;

	        //Build the google playground url example
	        $scope.playgroundExample = '';

	        if($scope.googleUri == selectedRedirectUriValue) {
	            var example = $scope.googleExampleLink;
	            example = example.replace('[BASE_URI_ENCODE]', encodeURI(getBaseUri()));
	            example = example.replace('[CLIENT_ID]', clientId);
	            example = example.replace('[CLIENT_SECRET]', selectedClientSecret);
	            $scope.playgroundExample = example;
	        }

	        var example = $scope.authorizeURLTemplate;
	        example = example.replace('BASE_URI]', orcidVar.baseUri);
	        example = example.replace('[CLIENT_ID]', clientId);
	        example = example.replace('[REDIRECT_URI]', selectedRedirectUriValue);
	        $scope.authorizeURL = example;

	        // rebuild sampel Auhtroization Curl
	        var sampeleCurl = $scope.sampleAuthCurlTemplate;
	        $scope.sampleAuthCurl = sampeleCurl.replace('[CLIENT_ID]', clientId)
	            .replace('[CLIENT_SECRET]', selectedClientSecret)
	            .replace('[BASE_URI]', orcidVar.baseUri)
	            .replace('[REDIRECT_URI]', selectedRedirectUriValue);
	    };

	    $scope.confirmResetClientSecret = function() {
	        $scope.clientSecretToReset = $scope.userCredentials.clientSecret;
	        $.colorbox({
	            html : $compile($('#reset-client-secret-modal').html())($scope),
	            transition: 'fade',
	            onLoad: function() {
	                $('#cboxClose').remove();
	            },
	            scrolling: true
	        });
	        $.colorbox.resize({width:"415px" , height:"250px"});
	    };

	    $scope.resetClientSecret = function() {     
	        $.ajax({
	            url: getBaseUri() + '/developer-tools/reset-client-secret.json',
	            type: 'POST',
	            data: $scope.userCredentials.clientOrcid.value,
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'text',
	            success: function(data) {
	                if(data) {
	                    $scope.editing = false;
	                    $scope.closeModal();
	                    $scope.getSSOCredentials();
	                } else
	                    console.log('Unable to reset client secret');
	            }
	        }).fail(function() {
	            console.log("Error resetting redirect uri");
	        });
	    };

	    $scope.closeModal = function(){
	        $.colorbox.close();
	    };

	    //init
	    $scope.getSSOCredentials();

	    $scope.setHtmlTrustedNameAndDescription = function() {
	        //Trust client name and description as html since it has been already filtered
	        $scope.nameToDisplay = $sce.trustAsHtml($scope.userCredentials.clientName.value);
	        $scope.descriptionToDisplay = $sce.trustAsHtml($scope.userCredentials.clientDescription.value);
	    };
	    
	    $scope.inputTextAreaSelectAll = function($event){
	        $event.target.select();
	    }
	    
	    $scope.expand =  function(){
	        $scope.expanded = true;
	    }
	    
	    $scope.collapse = function(){
	        $scope.expanded = false;
	    }
	    
	    $scope.getClientUrl = function(userCredentials) {
	        if(typeof userCredentials != undefined && userCredentials != null && userCredentials.clientWebsite != null && userCredentials.clientWebsite.value != null) {
	            if(userCredentials.clientWebsite.value.lastIndexOf('http://') === -1 && userCredentials.clientWebsite.value.lastIndexOf('https://') === -1) {
	                return '//' + userCredentials.clientWebsite.value;
	            } else {
	                return userCredentials.clientWebsite.value;
	            }
	        }
	        return '';
	    }
	    
	}]);

	angular.module('orcidApp').controller('ClientEditCtrl',['$scope', '$compile', function ($scope, $compile){
	    $scope.clients = [];
	    $scope.newClient = null;
	    $scope.scopeSelectorOpen = false;
	    $scope.selectedScopes = [];
	    $scope.availableRedirectScopes = [];
	    $scope.editing = false;
	    $scope.creating = false;
	    $scope.viewing = false;
	    $scope.listing = true;
	    $scope.hideGoogleUri = true;
	    $scope.selectedRedirectUri = "";
	    $scope.selectedScope = "";
	    // Google example
	    $scope.googleUri = 'https://developers.google.com/oauthplayground';
	    $scope.playgroundExample = '';
	    $scope.googleExampleLink = 'https://developers.google.com/oauthplayground/#step1&oauthEndpointSelect=Custom&oauthAuthEndpointValue=[BASE_URI_ENCODE]/oauth/authorize&oauthTokenEndpointValue=[BASE_URI_ENCODE]/oauth/token&oauthClientId=[CLIENT_ID]&oauthClientSecret=[CLIENT_SECRET]&accessTokenType=bearer&scope=[SCOPES]';
	    // Curl example
	    $scope.sampleAuthCurl = '';
	    $scope.sampleAuthCurlTemplate = "curl -i -L -k -H 'Accept: application/json' --data 'client_id=[CLIENT_ID]&client_secret=[CLIENT_SECRET]&grant_type=authorization_code&redirect_uri=[REDIRECT_URI]&code=REPLACE WITH OAUTH CODE' [BASE_URI]/oauth/token";
	    // Auth example
	    $scope.authorizeUrlBase = getBaseUri() + '/oauth/authorize';
	    $scope.authorizeURLTemplate = $scope.authorizeUrlBase + '?client_id=[CLIENT_ID]&response_type=code&redirect_uri=[REDIRECT_URI]&scope=[SCOPES]';
	    // Token url
	    $scope.tokenURL = orcidVar.pubBaseUri + '/oauth/token';
	    $scope.expanded = false;

	    // Get the list of clients associated with this user
	    $scope.getClients = function(){
	        $.ajax({
	            url: getBaseUri() + '/group/developer-tools/get-clients.json',
	            dataType: 'json',
	            success: function(data) {
	                $scope.$apply(function(){
	                    $scope.clients = data;
	                    $scope.creating = false;
	                    $scope.editing = false;
	                    $scope.viewing = false;
	                    $scope.listing = true;
	                    $scope.hideGoogleUri = false;
	                });
	            }
	        }).fail(function() {
	            alert("Error fetching clients.");
	            console.log("Error fetching clients.");
	        });
	    };

	    // Get an empty modal to add
	    $scope.showAddClient = function(){
	        $.ajax({
	            url: getBaseUri() + '/group/developer-tools/client.json',
	            dataType: 'json',
	            success: function(data) {
	                $scope.$apply(function() {
	                    $scope.newClient = data;
	                    $scope.creating = true;
	                    $scope.listing = false;
	                    $scope.editing = false;
	                    $scope.viewing = false;
	                    $scope.hideGoogleUri = false;
	                });
	            }
	        }).fail(function() {
	            console.log("Error fetching client");
	        });
	    };

	    // Add a new uri input field to a new client
	    $scope.addRedirectUriToNewClientTable = function(){
	        $scope.newClient.redirectUris.push({value: {value: ''},type: {value: 'default'}, scopes: [], errors: [], actType: {value: ""}, geoArea: {value: ""}});
	    };

	    // Add a new uri input field to a existing client
	    $scope.addUriToExistingClientTable = function(){
	        $scope.clientToEdit.redirectUris.push({value: {value: ''},type: {value: 'default'}, scopes: [], errors: [], actType: {value: ""}, geoArea: {value: ""}});
	    };

	    // Delete an uri input field
	    $scope.deleteUriOnNewClient = function(idx){
	        $scope.newClient.redirectUris.splice(idx, 1);
	        $scope.hideGoogleUri = false;
	        if($scope.newClient.redirectUris != null && $scope.newClient.redirectUris.length > 0) {
	            for(var i = 0; i < $scope.newClient.redirectUris.length; i++) {
	                if($scope.newClient.redirectUris[i].value.value == $scope.googleUri) {
	                    $scope.hideGoogleUri = true;
	                    break;
	                }
	            }
	        }
	    };

	    // Delete an uri input field
	    $scope.deleteUriOnExistingClient = function(idx){
	        $scope.clientToEdit.redirectUris.splice(idx, 1);
	        $scope.hideGoogleUri = false;
	        if($scope.clientToEdit.redirectUris != null && $scope.clientToEdit.redirectUris.length > 0) {
	            for(var i = 0; i < $scope.clientToEdit.redirectUris.length; i++) {
	                if($scope.clientToEdit.redirectUris[i].value.value == $scope.googleUri) {
	                    $scope.hideGoogleUri = true;
	                    break;
	                }
	            }
	        }
	    };

	    $scope.addTestRedirectUri = function(type, edit) {
	        var rUri = '';
	        if(type == 'google'){
	            rUri = $scope.googleUri;
	        }

	        $.ajax({
	            url: getBaseUri() + '/developer-tools/get-empty-redirect-uri.json',
	            dataType: 'json',
	            success: function(data) {
	                data.value.value=rUri;
	                data.type.value='default';
	                $scope.$apply(function(){
	                    if(edit == 'true'){
	                        if($scope.clientToEdit.redirectUris.length == 1 && $scope.clientToEdit.redirectUris[0].value.value == null) {
	                            $scope.clientToEdit.redirectUris[0].value.value = rUri;
	                        } else {
	                            $scope.clientToEdit.redirectUris.push(data);
	                        }
	                    } else {
	                        if($scope.newClient.redirectUris.length == 1 && $scope.newClient.redirectUris[0].value.value == null) {
	                            $scope.newClient.redirectUris[0].value.value = rUri;
	                        } else {
	                            $scope.newClient.redirectUris.push(data);
	                        }
	                    }
	                    if(type == 'google') {
	                        $scope.hideGoogleUri = true;
	                    }
	                });
	            }
	        }).fail(function() {
	            console.log("Error fetching empty redirect uri");
	        });
	    };

	    // Display the modal to edit a client
	    $scope.showEditClient = function(client) {
	        // Copy the client to edit to a scope variable
	        $scope.clientToEdit = client;
	        $scope.editing = true;
	        $scope.creating = false;
	        $scope.listing = false;
	        $scope.viewing = false;
	        $scope.hideGoogleUri = false;

	        if($scope.clientToEdit.redirectUris != null && $scope.clientToEdit.redirectUris.length > 0) {
	            for(var i = 0; i < $scope.clientToEdit.redirectUris.length; i++) {
	                if($scope.clientToEdit.redirectUris[i].value.value == $scope.googleUri) {
	                    $scope.hideGoogleUri = true;
	                    break;
	                }
	            }
	        }
	    };

	    //Submits the client update request
	    $scope.submitEditClient = function(){
	        // Check which redirect uris are empty strings and remove them from the array
	        for(var j = $scope.clientToEdit.length - 1; j >= 0 ; j--)    {
	            if(!$scope.clientToEdit.redirectUris[j].value){
	                $scope.clientToEdit.redirectUris.splice(j, 1);
	            }
	        }
	        //Submit the update request
	        $.ajax({
	            url: getBaseUri() + '/group/developer-tools/edit-client.json',
	            type: 'POST',
	            data: angular.toJson($scope.clientToEdit),
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                if(data.errors != null && data.errors.length > 0){
	                    $scope.clientToEdit = data;
	                    $scope.$apply();
	                } else {
	                    //If everything worked fine, reload the list of clients
	                    $scope.getClients();
	                    $.colorbox.close();
	                }
	            }
	        }).fail(function() {
	            alert("An error occured updating the client");
	            console.log("Error updating client information.");
	        });
	    };

	    //Submits the new client request
	    $scope.addClient = function(){
	        // Check which redirect uris are empty strings and remove them from the array
	        for(var j = $scope.newClient.redirectUris.length - 1; j >= 0 ; j--)    {
	            if(!$scope.newClient.redirectUris[j].value){
	                $scope.newClient.redirectUris.splice(j, 1);
	            } else {
	                $scope.newClient.redirectUris[j].actType.value = JSON.stringify({"import-works-wizard" : ["Articles"]});
	                $scope.newClient.redirectUris[j].geoArea.value = JSON.stringify({"import-works-wizard" : ["Global"]});
	            }
	        }

	        //Submit the new client request
	        $.ajax({
	            url: getBaseUri() + '/group/developer-tools/add-client.json',
	            type: 'POST',
	            data: angular.toJson($scope.newClient),
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                if(data.errors != null && data.errors.length > 0){
	                    $scope.newClient = data;
	                    $scope.$apply();
	                } else {
	                    //If everything worked fine, reload the list of clients
	                    $scope.getClients();
	                }
	            }
	        }).fail(function() {
	            console.log("Error creating client information.");
	        });
	    };

	    //Submits the updated client
	    $scope.editClient = function() {
	        // Check which redirect uris are empty strings and remove them from the array
	        for(var j = $scope.clientToEdit.redirectUris.length - 1; j >= 0 ; j--)    {
	            if(!$scope.clientToEdit.redirectUris[j].value){
	                $scope.clientToEdit.redirectUris.splice(j, 1);
	            } else if($scope.clientToEdit.redirectUris[j].actType.value == "") {
	                $scope.clientToEdit.redirectUris[j].actType.value = JSON.stringify({"import-works-wizard" : ["Articles"]});
	                $scope.clientToEdit.redirectUris[j].geoArea.value = JSON.stringify({"import-works-wizard" : ["Global"]});
	            }
	        }
	        //Submit the edited client
	        $.ajax({
	            url: getBaseUri() + '/group/developer-tools/edit-client.json',
	            type: 'POST',
	            data: angular.toJson($scope.clientToEdit),
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                if(data.errors != null && data.errors.length > 0){
	                    $scope.clientToEdit = data;
	                    $scope.$apply();
	                } else {
	                    //If everything worked fine, reload the list of clients
	                    $scope.getClients();
	                }
	            }
	        }).fail(function() {
	            console.log("Error editing client information.");
	        });
	    };

	    // Display client details: Client ID and Client secret
	    $scope.viewDetails = function(client) {
	        // Set the client details
	        $scope.clientDetails = client;
	        // Set the first redirect uri selected
	        if(client.redirectUris != null && client.redirectUris.length > 0) {
	            $scope.selectedRedirectUri = client.redirectUris[0];
	        } else {
	            $scope.selectedRedirectUri = null;
	        }

	        $scope.editing = false;
	        $scope.creating = false;
	        $scope.listing = false;
	        $scope.viewing = true;

	        // Update the selected redirect uri
	        if($scope.clientDetails != null){
	            $scope.updateSelectedRedirectUri();
	        }
	    };

	    $scope.updateSelectedRedirectUri = function() {
	        var clientId = '';
	        var selectedClientSecret = '';
	        $scope.playgroundExample = '';
	        var scope = $scope.selectedScope;

	        if ($scope.clientDetails != null){
	            clientId = $scope.clientDetails.clientId.value;
	            selectedClientSecret = $scope.clientDetails.clientSecret.value;
	        }

	        if($scope.selectedRedirectUri.length != 0) {
	            selectedRedirectUriValue = $scope.selectedRedirectUri.value.value;

	            if($scope.googleUri == selectedRedirectUriValue) {
	                var example = $scope.googleExampleLink;
	                example = example.replace('[BASE_URI_ENCODE]', encodeURI(getBaseUri()));
	                example = example.replace('[CLIENT_ID]', clientId);
	                example = example.replace('[CLIENT_SECRET]', selectedClientSecret);
	                if(scope != '')
	                    example = example.replace('[SCOPES]', scope);
	                $scope.playgroundExample = example.replace(/,/g,'%20');
	            }

	            var example = $scope.authorizeURLTemplate;
	            example = example.replace('[BASE_URI]', orcidVar.baseUri);
	            example = example.replace('[CLIENT_ID]', clientId);
	            example = example.replace('[REDIRECT_URI]', selectedRedirectUriValue);
	            if(scope != ''){
	                example = example.replace('[SCOPES]', scope);
	            }

	            $scope.authorizeURL = example.replace(/,/g,'%20');    //replacing ,

	            // rebuild sample Auhtroization Curl
	            var sampleCurl = $scope.sampleAuthCurlTemplate;
	            $scope.sampleAuthCurl = sampleCurl.replace('[CLIENT_ID]', clientId)
	                .replace('[CLIENT_SECRET]', selectedClientSecret)
	                .replace('[BASE_URI]', orcidVar.baseUri)
	                .replace('[REDIRECT_URI]', selectedRedirectUriValue);
	        }
	    };

	    $scope.showViewLayout = function() {
	        $scope.editing = false;
	        $scope.creating = false;
	        $scope.listing = true;
	        $scope.viewing = false;
	    };

	    //Load the list of scopes for client redirect uris
	    $scope.loadAvailableScopes = function(){
	        $.ajax({
	            url: getBaseUri() + '/group/developer-tools/get-available-scopes.json',
	            type: 'GET',
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                $scope.availableRedirectScopes = data;
	            }
	        }).fail(function() {
	            console.log("Unable to fetch redirect uri scopes.");
	        });
	    };


	    $scope.getAvailableRedirectScopes = function() {
	        var toRemove = '/authenticate';
	        var result = [];

	        result = jQuery.grep($scope.availableRedirectScopes, function(value) {
	          return value != toRemove;
	        });

	        return result;
	    };

	    //Load the default scopes based n the redirect uri type selected
	    $scope.loadDefaultScopes = function(rUri) {
	        //Empty the scopes to update the default ones
	        rUri.scopes = [];
	        //Fill the scopes with the default scopes
	        if(rUri.type.value == 'grant-read-wizard'){
	            rUri.scopes.push('/orcid-profile/read-limited');
	        } else if (rUri.type.value == 'import-works-wizard'){
	            rUri.scopes.push('/orcid-profile/read-limited');
	            rUri.scopes.push('/orcid-works/create');
	        } else if (rUri.type.value == 'import-funding-wizard'){
	            rUri.scopes.push('/orcid-profile/read-limited');
	            rUri.scopes.push('/funding/create');
	        }
	    };

	    //Mark an item as selected
	    $scope.setSelectedItem = function(rUri){
	        var scope = this.scope;
	        if (jQuery.inArray( scope, rUri.scopes ) == -1) {
	            rUri.scopes.push(scope);
	        } else {
	            rUri.scopes = jQuery.grep(rUri.scopes, function(value) {
	                return value != scope;
	              });
	        }
	        return false;
	    };

	    //Checks if an item is selected
	    $scope.isChecked = function (rUri) {
	        var scope = this.scope;
	        if (jQuery.inArray( scope, rUri.scopes ) != -1) {
	            return true;
	        }
	        return false;
	    };

	    // Checks if the scope checkbox should be disabled
	    $scope.isDisabled = function (rUri) {
	        if(rUri.type.value == 'grant-read-wizard')
	            return true;
	        return false;
	    };

	    //init
	    $scope.getClients();
	    $scope.loadAvailableScopes();

	    $scope.confirmResetClientSecret = function() {
	        $scope.resetThisClient = $scope.clientToEdit;
	        $.colorbox({
	            html : $compile($('#reset-client-secret-modal').html())($scope),
	            transition: 'fade',
	            onLoad: function() {
	                $('#cboxClose').remove();
	            },
	            scrolling: true
	        });
	        $.colorbox.resize({width:"415px" , height:"250px"});
	    };

	    $scope.resetClientSecret = function() {
	        $.ajax({
	            url: getBaseUri() + '/group/developer-tools/reset-client-secret.json',
	            type: 'POST',
	            data: $scope.resetThisClient.clientId.value,
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'text',
	            success: function(data) {
	                if(data) {
	                    $scope.editing = false;
	                    $scope.creating = false;
	                    $scope.listing = true;
	                    $scope.viewing = false;

	                    $scope.closeModal();
	                    $scope.getClients();
	                } else {
	                    console.log('Unable to reset client secret');
	                }
	            }
	        }).fail(function() {
	            console.log("Error resetting redirect uri");
	        });
	    };

	    $scope.closeModal = function(){
	        $.colorbox.close();
	    };
	    
	    $scope.inputTextAreaSelectAll = function($event){
	        $event.target.select();
	    }
	    
	    $scope.expand =  function(){
	        $scope.expanded = true;
	    }
	    
	    $scope.collapse = function(){
	        $scope.expanded = false;
	    }
	    
	    $scope.getClientUrl = function(client) {
	        if(client != null) {
	            if(client.website != null){
	                if(client.website.value != null) {
	                    if(client.website.value.lastIndexOf('http://') === -1 && client.website.value.lastIndexOf('https://') === -1) {
	                        return '//' + client.website.value;
	                    } else {
	                        return client.website.value;
	                    }
	                }
	            }
	        }
	        return '';
	    }
	    
	}]);

	angular.module('orcidApp').controller('CustomEmailCtrl',['$scope', '$compile',function ($scope, $compile) {
	    $scope.customEmail = null;
	    $scope.editedCustomEmail = null;
	    $scope.customEmailList = [];
	    $scope.showCreateButton = false;
	    $scope.showEmailList = false;
	    $scope.showCreateForm = false;
	    $scope.showEditForm = false;
	    $scope.clientId = null;
	    
	    $scope.init = function(client_id) {
	        $scope.clientId = client_id;
	        $scope.getCustomEmails();
	    };
	    
	    $scope.getCustomEmails = function() {
	        $.ajax({
	            url: getBaseUri() + '/group/custom-emails/get.json?clientId=' + $scope.clientId,
	            type: 'GET',
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                $scope.customEmailList = [];
	                $scope.showEmailList = false;
	                $scope.showCreateForm = false;
	                $scope.showEditForm = false;
	                $scope.customEmail = null;
	                $scope.editedCustomEmail = null;
	                if(data != null && data.length > 0){
	                    $scope.customEmailList = data;
	                    $scope.showCreateForm = false;
	                    $scope.showEditForm = false;
	                    $scope.showEmailList = true;
	                    $scope.showCreateButton = false;
	                }  else {
	                    $scope.showCreateButton = true;
	                }
	                $scope.$apply();
	            }
	        });
	    };

	    $scope.displayCreateForm = function() {
	        $.ajax({
	            url: getBaseUri() + '/group/custom-emails/get-empty.json?clientId=' + $scope.clientId,
	            type: 'GET',
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                if(data.errors == null || data.errors.length == 0){
	                    $scope.customEmail = data;
	                    $scope.showCreateForm = true;
	                    $scope.showEditForm = false;
	                    $scope.showCreateButton = false;
	                    $scope.showEmailList = false;
	                    $scope.$apply();
	                }
	            }
	        }).fail(function() {
	            console.log("Error getting empty custom email.");
	        });
	    };

	    $scope.saveCustomEmail = function() {
	        $.ajax({
	            url: getBaseUri() + '/group/custom-emails/create.json',
	            type: 'POST',
	            data: angular.toJson($scope.customEmail),
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                if(data.errors != null && data.errors.length > 0){
	                    $scope.customEmail = data;
	                    $scope.$apply();
	                } else {
	                    //If everything worked fine, reload the list of clients
	                    $scope.getCustomEmails();
	                }
	            }
	        }).fail(function() {
	            alert("An error occured creating the custom email");
	            console.log("An error occured creating the custom email.");
	        });
	    };

	    $scope.showEditLayout = function(index) {
	        $scope.showCreateForm = false;
	        $scope.showEditForm = true;
	        $scope.showCreateButton = false;
	        $scope.showEmailList = false;
	        $scope.editedCustomEmail = $scope.customEmailList[index];
	    };

	    $scope.editCustomEmail = function() {
	        $.ajax({
	            url: getBaseUri() + '/group/custom-emails/update.json',
	            type: 'POST',
	            data: angular.toJson($scope.editedCustomEmail),
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                if(data.errors != null && data.errors.length > 0){
	                    $scope.editedCustomEmail = data;
	                    $scope.$apply();
	                } else {
	                    //If everything worked fine, reload the list of clients
	                    $scope.getCustomEmails();
	                }
	            }
	        }).fail(function() {
	            alert("An error occured creating the custom email");
	            console.log("An error occured creating the custom email.");
	        });
	    };

	    $scope.showViewLayout = function() {
	        $scope.getCustomEmails();
	    };

	    $scope.confirmDeleteCustomEmail = function(index) {
	        $scope.toDelete = $scope.customEmailList[index];
	        $.colorbox({
	            html : $compile($('#delete-custom-email').html())($scope),
	            scrolling: true,
	            onLoad: function() {
	                $('#cboxClose').remove();
	            },
	            scrolling: true
	        });

	        $.colorbox.resize({width:"415px" , height:"175px"});
	    };

	    $scope.deleteCustomEmail = function(index) {
	        $.ajax({
	            url: getBaseUri() + '/group/custom-emails/delete.json',
	            type: 'POST',
	            data: angular.toJson($scope.toDelete),
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                if(data){
	                    //If everything worked fine, reload the list of clients
	                    $scope.getCustomEmails();
	                    $scope.closeModal();
	                } else {
	                    console.log("Error deleting custom email");
	                }
	            }
	        }).fail(function() {
	            alert("An error occured creating the custom email");
	            console.log("An error occured creating the custom email.");
	        });
	    };

	    $scope.closeModal = function(){
	        $.colorbox.close();
	    };
	}]);

	angular.module('orcidApp').controller('switchUserModalCtrl',['$scope','$compile',function ($scope,$compile){
	    $scope.emails = "";
	    $scope.orcidOrEmail = "";
	    $scope.showSection = false;

	    $scope.toggleSection = function(){
	        $scope.showSection = !$scope.showSection;
	        $('#switch_user_section').toggle();
	    };
	    
	    $scope.switchUserAdmin = function() {
	        $.ajax({
	            url: getBaseUri()+'/admin-actions/admin-switch-user?orcidOrEmail=' + $scope.orcidOrEmail,
	            type: 'GET',
	            dataType: 'json',
	            success: function(data){
	                $scope.$apply(function(){
	                    if(!$.isEmptyObject(data)) {
	                        if(!$.isEmptyObject(data.errorMessg)) {
	                            $scope.orcidMap = data;
	                            $scope.showSwitchErrorModal();
	                        } else {
	                            window.location.replace("./account/admin-switch-user?orcid\=" + data.orcid);
	                        }
	                    } else {
	                        $scope.showSwitchInvalidModal();
	                    }
	                    $scope.orcidOrEmail='';
	                });
	            }
	        }).fail(function(error) {
	            // something bad is happening!
	            console.log("Error deprecating the account");
	        });
	    };
	    
	    $scope.showSwitchInvalidModal = function() {
	    $.colorbox({
	        html : $compile($('#switch-imvalid-modal').html())($scope),
	            scrolling: false,
	            onLoad: function() {
	            $('#cboxClose').remove();
	        },
	        scrolling: false
	    });

	        setTimeout(function(){$.colorbox.resize({width:"575px"});},100);
	    };
	    
	    $scope.showSwitchErrorModal = function() {
	        $.colorbox({
	            html : $compile($('#switch-error-modal').html())($scope),
	                scrolling: false,
	                onLoad: function() {
	                $('#cboxClose').remove();
	            },
	            scrolling: false
	        });

	        setTimeout(function(){$.colorbox.resize({width:"575px"});},100);
	    };

	    $scope.closeModal = function() {
	        $.colorbox.close();
	    };

	}]);

	angular.module('orcidApp').controller('SocialNetworksCtrl',['$scope',function ($scope){
	    $scope.twitter=false;

	    $scope.checkTwitterStatus = function(){
	        $.ajax({
	            url: getBaseUri() + '/manage/twitter/check-twitter-status',
	            type: 'GET',
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'text',
	            success: function(data) {
	                if(data == "true")
	                    $scope.twitter = true;
	                else
	                    $scope.twitter = false;
	                $scope.$apply();
	            }
	        }).fail(function(){
	            console.log("Unable to fetch user twitter status");
	        });
	    };

	    $scope.updateTwitter = function() {
	        if($scope.twitter == true) {
	            $.ajax({
	                url: getBaseUri() + '/manage/twitter',
	                type: 'POST',
	                contentType: 'application/json;charset=UTF-8',
	                dataType: 'text',
	                success: function(data) {
	                    window.location = data;
	                }
	            }).fail(function() {
	                console.log("Unable to enable twitter");
	            });
	        } else {
	            $.ajax({
	                url: getBaseUri() + '/manage/disable-twitter',
	                type: 'POST',
	                contentType: 'application/json;charset=UTF-8',
	                dataType: 'text',
	                success: function(data) {
	                    if(data == "true"){
	                        $scope.twitter = false;
	                    } else {
	                        $scope.twitter = true;
	                    }

	                    $scope.$apply();
	                }
	            }).fail(function() {
	                console.log("Unable to disable twitter");
	            });
	        }
	    };

	    //init
	    $scope.checkTwitterStatus();
	}]);

	angular.module('orcidApp').controller('adminDelegatesCtrl',['$scope',function ($scope){
	    $scope.showSection = false;
	    $scope.managed_verified = false;
	    $scope.trusted_verified = false;
	    $scope.success = false;
	    $scope.request = {trusted : {errors: [], value: ''}, managed : {errors: [], value: ''}};

	    $scope.toggleSection = function(){
	        $scope.showSection = !$scope.showSection;
	        $('#delegates_section').toggle();
	    };

	    $scope.checkClaimedStatus = function (whichField){
	        var orcidOrEmail = '';
	        if(whichField == 'trusted') {
	            $scope.trusted_verified = false;
	            orcidOrEmail = $scope.request.trusted.value;
	        } else {
	            $scope.managed_verified = false;
	            orcidOrEmail = $scope.request.managed.value;
	        }

	        $.ajax({
	            url: getBaseUri()+'/admin-actions/admin-delegates/check-claimed-status.json?orcidOrEmail=' + orcidOrEmail,
	            type: 'GET',
	            dataType: 'json',
	            success: function(data){
	                    if(data) {
	                        if(whichField == 'trusted') {
	                            $scope.trusted_verified = true;
	                        } else {
	                            $scope.managed_verified = true;
	                        }
	                        $scope.$apply();
	                    }
	                }
	            }).fail(function(error) {
	                // something bad is happening!
	                console.log("Error getting account details for: " + orcid);
	            });
	    };

	    $scope.confirmDelegatesProcess = function() {
	        $scope.success = false;
	        $.ajax({
	            url: getBaseUri()+'/admin-actions/admin-delegates',
	            type: 'POST',
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            data: angular.toJson($scope.request),
	            success: function(data){
	                    $scope.request = data;
	                    if(data.successMessage) {
	                        $scope.success = true;
	                    }
	                    $scope.$apply();
	                }
	            }).fail(function(error) {
	                // something bad is happening!
	                console.log("Error getting delegates request");
	            });
	    };
	}]);

	angular.module('orcidApp').controller('OauthAuthorizationController',['$scope', '$compile', '$sce', 'commonSrvc', 'vcRecaptchaService', function ($scope, $compile, $sce, commonSrvc, vcRecaptchaService){
	    $scope.showClientDescription = false;
	    $scope.showRegisterForm = true;
	    $scope.isOrcidPresent = false;
	    $scope.authorizationForm = {};
	    $scope.registrationForm = {};
	    $scope.emailTrustAsHtmlErrors = [];
	    $scope.enablePersistentToken = true;
	    $scope.allowEmailAccess = true;
	    $scope.showLongDescription = {};
	    $scope.recaptchaWidgetId = null;
	    $scope.recatchaResponse = null;
	    $scope.personalLogin = true;
	    $scope.scriptsInjected = false;
	    $scope.counter = 0;
	    $scope.requestInfoForm = null;    
	    $scope.showBulletIcon = false;
	    $scope.showCreateIcon = false;
	    $scope.showLimitedIcon = false;    
	    $scope.showUpdateIcon = false;    
	    $scope.gaString = null;
	    $scope.showDeactivatedError = false;
	    $scope.showReactivationSent = false;
	    
	    $scope.model = {
	        key: orcidVar.recaptchaKey
	    };
	    
	    $scope.toggleClientDescription = function() {
	        $scope.showClientDescription = !$scope.showClientDescription;
	    };
	    
	    $scope.loadRequestInfoForm = function() {
	        $.ajax({
	            url: getBaseUri() + '/oauth/custom/authorize/get_request_info_form.json',
	            type: 'GET',
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                angular.forEach(data.scopes, function (scope) {
	                    if (scope.value == "/email/read-private") {
	                        $scope.emailRequested = true;
	                    } else if(scope.value.endsWith('/create')) {
	                        $scope.showCreateIcon = true;
	                    } else if(scope.value.endsWith('/update')) {
	                        $scope.showUpdateIcon = true;
	                    } else if(scope.value.endsWith('/read-limited')) {
	                        $scope.showLimitedIcon = true;
	                    } else {
	                        $scope.showBulletIcon = true;
	                    }
	                })
	                                                                                                        
	                $scope.requestInfoForm = data;              
	                $scope.gaString = orcidGA.buildClientString($scope.requestInfoForm.memberName, $scope.requestInfoForm.clientName);              
	                $scope.$apply();
	            }
	        }).fail(function() {
	            console.log("An error occured initializing the form.");
	        });
	    };         
	    
	    //---------------------
	    //-LOGIN AND AUTHORIZE-
	    //---------------------
	    $scope.loadAndInitLoginForm = function() {
	        $scope.isOrcidPresent = false;
	        $.ajax({
	            url: getBaseUri() + '/oauth/custom/authorize/empty.json',
	            type: 'GET',
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                $scope.authorizationForm = data;                                
	                if($scope.authorizationForm.userName.value) {
	                    $scope.isOrcidPresent = true;
	                    $scope.showRegisterForm = false;                    
	                }
	                // #show_login - legacy fragment id, we should remove this sometime
	                // after November 2014 and only support &show_login=true
	                if(window.location.href.endsWith('#show_login'))
	                    $scope.showRegisterForm = false;
	                else if(!$scope.isOrcidPresent)
	                    $scope.showRegisterForm = !orcidVar.showLogin;                
	                
	                $scope.$apply();
	            }
	        }).fail(function() {
	            console.log("An error occured initializing the form.");
	        });
	    };

	    $scope.loginAndAuthorize = function() {
	        $scope.authorizationForm.approved = true;
	        //Fire GA sign-in-submit
	        orcidGA.gaPush(['send', 'event', 'RegGrowth', 'Sign-In-Submit' , 'OAuth ' + $scope.gaString]);
	        $scope.submitLogin();
	    };
	    
	    $scope.loginSocial = function(idp) {
	        orcidGA.gaPush(['send', 'event', 'RegGrowth', 'Sign-In-Submit' , 'OAuth ' + $scope.gaString]);
	        orcidGA.gaPush(['send', 'event', 'RegGrowth', 'Sign-In-Submit-Social', idp ]);
	        return false;
	    };

	    $scope.loginAndDeny = function() {
	        $scope.authorizationForm.approved = false;
	        $scope.submitLogin();
	    };

	    $scope.submitLogin = function() {
	        var auth_scope_prefix = 'Authorize_';
	        if($scope.enablePersistentToken) {
	            $scope.authorizationForm.persistentTokenEnabled=true;
	            auth_scope_prefix = 'AuthorizeP_';
	        }        
	        if($scope.allowEmailAccess) {
	            $scope.authorizationForm.emailAccessAllowed = true;
	        }
	        console.log(angular.toJson($scope.authorizationForm));
	        $.ajax({
	            url: getBaseUri() + '/oauth/custom/login.json',
	            type: 'POST',
	            data: angular.toJson($scope.authorizationForm),
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                if(data) {
	                    if(data.errors.length != 0) {
	                        $scope.authorizationForm = data;
	                        $scope.showDeactivatedError = ($.inArray('orcid.frontend.security.orcid_deactivated', $scope.authorizationForm.errors) != -1);
	                        $scope.showReactivationSent = false;
	                        $scope.$apply();
	                    } else {
	                        //Fire google GA event
	                        if($scope.authorizationForm.approved) {
	                            orcidGA.gaPush(['send', 'event', 'RegGrowth', 'Sign-In' , 'OAuth ' + $scope.gaString]);
	                            for(var i = 0; i < $scope.requestInfoForm.scopes.length; i++) {
	                                orcidGA.gaPush(['send', 'event', 'RegGrowth', auth_scope_prefix + $scope.requestInfoForm.scopes[i].name, 'OAuth ' + $scope.gaString]);
	                            }
	                        } else {
	                            //Fire GA authorize-deny
	                            orcidGA.gaPush(['send', 'event', 'Disengagement', 'Authorize_Deny', 'OAuth ' + $scope.gaString]);
	                        }
	                        orcidGA.windowLocationHrefDelay(data.redirectUrl);
	                    }
	                } else {
	                    console.log("Error authenticating the user");
	                }

	            }
	        }).fail(function() {
	            console.log("An error occured authenticating the user.");
	        });
	    };

	    //------------------------
	    //-REGISTER AND AUTHORIZE-
	    //------------------------
	    $scope.loadAndInitRegistrationForm = function() {
	        $.ajax({
	            url: getBaseUri() + '/oauth/custom/register/empty.json',
	            type: 'GET',
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                $scope.registrationForm = data;                            
	                if($scope.registrationForm.email.value && !$scope.isOrcidPresent)
	                    $scope.showRegisterForm = true;
	                $scope.$apply();
	                                
	                // special handling of deactivation error
	                $scope.$watch('registrationForm.email.errors', function(newValue, oldValue) {
	                    $scope.showDeactivatedError = ($.inArray('orcid.frontend.verify.deactivated_email', $scope.registrationForm.email.errors) != -1);
	                    $scope.showReactivationSent = false;
	                }); // initialize the watch                     
	            }
	        }).fail(function() {
	            console.log("An error occured initializing the registration form.");
	        });
	    };

	    $scope.registerAndAuthorize = function() {
	        $scope.registrationForm.approved = true;
	        orcidGA.gaPush(['send', 'event', 'RegGrowth', 'New-Registration-Submit' , 'OAuth ' + $scope.gaString]);
	        $scope.register();
	    };

	    $scope.registerAndDeny = function() {
	        $scope.registrationForm.approved = false;
	        $scope.register();
	    };

	    $scope.sendReactivationEmail = function (email) {
	        $scope.showDeactivatedError = false;
	        $scope.showReactivationSent = true;
	        $.ajax({
	            url: getBaseUri() + '/sendReactivation.json',
	            type: "POST",
	            data: { email: email },
	            dataType: 'json',
	        }).fail(function(){
	        // something bad is happening!
	            console.log("error sending reactivation email");
	        });
	    };
	    
	    $scope.register = function() {
	        if($scope.enablePersistentToken) {
	            $scope.registrationForm.persistentTokenEnabled=true;
	        }
	    
	        if ($scope.allowEmailAccess) {
	            $scope.registrationForm.allowEmailAccess = true;
	        }
	        
	        $scope.registrationForm.grecaptcha.value = $scope.recatchaResponse; //Adding the response to the register object
	        $scope.registrationForm.grecaptchaWidgetId.value = $scope.recaptchaWidgetId;
	        
	        $.ajax({
	            url: getBaseUri() + '/oauth/custom/register.json',
	            type: 'POST',
	            data:  angular.toJson($scope.registrationForm),
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                $scope.registrationForm = data;
	                if($scope.registrationForm.approved) {
	                    if ($scope.registrationForm.errors == undefined || $scope.registrationForm.errors.length == 0) {
	                        $scope.showProcessingColorBox();
	                        $scope.getDuplicates();
	                    } else {
	                        if($scope.registrationForm.email.errors.length > 0) {
	                            for(var i = 0; i < $scope.registrationForm.email.errors.length; i++){
	                                $scope.emailTrustAsHtmlErrors[0] = $sce.trustAsHtml($scope.registrationForm.email.errors[i]);
	                            }
	                        } else {
	                            $scope.emailTrustAsHtmlErrors = [];
	                        }
	                    }
	                } else {
	                    //Fire GA register deny
	                    orcidGA.gaPush(['send', 'event', 'Disengagement', 'Authorize_Deny', 'OAuth ' + $scope.gaString]);                    
	                    orcidGA.windowLocationHrefDelay($scope.registrationForm.redirectUrl);
	                }

	                $scope.$apply();
	            }
	        }).fail(function() {
	            // something bad is happening!
	            console.log("RegistrationCtrl.postRegister() error");
	        });
	    };

	    $scope.getDuplicates = function(){
	        $.ajax({
	            url: getBaseUri() + '/dupicateResearcher.json?familyNames=' + $scope.registrationForm.familyNames.value + '&givenNames=' + $scope.registrationForm.givenNames.value,
	            dataType: 'json',
	            success: function(data) {
	                   $scope.duplicates = data;
	                $scope.$apply();
	                if ($scope.duplicates.length > 0 ) {
	                    $scope.showDuplicatesColorBox();
	                } else {
	                    $scope.postRegisterConfirm();
	                }
	            }
	        }).fail(function(){
	            // something bad is happening!
	            console.log("error fetching dupicateResearcher.json");
	            // continue to registration, as solr dup lookup failed.
	            $scope.postRegisterConfirm();
	        });
	    };

	    $scope.showDuplicatesColorBox = function () {
	        $.colorbox({
	            html : $compile($('#duplicates').html())($scope),
	            escKey:false,
	            overlayClose:false,
	            transition: 'fade',
	            close: '',
	            scrolling: true
	                    });
	        $scope.$apply();
	        $.colorbox.resize({width:"780px" , height:"400px"});
	    };

	    $scope.postRegisterConfirm = function () {
	        var auth_scope_prefix = 'Authorize_';
	        if($scope.enablePersistentToken)
	            auth_scope_prefix = 'AuthorizeP_';
	        $scope.showProcessingColorBox();
	        
	        $.ajax({
	            url: getBaseUri() + '/oauth/custom/registerConfirm.json',
	            type: 'POST',
	            data:  angular.toJson($scope.registrationForm),
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                $scope.requestInfoForm = data;
	                if($scope.requestInfoForm.errors.length > 0) {                                  
	                    $scope.generalRegistrationError = $scope.requestInfoForm.errors[0];
	                    console.log($scope.generalRegistrationError);
	                    $scope.$apply();
	                    $.colorbox.close();
	                } else {
	                    orcidGA.gaPush(['send', 'event', 'RegGrowth', 'New-Registration', 'OAuth '+ $scope.gaString]);
	                    if($scope.registrationForm.approved) {
	                        for(var i = 0; i < $scope.requestInfoForm.scopes.length; i++) {
	                            orcidGA.gaPush(['send', 'event', 'RegGrowth', auth_scope_prefix + $scope.requestInfoForm.scopes[i].name, 'OAuth ' + $scope.gaString]);
	                        }
	                    } else {
	                        //Fire GA register deny
	                        orcidGA.gaPush(['send', 'event', 'Disengagement', 'Authorize_Deny', 'OAuth ' + $scope.gaString]);
	                    }
	                    orcidGA.windowLocationHrefDelay($scope.requestInfoForm.redirectUrl);
	                }                               
	            }
	        }).fail(function() {
	            // something bad is happening!
	            console.log("OauthAuthorizationController.postRegister() error");
	        });
	    };

	    $scope.serverValidate = function (field) {
	        if (field === undefined) field = '';
	        $.ajax({
	            url: getBaseUri() + '/oauth/custom/register/validate' + field + '.json',
	            type: 'POST',
	            data:  angular.toJson($scope.registrationForm),
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                commonSrvc.copyErrorsLeft($scope.registrationForm, data);
	                if(field == 'Email') {
	                    if ($scope.registrationForm.email.errors.length > 0) {
	                        for(var i = 0; i < $scope.registrationForm.email.errors.length; i++){
	                            $scope.emailTrustAsHtmlErrors[0] = $sce.trustAsHtml($scope.registrationForm.email.errors[i]);
	                        }
	                    } else {
	                        $scope.emailTrustAsHtmlErrors = [];
	                    }
	                }
	                $scope.$apply();
	            }
	        }).fail(function() {
	            // something bad is happening!
	            console.log("OauthAuthorizationController.serverValidate() error");
	        });
	    };

	    $scope.updateActivitiesVisibilityDefault = function(priv, $event) {
	        $scope.registrationForm.activitiesVisibilityDefault.visibility = priv;
	    };

	    //------------------------
	    //------ AUTHORIZE -------
	    //------------------------
	    $scope.loadAndInitAuthorizationForm = function() {
	        $.ajax({
	            url: getBaseUri() + '/oauth/custom/authorize/empty.json',
	            type: 'GET',
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                $scope.authorizationForm = data;
	            }
	        }).fail(function() {
	            console.log("An error occured initializing the form.");
	        });
	    };

	    $scope.authorize = function() {
	        $scope.authorizationForm.approved = true;
	        $scope.authorizeRequest();
	    };

	    $scope.deny = function() {
	        $scope.authorizationForm.approved = false;
	        orcidGA.gaPush(['send', 'event', 'Disengagement', 'Authorize_Deny', 'OAuth ' + $scope.gaString]);
	        $scope.authorizeRequest();
	    };

	    $scope.authorizeRequest = function() {
	        var auth_scope_prefix = 'Authorize_';
	        if($scope.enablePersistentToken) {
	            $scope.authorizationForm.persistentTokenEnabled=true;
	            auth_scope_prefix = 'AuthorizeP_';
	        }
	        if($scope.allowEmailAccess) {
	            $scope.authorizationForm.emailAccessAllowed = true;
	        }
	        var is_authorize = $scope.authorizationForm.approved;
	        $.ajax({
	            url: getBaseUri() + '/oauth/custom/authorize.json',
	            type: 'POST',
	            data: angular.toJson($scope.authorizationForm),
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                if(is_authorize) {
	                    for(var i = 0; i < $scope.requestInfoForm.scopes.length; i++) {
	                        orcidGA.gaPush(['send', 'event', 'RegGrowth', auth_scope_prefix + $scope.requestInfoForm.scopes[i].name, 'OAuth ' + $scope.gaString]);
	                    }
	                }
	                orcidGA.windowLocationHrefDelay(data.redirectUrl);
	            }
	        }).fail(function() {
	            console.log("An error occured authorizing the user.");
	        });
	    };

	    //------------------
	    //------COMMON------
	    //------------------
	    $scope.switchForm = function() {
	        $scope.showRegisterForm = !$scope.showRegisterForm;
	        if (!$scope.personalLogin) 
	            $scope.personalLogin = true;
	    };

	    $scope.showProcessingColorBox = function () {
	        $.colorbox({
	            html : $('<div style="font-size: 50px; line-height: 60px; padding: 20px; text-align:center">' + om.get('common.processing') + '&nbsp;<i id="ajax-loader" class="glyphicon glyphicon-refresh spin green"></i></div>'),
	            width: '400px',
	            height:"100px",
	            close: '',
	            escKey:false,
	            overlayClose:false,
	            onComplete: function() {
	                $.colorbox.resize({width:"400px" , height:"100px"});
	            }
	        });
	    };

	    $scope.showToLoginForm = function() {
	        $scope.authorizationForm.userName.value=$scope.registrationForm.email.value;
	        $scope.showRegisterForm = false;
	    };

	    $scope.toggleLongDescription = function(orcid_scope) {              
	        $scope.showLongDescription[orcid_scope] = !$scope.showLongDescription[orcid_scope];
	    };

	    document.onkeydown = function(e) {
	        e = e || window.event;
	        if (e.keyCode == 13) {          
	            if ( typeof location.search.split('client_id=')[1] == 'undefined' ){ //There is no clientID information             
	                if ($scope.showRegisterForm == true){
	                    $scope.registerAndAuthorize();                  
	                } else{
	                    $scope.loginAndAuthorize();                 
	                }               
	            } else{
	                $scope.authorize();
	            }
	        }
	    };
	    
	    //---------------------
	    //------Recaptcha------
	    //---------------------   
	    $scope.setRecaptchaWidgetId = function (widgetId) {
	        $scope.recaptchaWidgetId = widgetId;        
	    };

	    $scope.setRecatchaResponse = function (response) {
	        $scope.recatchaResponse = response;        
	    };
	    
	    //------------------------
	    //------OAuth Layout------
	    //------------------------
	    $scope.showPersonalLogin = function () {        
	        $scope.personalLogin = true;
	    };
	    
	    $scope.showInstitutionLogin = function () {
	        $scope.personalLogin = false; //Hide Personal Login
	        
	        if(!$scope.scriptsInjected){ //If shibboleth scripts haven't been loaded yet.            
	            $scope.addScript('/static/javascript/shibboleth-embedded-ds/1.1.0/idpselect_config.js', function(){
	                $scope.addScript('/static/javascript/shibboleth-embedded-ds/1.1.0/idpselect.js', function(){
	                    $scope.scriptsInjected = true;
	                    $scope.$apply();
	                    addShibbolethGa($scope.gaString);
	                });
	            });
	        };
	    };
	    
	    $scope.addScript = function(url, onLoadFunction){        
	        var head = document.getElementsByTagName('head')[0];
	        var script = document.createElement('script');
	        script.src = getBaseUri() + url + '?v=' + orcidVar.version;
	        script.onload =  onLoadFunction;
	        head.appendChild(script); //Inject the script
	    };
	    
	    //Init
	    $scope.loadRequestInfoForm();    
	    
	}]);

	angular.module('orcidApp').controller('LoginLayoutController',['$scope', function ($scope){
	    
	    $scope.personalLogin = true; //Flag to show or not Personal or Institution Account Login
	    $scope.scriptsInjected = false; //Flag to show or not the spinner
	    $scope.counter = 0; //To hide the spinner when the second script has been loaded, not the first one.
	    $scope.showDeactivatedError = false;
	    $scope.showReactivationSent = false;
	    
	    $scope.showPersonalLogin = function () {        
	        $scope.personalLogin = true;        
	    };
	    
	    $scope.showInstitutionLogin = function () {
	        $scope.personalLogin = false; //Hide Personal Login
	        
	        if(!$scope.scriptsInjected){ //If shibboleth scripts haven't been loaded yet.            
	            $scope.addScript('/static/javascript/shibboleth-embedded-ds/1.1.0/idpselect_config.js', function(){
	                $scope.addScript('/static/javascript/shibboleth-embedded-ds/1.1.0/idpselect.js', function(){
	                    $scope.scriptsInjected = true;
	                    $scope.$apply();
	                    addShibbolethGa($scope.gaString);
	                });
	            });
	        };
	    };
	    
	    $scope.addScript = function(url, onLoadFunction){        
	        var head = document.getElementsByTagName('head')[0];
	        var script = document.createElement('script');
	        script.src = getBaseUri() + url + '?v=' + orcidVar.version;
	        script.onload =  onLoadFunction;
	        head.appendChild(script); //Inject the script
	    };
	    
	    $scope.loginSocial = function(idp) {
	        orcidGA.gaPush(['send', 'event', 'RegGrowth', 'Sign-In-Submit-Social', idp]);
	        return false;
	    };
	    
	    $scope.showDeactivationError = function() {
	        $scope.showDeactivatedError = true;
	        $scope.showReactivationSent = false;
	        $scope.$apply();
	    };

	    $scope.sendReactivationEmail = function () {
	       $scope.showDeactivatedError = false;
	       $scope.showReactivationSent = true;
	       $.ajax({
	           url: getBaseUri() + '/sendReactivation.json',
	           type: "POST",
	           data: { email: $('#userId').val() },
	           dataType: 'json',
	       }).fail(function(){
	       // something bad is happening!
	           console.log("error sending reactivation email");
	       });
	   };
	    
	}]);

	angular.module('orcidApp').controller('LinkAccountController',['$scope', 'discoSrvc', function ($scope, discoSrvc){
	    
	    $scope.loadedFeed = false;
	    
	    $scope.linkAccount = function(idp, linkType) {
	        var eventAction = linkType === 'shibboleth' ? 'Sign-In-Link-Federated' : 'Sign-In-Link-Social';
	        orcidGA.gaPush(['send', 'event', 'Sign-In-Link', eventAction, idp]);
	        return false;
	    };
	    
	    $scope.setEntityId = function(entityId) {
	        $scope.entityId = entityId;
	    }
	    
	    $scope.$watch(function() { return discoSrvc.feed; }, function(){
	        $scope.idpName = discoSrvc.getIdPName($scope.entityId);
	        if(discoSrvc.feed != null) {
	            $scope.loadedFeed = true;
	        }
	    });
	    
	}]);

	angular.module('orcidApp').controller('MembersListController',['$scope', '$sce', 'membersListSrvc', 'clearMemberListFilterSrvc', function ($scope, $sce, membersListSrvc, clearMemberListFilterSrvc){
	    $scope.membersListSrvc = membersListSrvc;
	    $scope.displayMoreDetails = {};
	    
	    $scope.toggleDisplayMoreDetails = function(memberId, consortiumLeadId){
	        membersListSrvc.getDetails(memberId, consortiumLeadId);
	        $scope.displayMoreDetails[memberId] = !$scope.displayMoreDetails[memberId];
	    }
	    
	    //render html from salesforce data
	    $scope.renderHtml = function (htmlCode) {
	        return $sce.trustAsHtml(htmlCode);
	    };
	    
	    //create alphabetical list for filter
	    var alphaStr = "abcdefghijklmnopqrstuvwxyz";
	    $scope.alphabet = alphaStr.toUpperCase().split("");
	    $scope.activeLetter = '';
	    $scope.activateLetter = function(letter) {
	      $scope.activeLetter = letter
	    };
	    
	    //clear filters 
	    $scope.clearFilters = function(){
	        return clearMemberListFilterSrvc.clearFilters($scope);
	    }
	        
	    // populate the members feed
	    membersListSrvc.getMembersList();
	    
	}]);

	angular.module('orcidApp').controller('MemberPageController',['$scope', '$sce', 'membersListSrvc', function ($scope, $sce, membersListSrvc){
	    $scope.membersListSrvc = membersListSrvc;
	    
	    $scope.renderHtml = function (htmlCode) {
	        return $sce.trustAsHtml(htmlCode);
	    };
	    
	}]);

	angular.module('orcidApp').controller('ConsortiaListController',['$scope', '$sce', 'membersListSrvc', 'clearMemberListFilterSrvc', function ($scope, $sce, membersListSrvc, clearMemberListFilterSrvc){
	    $scope.membersListSrvc = membersListSrvc;
	    $scope.displayMoreDetails = {};
	    
	    $scope.toggleDisplayMoreDetails = function(memberId, consortiumLeadId){
	        membersListSrvc.getDetails(memberId, consortiumLeadId);
	        $scope.displayMoreDetails[memberId] = !$scope.displayMoreDetails[memberId];
	    }
	    
	    //render html from salesforce data
	    $scope.renderHtml = function (htmlCode) {
	        return $sce.trustAsHtml(htmlCode);
	    };
	    
	    //create alphabetical list for filter
	    var alphaStr = "abcdefghijklmnopqrstuvwxyz";
	    $scope.alphabet = alphaStr.toUpperCase().split("");
	    $scope.activeLetter = '';
	    $scope.activateLetter = function(letter) {
	      $scope.activeLetter = letter
	    };
	    
	    //clear filters
	    $scope.clearFilters = function(){
	        return clearMemberListFilterSrvc.clearFilters($scope);
	    }
	        
	    // populate the consortia feed
	    membersListSrvc.getConsortiaList();    
	    
	}]);

	angular.module('orcidApp').controller('EmailsCtrl',['$scope', 'emailSrvc', '$compile','prefsSrvc' ,function ($scope, emailSrvc, $compile, prefsSrvc){    
	    $scope.emailSrvc = emailSrvc;
	    $scope.showEdit = false;
	    $scope.showElement = {};

	    emailSrvc.getEmails();
	    
	    $scope.openEdit = function(){
	        $scope.showEdit = true;
	    }
	    
	    $scope.close = function(){      
	        $scope.showEdit = false;
	        prefsSrvc.saved = false;
	        $.colorbox.close();
	    }
	    
	    $scope.openEditModal = function(){
	        
	        var HTML = '<div class="lightbox-container" style="position: static">\
	                        <div class="edit-record edit-record-emails" style="position: static">\
	                            <div class="row">\
	                                <div class="col-md-12 col-sm-12 col-xs-12">\
	                                        <h1 class="lightbox-title pull-left">'+ om.get("manage.edit.emails") +'</h1>\
	                                </div>\
	                            </div>\
	                            <div class="row">\
	                                <div class="col-md-12 col-xs-12 col-sm-12" style="position: static">\
	                                    <table class="settings-table" style="position: static">\
	                                        <tr>' +
	                                            $('#edit-emails').html()
	                                      +'</tr>\
	                                    </table>\
	                                </div>\
	                            </div>\
	                            <div class="row">\
	                                <div class="col-md-12 col-sm-12 col-xs-12">\
	                                    <a ng-click="close()" class="cancel-option pull-right">'+om.get("manage.email.close")+'</a>\
	                                </div>\
	                            </div>\
	                        </div>\
	                    </div>';  
	        
	        $scope.emailSrvc.popUp = true;
	        
	        $.colorbox({
	            scrolling: true,
	            html: $compile(HTML)($scope),
	            onLoad: function() {                
	                $('#cboxClose').remove();
	            },
	            width: formColorBoxResize(),
	            onComplete: function() {
	                $.colorbox.resize();
	            },
	            onClosed: function() {
	                $scope.emailSrvc.popUp = false;        
	            }            
	        });
	    }
	    
	}]);

	angular.module('orcidApp').controller('headerCtrl',['$scope', '$window', function ($scope, $window){ 
	    
	    $scope.searchFilterChanged = false;
	    $scope.filterActive = false;
	    $scope.conditionsActive = false;
	    $scope.menuVisible = false;
	    $scope.secondaryMenuVisible = {};
	    $scope.tertiaryMenuVisible = {};
	    $scope.searchVisible = false;
	    $scope.settingsVisible = false;
	    
	    $scope.searchFocus = function(){
	        $scope.filterActive = true;
	        $scope.conditionsActive = true;
	    }
	    
	    $scope.searchBlur = function(){     
	        $scope.hideSearchFilter();
	        $scope.conditionsActive = false;        
	    }
	    
	    $scope.filterChange = function(){
	        $scope.searchFilterChanged = true;
	    }
	    
	    $scope.hideSearchFilter = function(){
	        var searchInputValue = document.getElementById("search-input").value;
	        if (searchInputValue === ""){
	            setTimeout(function() {
	                if ($scope.searchFilterChanged === false) {
	                    $scope.filterActive = false;
	                }
	            }, 3000);
	        }
	    }
	    
	    
	    $scope.toggleMenu = function(){
	        $scope.menuVisible = !$scope.menuVisible;
	        $scope.searchVisible = false;
	        $scope.settingsVisible = false;     
	    }
	    
	    $scope.toggleSecondaryMenu = function(submenu){
	        $scope.secondaryMenuVisible[submenu] = !$scope.secondaryMenuVisible[submenu];
	    }
	    
	    $scope.toggleTertiaryMenu = function(submenu){
	        $scope.tertiaryMenuVisible[submenu] = !$scope.tertiaryMenuVisible[submenu];
	    }
	    
	    $scope.toggleSearch = function(){
	        $scope.searchVisible = !$scope.searchVisible;
	        $scope.menuVisible = false;     
	        $scope.settingsVisible = false;
	    }
	    
	    $scope.toggleSettings = function(){
	        $scope.settingsVisible = !$scope.settingsVisible;
	        $scope.menuVisible = false;
	        $scope.searchVisible = false;
	    }   
	    
	    $scope.handleMobileMenuOption = function($event){
	        $event.preventDefault();
	        var w = getWindowWidth();           
	        if(w > 767) {               
	            window.location = $event.target.getAttribute('href');
	        }
	    }
	    
	}]);

	angular.module('orcidApp').controller('widgetCtrl',['$scope', 'widgetSrvc', function ($scope, widgetSrvc){
	    $scope.hash = orcidVar.orcidIdHash.substr(0, 6);
	    $scope.showCode = false;
	    $scope.widgetSrvc = widgetSrvc;
	    
	    $scope.widgetURLND = '<div style="width:100%;text-align:center"><iframe src="'+ getBaseUri() + '/static/html/widget.html?orcid=' + orcidVar.orcidId + '&t=' + $scope.hash + '&locale=' + $scope.widgetSrvc.locale + '" frameborder="0" height="310" width="210px" vspace="0" hspace="0" marginheight="5" marginwidth="5" scrolling="no" allowtransparency="true"></iframe></div>';
	    
	    $scope.inputTextAreaSelectAll = function($event){
	        $event.target.select();
	    }
	    
	    $scope.toggleCopyWidget = function(){
	        $scope.showCode = !$scope.showCode;
	    }
	    
	    $scope.hideWidgetCode = function(){
	        $scope.showCode = false;
	    }
	    
	}]);

	angular.module('orcidApp').controller('PublicRecordCtrl',['$scope', '$compile',function ($scope, $compile) {
	    $scope.showSources = new Array();
	    $scope.showPopover = new Array();
	    $scope.toggleSourcesDisplay = function(section){        
	        $scope.showSources[section] = !$scope.showSources[section];     
	    }
	    
	    $scope.showPopover = function(section){
	        $scope.showPopover[section] = true;
	    }   
	    
	    $scope.hidePopover = function(section){
	        $scope.showPopover[section] = false;    
	    }
	}]);

	/*
	 * FILTERS
	 */

	angular.module('orcidApp').filter('formatBibtexOutput', function () {
	    return function (text) {
	        var str = text.replace(/[\-?_?]/, ' ');
	        return str.toUpperCase();
	    };
	});


	angular.module('orcidApp').filter('orderObjectBy', function() {
	      return function(items, field, reverse) {
	        var filtered = [];
	        angular.forEach(items, function(item) {
	          filtered.push(item);
	        });
	        filtered.sort(function (a, b) {
	          return (a[field] > b[field] ? 1 : -1);
	        });
	        if(reverse) filtered.reverse();
	        return filtered;
	     };
	});

	angular.module('orcidApp').filter("filterImportWizards", function(){ 
	    return function(input, selectedWorkType, selectedGeoArea) {
	        var output = [];        
	        if(selectedWorkType == 'All' && selectedGeoArea == 'All'){
	            output = input;
	        }else{
	            for(var i = 0; i < input.length; i ++) {
	                for(var j = 0; j <  input[i].redirectUris.redirectUri.length; j ++) {
	                    if (selectedWorkType == 'All'){
	                        if (contains(input[i].redirectUris.redirectUri[j].geoArea['import-works-wizard'],selectedGeoArea)){
	                            output.push(input[i]);
	                        }
	                    }else if(selectedGeoArea == 'All'){
	                        if (contains(input[i].redirectUris.redirectUri[j].actType['import-works-wizard'],selectedWorkType)){
	                            output.push(input[i]);
	                        }                       
	                    }else{                                      
	                        if (contains(input[i].redirectUris.redirectUri[j].actType['import-works-wizard'],selectedWorkType) && contains(input[i].redirectUris.redirectUri[j].geoArea['import-works-wizard'],selectedGeoArea)){
	                            output.push(input[i]);
	                        }
	                    }
	                }
	            }           
	        }
	        return output;
	    };
	});


	angular.module('orcidApp').filter('urlProtocol', function(){
	    return function(url){
	        if (url == null) return url;
	        if(!url.startsWith('http')) {               
	            if (url.startsWith('//')){              
	                url = ('https:' == document.location.protocol ? 'https:' : 'http:') + url;
	            } else {
	                url = 'http://' + url;    
	            }
	        }
	        return url;
	    }
	});

	angular.module('orcidApp').filter('uri', function() {
	    return window.encodeURIComponent;
	});

	angular.module('orcidApp').filter('latex', function(){
	    return function(input){
	        if (input == null) return "";
	        return latexParseJs.decodeLatex(input);
	    };
	});

	angular.module('orcidApp').filter('ajaxFormDateToISO8601', function(){
	    return function(input){
	        if (typeof input != 'undefined'){
	            var str = '';
	            if (input.year) str += input.year;
	            if (input.month) {
	                if (str.length > 0) str += '-';
	                str += Number(input.month).pad(2);
	            }
	            if (input.day) {
	                if (str.length > 0)
	                    str += '-';
	                str += Number(input.day).pad(2);
	            }
	            return str;
	        } else {
	            return false;
	        }
	    };
	});

	angular.module('orcidApp').filter('humanDate', function($filter){
	    var standardDateFilter = $filter('date');
	    return function(input){
	        var inputDate = new Date(input);
	        var dateNow = new Date();
	        var dateFormat = (inputDate.getYear() === dateNow.getYear() && inputDate.getMonth() === dateNow.getMonth() && inputDate.getDate() === dateNow.getDate())  ? 'HH:mm' : 'yyyy-MM-dd';
	        return standardDateFilter(input, dateFormat);
	    };
	});

	angular.module('orcidApp').filter('contributorFilter', function(){
	    return function(ctrb){
	        var out = '';
	        if (!emptyTextField(ctrb.contributorRole)) out = out + ctrb.contributorRole.value;
	        if (!emptyTextField(ctrb.contributorSequence)) out = addComma(out) + ctrb.contributorSequence.value;
	        if (!emptyTextField(ctrb.orcid)) out = addComma(out) + ctrb.orcid.value;
	        if (!emptyTextField(ctrb.email)) out = addComma(out) + ctrb.email.value;
	        if (out.length > 0) out = '(' + out + ')';
	        return out;
	    };
	});

	angular.module('orcidApp').filter('clean', function($filter){
	   return function(x, idx){
	       console.log(idx);
	       
	       return x;
	   }; 
	});

	angular.module('orcidApp').filter('workExternalIdentifierHtml', function($filter){
	    return function(workExternalIdentifier, first, last, length, moreInfo){
	        var id = null;
	        var isPartOf = false;
	        var link = null;
	        var ngclass = '';
	        var output = '';
	        var type = null;
	        
	        if (moreInfo == false || typeof moreInfo == 'undefined') ngclass = 'truncate-anchor';
	        
	        if(workExternalIdentifier.relationship != null && workExternalIdentifier.relationship.value == 'part-of')
	            isPartOf = true;        
	        if (workExternalIdentifier == null){
	            return output;
	        } 
	        if (workExternalIdentifier.workExternalIdentifierId == null) {
	            return output;        
	        }
	        
	        id = workExternalIdentifier.workExternalIdentifierId.value;
	        type;
	        
	        if (workExternalIdentifier.workExternalIdentifierType != null) {
	            type = workExternalIdentifier.workExternalIdentifierType.value;        
	        }
	        if (type != null && typeof type != 'undefined') {
	            type.escapeHtml();
	            if(isPartOf) {
	                output = output + "<span class='italic'>" + om.get("common.part_of") + " <span class='type'>" + type.toUpperCase() + "</span></span>: ";
	            }
	            else {
	                output = output + "<span class='type'>" + type.toUpperCase() + "</span>: ";
	            }
	        }
	        
	        if (workExternalIdentifier.url != null && workExternalIdentifier.url.value != '') {
	            link = workExternalIdentifier.url.value;
	        }
	        else {
	            link = workIdLinkJs.getLink(id,type);   
	        }
	        if (link != null) {         
	            link = $filter('urlProtocol')(link);            
	            output = output + '<a href="' + link.replace(/'/g, "&#39;") + '" class ="' + ngclass + '"' + " target=\"_blank\" ng-mouseenter=\"showURLPopOver(work.putCode.value + $index)\" ng-mouseleave=\"hideURLPopOver(work.putCode.value + $index)\">" + id.escapeHtml() + '</a>';            
	        } else {
	            output = output + id.escapeHtml();        
	        }
	        
	        if( link != null ) {
	            output += '<div class="popover-pos">\
	                <div class="popover-help-container">\
	                    <div class="popover bottom" ng-class="{'+"'block'"+' : displayURLPopOver[work.putCode.value + $index] == true}">\
	                        <div class="arrow"></div>\
	                        <div class="popover-content">\
	                            <a href="'+link+'" target="_blank" class="ng-binding">'+link.escapeHtml()+'</a>\
	                        </div>\
	                    </div>\
	                </div>\
	          </div>';
	       }
	            
	       return output;
	    };
	});

	//Currently being used in Fundings only
	angular.module('orcidApp').filter('externalIdentifierHtml', ['fundingSrvc', '$filter', function(fundingSrvc, $filter){
	    return function(externalIdentifier, first, last, length, type, moreInfo){
	        var isPartOf = false;
	        var link = null;
	        var ngclass = '';
	        var output = '';
	        var value = null;        

	        if (externalIdentifier == null) {
	            return output;
	        }

	        if(externalIdentifier.relationship != null && externalIdentifier.relationship.value == 'part-of') {
	            isPartOf = true;     
	        }

	        //If type is set always come: "grant_number"
	        if (type != null) {
	            if(isPartOf){
	                output += "<span class='italic'>" + om.get("common.part_of") + "</span>&nbsp";
	            }
	            if (type.value == 'grant') {
	                output += om.get('funding.add.external_id.value.label.grant') + ": ";
	            } else if (type.value == 'contract') {
	                output += om.get('funding.add.external_id.value.label.contract') + ": ";
	            } else {
	                output += om.get('funding.add.external_id.value.label.award') + ": ";
	            }
	            
	        }         
	        
	        if(externalIdentifier.value != null){
	            value = externalIdentifier.value.value;
	        }
	        
	        if(externalIdentifier.url != null) {
	            link = externalIdentifier.url.value;
	        }
	 
	        if(link != null) {
	            link = $filter('urlProtocol')(link);
	            
	            if(value != null) {
	                output += "<a href='" + link + "' class='truncate-anchor' target='_blank' ng-mouseenter='showURLPopOver(funding.putCode.value+ $index)' ng-mouseleave='hideURLPopOver(funding.putCode.value + $index)'>" + value.escapeHtml() + "</a>";
	            } else {
	                if(type != null) {
	                    if (moreInfo == false || typeof moreInfo == 'undefined') {
	                        ngclass = 'truncate-anchor';
	                    }
	                    
	                    if(type.value == 'grant') {
	                        output = om.get('funding.add.external_id.url.label.grant') + ': <a href="' + link + '" class="' + ngclass + '"' + " target=\"_blank\" ng-mouseenter=\"showURLPopOver(funding.putCode.value + $index)\" ng-mouseleave=\"hideURLPopOver(funding.putCode.value + $index)\">" + link.escapeHtml() + "</a>";
	                    } else if(type.value == 'contract') {
	                        output = om.get('funding.add.external_id.url.label.contract') + ': <a href="' + link + '" class="' + ngclass + '"' + " target=\"_blank\" ng-mouseenter=\"showURLPopOver(funding.putCode.value + $index)\" ng-mouseleave=\"hideURLPopOver(funding.putCode.value + $index)\">" + link.escapeHtml() + "</a>";
	                    } else {
	                        output = om.get('funding.add.external_id.url.label.award') + ': <a href="' + link + '" class="' + ngclass + '"' + " target=\"_blank\" ng-mouseenter=\"showURLPopOver(funding.putCode.value + $index)\" ng-mouseleave=\"hideURLPopOver(funding.putCode.value + $index)\">" + link.escapeHtml() + "</a>";
	                    }
	                    
	                }               
	            }
	        } else if(value != null) {
	            output = output + " " + value.escapeHtml();
	        }
	        
	        if( link != null ) {            
	            output += '<div class="popover-pos">\
	                        <div class="popover-help-container">\
	                            <div class="popover bottom" ng-class="{'+"'block'"+' : displayURLPopOver[funding.putCode.value + $index] == true}">\
	                                <div class="arrow"></div>\
	                                <div class="popover-content">\
	                                    <a href="'+link+'" target="_blank" class="ng-binding">'+link.escapeHtml()+'</a>\
	                                </div>\
	                            </div>\
	                        </div>\
	                  </div>';
	        }
	        
	        return output;
	    };
	}]);

	angular.module('orcidApp').filter('peerReviewExternalIdentifierHtml', function($filter){
	    return function(peerReviewExternalIdentifier, first, last, length, moreInfo, own){
	        
	        var id = null;
	        var output = '';
	        var ngclass = '';
	        var isPartOf = false;
	        var type = null;
	        var link = null;
	        ngclass = 'truncate';
	        
	        if (peerReviewExternalIdentifier == null) return output;
	        
	        if(peerReviewExternalIdentifier.relationship != null && peerReviewExternalIdentifier.relationship.value == 'part-of')
	            isPartOf = true;
	        
	        if (peerReviewExternalIdentifier.workExternalIdentifierId == null) return output;
	        id = peerReviewExternalIdentifier.workExternalIdentifierId.value;        
	        
	        if (peerReviewExternalIdentifier.workExternalIdentifierType != null)
	            type = peerReviewExternalIdentifier.workExternalIdentifierType.value;
	            if (type != null) {
	                if(isPartOf)
	                    output += "<span class='italic'>" + om.get("common.part_of") + " <span class='type'>" + type.toUpperCase().escapeHtml() + "</span></span>: ";
	                else 
	                    output += "<span class='type'>" + type.toUpperCase().escapeHtml() + "</span>: ";
	            }
	        
	        if (peerReviewExternalIdentifier.url != null && peerReviewExternalIdentifier.url.value != '')
	            link = peerReviewExternalIdentifier.url.value;
	        else link = workIdLinkJs.getLink(id,type); 
	            
	        if (link != null){
	            link = $filter('urlProtocol')(link);
	            output += '<a href="' + link.replace(/'/g, "&#39;") + '" class =""' + " target=\"_blank\" ng-mouseenter=\"showURLPopOver(peerReview.putCode.value + $index)\" ng-mouseleave=\"hideURLPopOver(peerReview.putCode.value + $index)\">" + id.escapeHtml() + '</a>';
	        }else{
	            output += id.escapeHtml();        
	        }
	        
	        if (length > 1 && !last) output = output + ',';
	        
	        
	        
	        if (link != null){
	            output += '\
	            <div class="popover-pos">\
	                <div class="popover-help-container">\
	                    <div class="popover bottom" ng-class="{'+"'block'"+' : displayURLPopOver[peerReview.putCode.value + $index] == true}">\
	                        <div class="arrow"></div>\
	                        <div class="popover-content">\
	                            <a href="'+link+'" target="_blank">'+link.escapeHtml()+'</a>\
	                        </div>\
	                    </div>\
	                </div>\
	           </div>';
	        }
	        
	       if(own)
	            output = '<br/>' + output;
	        
	       return output;      
	      
	     
	    };
	});

	//used in dropdown filters on /members and /consortia
	angular.module('orcidApp').filter('unique', function () {

	    return function (items, filterOn) {

	      if (filterOn === false) {
	        return items;
	      }

	      if ((filterOn || angular.isUndefined(filterOn)) && angular.isArray(items)) {
	        var hashCheck = {}, newItems = [];

	        var extractValueToCompare = function (item) {
	          if (angular.isObject(item) && angular.isString(filterOn)) {
	            return item[filterOn];
	          } else {
	            return item;
	          }
	        };

	        angular.forEach(items, function (item) {
	          var valueToCheck, isDuplicate = false;

	          for (var i = 0; i < newItems.length; i++) {
	            if (angular.equals(extractValueToCompare(newItems[i]), extractValueToCompare(item))) {
	              isDuplicate = true;
	              break;
	            }
	          }
	          if (!isDuplicate) {
	            newItems.push(item);
	          }

	        });
	        items = newItems;
	      }
	      return items;
	    };
	  });

	//used in alphabetical filter on /members and /consortia
	angular.module('orcidApp').filter('startsWithLetter', function() {
	    return function(items, letter) {

	        var filtered = [];
	        var letterMatch = new RegExp(letter, 'i');
	        var item = null;
	        for (var i = 0; i < items.length; i++) {
	          item = items[i];
	          if (letterMatch.test(item.name.substring(0, 1))) {
	            filtered.push(item);
	          }
	        }
	        return filtered;
	      };
	    });


	/*
	 * DIRECTIVES
	 */


	/*Use instead ng-bind-html when you want to include directives inside the HTML to bind */
	angular.module('orcidApp').directive('bindHtmlCompile', ['$compile', function ($compile) {
	    return {
	        restrict: 'A',
	        link: function (scope, element, attrs) {
	            scope.$watch(function () {
	                return scope.$eval(attrs.bindHtmlCompile);
	            }, function (value) {
	                element.html(value);
	                $compile(element.contents())(scope);
	            });
	        }
	    };
	}]);


	angular.module('orcidApp').directive('scroll', function () {
	    return {
	        restrict: 'A',
	        link: function ($scope, element, attrs) {
	            $scope.scrollTop = 0;
	            var raw = element[0];
	            element.bind('scroll', function () {
	                $scope.scrollTop = raw.scrollTop;
	                //$scope.$apply(attrs.scroll);
	            });
	        }
	    }
	});

	angular.module('orcidApp').directive('ngModelOnblur', function() {
	    return {
	        restrict: 'A',
	        require: 'ngModel',
	        link: function(scope, elm, attr, ngModelCtrl) {
	            if (attr.type === 'radio' || attr.type === 'checkbox') return;

	            elm.unbind('input').unbind('keydown').unbind('change');

	            elm.bind("keydown keypress", function(event) {
	                if (event.which === 13) {
	                    scope.$apply(function() {
	                        ngModelCtrl.$setViewValue(elm.val());
	                    });
	                }
	            });

	            elm.bind('blur', function() {
	                scope.$apply(function() {
	                    ngModelCtrl.$setViewValue(elm.val());
	                });
	            });
	        }
	    };
	});

	angular.module('orcidApp').directive('appFileTextReader', function($q){
	        var slice = Array.prototype.slice;
	        return {
	            restrict: 'A',
	            require: 'ngModel',
	            scope: {
	                updateFn: '&'
	            },
	            link: function(scope, element, attrs, ngModelCtrl){
	                if(!ngModelCtrl) return;
	                ngModelCtrl.$render = function(){};
	                element.bind('change', function(event){
	                    var element = event.target;
	                    $q.all(slice.call(element.files, 0).map(readFile))
	                    .then(function(values){
	                        if(element.multiple){
	                            for(v in values){
	                                ngModelCtrl.$viewValue.push(values[v]);
	                            }
	                        }
	                        else{
	                            ngModelCtrl.$setViewValue(values.length ? values[0] : null);
	                        }
	                        scope.updateFn(scope);
	                        element.value = null;
	                    });
	                    function readFile(file) {
	                        var deferred = $q.defer();
	                        var reader = new FileReader();
	                        reader.onload = function(event){
	                            deferred.resolve(event.target.result);
	                        };
	                        reader.onerror = function(event) {
	                            deferred.reject(event);
	                        };
	                        reader.readAsText(file);
	                        return deferred.promise;
	                    }
	                });//change
	            }//link
	        };//return
	    });//appFilereader

	//Thanks to: https://docs.angularjs.org/api/ng/service/$compile#attributes
	angular.module('orcidApp').directive('compile', function($compile) {
	    // directive factory creates a link function
	    return function(scope, element, attrs) {
	        console.log("compile");
	      scope.$watch(
	        function(scope) {
	           // watch the 'compile' expression for changes
	          return scope.$eval(attrs.compile);
	        },
	        function(value) {
	          // when the 'compile' expression changes
	          // assign it into the current DOM
	          element.html(value);

	          // compile the new DOM and link it to the current
	          // scope.
	          // NOTE: we only compile .childNodes so that
	          // we don't get into infinite loop compiling ourselves
	          $compile(element.contents())(scope);
	        }
	      );
	    };
	  });

	angular.module('orcidApp').directive('resize', function ($window) {
	    return function ($scope, element) {
	        var w = angular.element($window);
	        /* Only used for detecting window resizing, the value returned by w.width() is not accurate, please refer to getWindowWidth() */
	        $scope.getWindowWidth = function () {
	            return { 'w': getWindowWidth() };
	        };
	        $scope.$watch($scope.getWindowWidth, function (newValue, oldValue) {            
	            
	            $scope.windowWidth = newValue.w;
	            
	            
	            if($scope.windowWidth > 767){ /* Desktop view */
	                $scope.menuVisible = true;
	                $scope.searchVisible = true;
	                $scope.settingsVisible = true;
	            }else{
	                $scope.menuVisible = false;
	                $scope.searchVisible = false;
	                $scope.settingsVisible = false;
	            }
	            
	        }, true);
	    
	        w.bind('resize', function () {
	            $scope.$apply();
	        });
	    }
	});





	/* Do not add anything below, see file structure at the top of this file */

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./BiographyCtrl.js": 3,
		"./CountryCtrl.js": 4,
		"./EmailEditCtrl.js": 5,
		"./FundingCtrl.js": 6,
		"./KeywordsCtrl.js": 7,
		"./NameCtrl.js": 8,
		"./NotificationsCtrl.js": 9,
		"./OtherNamesCtrl.js": 10,
		"./languageCtrl.js": 11,
		"./websitesCtrl.js": 12,
		"./workCtrl.js": 13
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 2;


/***/ },
/* 3 */
/***/ function(module, exports) {

	angular.module('orcidApp').controller('BiographyCtrl',['$scope','$rootScope', '$compile', 'emailSrvc', 'initialConfigService', function ($scope, $rootScope, $compile, emailSrvc, initialConfigService) {
	    $scope.biographyForm = null;
	    $scope.emailSrvc = emailSrvc;
	    $scope.lengthError = false;
	    $scope.showEdit = false;
	    $scope.showElement = {};

	    /////////////////////// Begin of verified email logic for work
	    var configuration = initialConfigService.getInitialConfiguration();;
	    var emails = {};
	    var emailVerified = false;

	    var showEmailVerificationModal = function(){
	        $rootScope.$broadcast('emailVerifiedObj', {flag: emailVerified, emails: emails});
	    };
	    
	    $scope.emailSrvc.getEmails(
	        function(data) {
	            emails = data.emails;
	            data.emails.forEach(
	                function(element){
	                    if(element.verified == true) {
	                        emailVerified = true;
	                    }
	                }
	            );
	        }
	    );
	    /////////////////////// End of verified email logic for work

	    $scope.toggleEdit = function() {
	        if(emailVerified === true || configuration.showModalManualEditVerificationEnabled == false){
	            $scope.showEdit = !$scope.showEdit;
	        }else{
	            showEmailVerificationModal();
	        }
	    };

	    $scope.close = function() {
	        $scope.showEdit = false;
	    };

	    $scope.cancel = function() {
	        $scope.getBiographyForm();
	        $scope.showEdit = false;
	    };

	    $scope.checkLength = function () {
	        if ($scope.biographyForm != null){
	            if ($scope.biographyForm.biography != null){
	                if ($scope.biographyForm.biography.value != null){    
	                    if ($scope.biographyForm.biography.value.length > 5000) {
	                        $scope.lengthError = true;
	                    } else {
	                        $scope.lengthError = false;
	                    }
	                }
	            }
	        }
	        return $scope.lengthError;
	    };


	    $scope.getBiographyForm = function(){
	        $.ajax({
	            url: getBaseUri() + '/account/biographyForm.json',
	            dataType: 'json',
	            success: function(data) {
	                $scope.biographyForm = data;
	                $scope.$apply();
	            }
	        }).fail(function(e){
	            // something bad is happening!
	            console.log("error fetching BiographyForm");
	            logAjaxError(e);
	        });
	    };

	    $scope.setBiographyForm = function(){
	        if( $scope.checkLength() ){    
	            return; // do nothing if there is a length error
	        } 
	        $.ajax({
	            url: getBaseUri() + '/account/biographyForm.json',
	            type: 'POST',
	            data:  angular.toJson($scope.biographyForm),
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                $scope.biographyForm = data;
	                if(data.errors.length == 0){
	                    $scope.close();
	                }
	                $scope.$apply();
	            }
	        }).fail(function() {
	            // something bad is happening!
	            console.log("BiographyCtrl.serverValidate() error");
	        });
	    };

	    $scope.setPrivacy = function(priv, $event) {
	        $event.preventDefault();
	        $scope.biographyForm.visiblity.visibility = priv;
	        $scope.setBiographyForm();        
	    };
	    
	    $scope.showTooltip = function(tp){
	        $scope.showElement[tp] = true;
	    };
	    
	    $scope.hideTooltip = function(tp){
	        $scope.showElement[tp] = false;
	    };

	    $scope.getBiographyForm();

	}]);

/***/ },
/* 4 */
/***/ function(module, exports) {

	angular.module('orcidApp').controller('CountryCtrl', ['$scope', '$rootScope', '$compile', 'bioBulkSrvc', 'commonSrvc', 'emailSrvc', 'initialConfigService', 'utilsService', function ($scope, $rootScope, $compile, bioBulkSrvc, commonSrvc, emailSrvc, initialConfigService, utilsService) {
	    bioBulkSrvc.initScope($scope);
	    $scope.commonSrvc = commonSrvc;
	    $scope.countryForm = null;
	    $scope.defaultVisibility = null;
	    $scope.emailSrvc = emailSrvc;
	    $scope.newElementDefaultVisibility = null;
	    $scope.newInput = false;    
	    $scope.orcidId = orcidVar.orcidId;
	    $scope.primaryElementIndex = null;
	    $scope.privacyHelp = false;
	    $scope.scrollTop = 0;   
	    $scope.showEdit = false;
	    $scope.showElement = {};


	    /////////////////////// Begin of verified email logic for work
	    var configuration = initialConfigService.getInitialConfiguration();
	    var emailVerified = false;
	    var emails = {};
	    var utilsService = utilsService;


	    var showEmailVerificationModal = function(){
	        $rootScope.$broadcast('emailVerifiedObj', {flag: emailVerified, emails: emails});
	    };
	    
	    $scope.emailSrvc.getEmails(
	        function(data) {
	            emails = data.emails;
	            data.emails.forEach(
	                function(element){
	                    if(element.verified == true) {
	                        emailVerified = true;
	                    }
	                }
	            );
	        }
	    );
	    /////////////////////// End of verified email logic for work

	    $scope.getCountryForm = function(){
	        $.ajax({
	            url: getBaseUri() + '/account/countryForm.json',
	            dataType: 'json',
	            success: function(data) {
	                $scope.countryForm = data;                
	                $scope.newElementDefaultVisibility = $scope.countryForm.visibility.visibility;
	                //If there is at least one element, iterate over them to see if they have the same visibility, to set the default  visibility element
	                if($scope.countryForm != null && $scope.countryForm.addresses != null && $scope.countryForm.addresses.length > 0) {
	                    var highestDisplayIndex = null;
	                    var itemVisibility = null;
	                    
	                    for(var i = 0; i < $scope.countryForm.addresses.length; i ++) {
	                        if($scope.countryForm.addresses[i].visibility != null && $scope.countryForm.addresses[i].visibility.visibility) {
	                            itemVisibility = $scope.countryForm.addresses[i].visibility.visibility;
	                        }
	                        /**
	                         * The default visibility should be set only when all elements have the same visibility, so, we should follow this rules: 
	                         * 
	                         * Rules: 
	                         * - If the default visibility is null:
	                         *  - If the item visibility is not null, set the default visibility to the item visibility
	                         * - If the default visibility is not null:
	                         *  - If the default visibility is not equals to the item visibility, set the default visibility to null and stop iterating 
	                         * */
	                        if($scope.defaultVisibility == null) {
	                            if(itemVisibility != null) {
	                                $scope.defaultVisibility = itemVisibility;
	                            }                           
	                        } else {
	                            if(itemVisibility != null) {
	                                if($scope.defaultVisibility != itemVisibility) {
	                                    $scope.defaultVisibility = null;
	                                    break;
	                                }
	                            } else {
	                                $scope.defaultVisibility = null;
	                                break;
	                            }
	                        }                                                                   
	                    }
	                    //We have to iterate on them again to select the primary address
	                    for(var i = 0; i < $scope.countryForm.addresses.length; i ++) {
	                        //Set the primary element based on the display index
	                        if($scope.primaryElementIndex == null || highestDisplayIndex < $scope.countryForm.addresses[i].displayIndex) {
	                            $scope.primaryElementIndex = i;
	                            highestDisplayIndex = $scope.countryForm.addresses[i].displayIndex;
	                        }
	                    }
	                } else {
	                    $scope.defaultVisibility = $scope.countryForm.visibility.visibility;                    
	                }     
	                $scope.$apply();                
	            }
	        }).fail(function(e){
	            // something bad is happening!
	            console.log("error fetching external identifiers");
	            logAjaxError(e);
	        });
	    };

	    $scope.toggleClickPrivacyHelp = function() {
	        if (!document.documentElement.className.contains('no-touch')){
	            $scope.privacyHelp=!$scope.privacyHelp;
	        }
	    };

	    $scope.setCountryForm = function(){
	        $scope.countryForm.visibility = null;
	        $.ajax({
	            url: getBaseUri() + '/account/countryForm.json',
	            type: 'POST',
	            data:  angular.toJson($scope.countryForm),
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                $scope.countryForm = data;
	                if ($scope.countryForm.errors.length == 0){
	                    $.colorbox.close();
	                    $scope.getCountryForm();
	                }else{
	                    console.log($scope.countryForm.errors);
	                }
	                
	                $scope.$apply();
	            }
	        }).fail(function() {
	            // something bad is happening!
	            console.log("CountryCtrl.serverValidate() error");
	        });
	    };
	    
	    $scope.closeModal = function(){     
	        $.colorbox.close();
	    }

	    $scope.setPrivacy = function(priv, $event) {
	        $event.preventDefault();
	        $scope.defaultVisibility = priv;
	    };
	    
	    $scope.setPrivacyModal = function(priv, $event, country) {        
	        $event.preventDefault();
	        var countries = $scope.countryForm.addresses;        
	        var len = countries.length;        
	        while (len--) {
	            if (countries[len] == country){            
	                countries[len].visibility.visibility = priv;
	                $scope.countryForm.addresses = countries;
	            }
	        }
	    };
	    
	    $scope.openEditModal = function() {
	        
	        if(emailVerified === true || configuration.showModalManualEditVerificationEnabled == false){
	            $scope.bulkEditShow = false;
	            
	            $.colorbox({
	                scrolling: true,
	                html: $compile($('#edit-country').html())($scope),
	                onLoad: function() {
	                    $('#cboxClose').remove();
	                    if ($scope.countryForm.addresses.length == 0){                  
	                        $scope.addNewModal();
	                    } else {
	                        if ($scope.countryForm.addresses.length == 1){
	                            if($scope.countryForm.addresses[0].source == null){
	                                $scope.countryForm.addresses[0].source = $scope.orcidId;
	                                $scope.countryForm.addresses[0].sourceName = "";
	                            }
	                        }
	                        $scope.updateDisplayIndex();
	                    }                
	                },
	     
	                width: utilsService.formColorBoxResize(),
	                onComplete: function() {
	                        
	                },
	                onClosed: function() {
	                    $scope.getCountryForm();
	                }            
	            });
	            $.colorbox.resize();
	        }else{
	            showEmailVerificationModal();
	        }
	    }
	    
	    $scope.closeEditModal = function(){
	        $.colorbox.close();
	    }
	    
	    $scope.deleteCountry = function(country){
	        var countries = $scope.countryForm.addresses;
	        var len = countries.length;
	        while (len--) {
	            if (countries[len] == country){
	                countries.splice(len,1);
	                $scope.countryForm.addresses = countries;
	            }       
	        }
	    };
	    
	    $scope.updateDisplayIndex = function(){
	        for (var idx in $scope.countryForm.addresses){
	            $scope.countryForm.addresses[idx]['displayIndex'] = $scope.countryForm.addresses.length - idx;                       
	        }
	    };
	    
	    $scope.addNewModal = function() {       
	        var tmpObj = {
	            "errors":[],
	            "iso2Country": null,
	            "countryName":null,
	            "putCode":null,
	            "visibility":{
	                "errors":[],
	                "required":true,
	                "getRequiredMessage":null,
	                "visibility":$scope.newElementDefaultVisibility
	            },
	            "displayIndex":1,
	            "source":$scope.orcidId,
	            "sourceName":""
	        };
	        $scope.countryForm.addresses.push(tmpObj);
	        $scope.updateDisplayIndex();
	        $scope.newInput = true; 
	    };
	    
	    $scope.swapUp = function(index){
	        if (index > 0) {
	            var temp = $scope.countryForm.addresses[index];
	            var tempDisplayIndex = $scope.countryForm.addresses[index]['displayIndex'];
	            temp['displayIndex'] = $scope.countryForm.addresses[index - 1]['displayIndex']
	            $scope.countryForm.addresses[index] = $scope.countryForm.addresses[index - 1];
	            $scope.countryForm.addresses[index]['displayIndex'] = tempDisplayIndex;
	            $scope.countryForm.addresses[index - 1] = temp;
	        }
	    };

	    $scope.swapDown = function(index){
	        if (index < $scope.countryForm.addresses.length - 1) {
	            var temp = $scope.countryForm.addresses[index];
	            var tempDisplayIndex = $scope.countryForm.addresses[index]['displayIndex'];
	            temp['displayIndex'] = $scope.countryForm.addresses[index + 1]['displayIndex']
	            $scope.countryForm.addresses[index] = $scope.countryForm.addresses[index + 1];
	            $scope.countryForm.addresses[index]['displayIndex'] = tempDisplayIndex;
	            $scope.countryForm.addresses[index + 1] = temp;
	        }
	    };
	    
	    $scope.setBulkGroupPrivacy = function(priv) {
	        for (var idx in $scope.countryForm.addresses){
	            $scope.countryForm.addresses[idx].visibility.visibility = priv;        
	        }
	    };
	     
	    $scope.getCountryForm();
	}]);

/***/ },
/* 5 */
/***/ function(module, exports) {

	angular.module('orcidApp').controller('EmailEditCtrl', ['$scope', '$compile', 'emailSrvc' , 'bioBulkSrvc', '$timeout', '$cookies', 'commonSrvc', function EmailEditCtrl($scope, $compile, emailSrvc, bioBulkSrvc, $timeout, $cookies, commonSrvc) {
	    bioBulkSrvc.initScope($scope);
	    $scope.emailSrvc = emailSrvc;
	    $scope.privacyHelp = {};
	    $scope.verifyEmailObject;
	    $scope.showElement = {};
	    $scope.isPassConfReq = orcidVar.isPasswordConfirmationRequired;
	    $scope.baseUri = orcidVar.baseUri;
	    $scope.showDeleteBox = false;
	    $scope.showConfirmationBox = false;
	    $scope.showEmailVerifBox = false;
	    $scope.commonSrvc = commonSrvc;
	    $scope.scrollTop = 0;    

	    $scope.toggleClickPrivacyHelp = function(key) {
	        if (!document.documentElement.className.contains('no-touch'))
	            $scope.privacyHelp[key]=!$scope.privacyHelp[key];
	    };

	    $scope.getEmails = function() {
	        emailSrvc.getEmails(function() {
	            if(isIE() == 7) $scope.fixZindexesIE7();
	        });
	    };

	    //init
	    $scope.password = null;
	    $scope.curPrivToggle = null;
	    emailSrvc.getEmails();
	    emailSrvc.initInputEmail();

	    $scope.fixZindexesIE7 =  function(){
	        fixZindexIE7('.popover',2000);
	        fixZindexIE7('.popover-help-container',3000);
	        fixZindexIE7('#privacy-bar',500);
	        fixZindexIE7('.emailVisibility',5000);
	        fixZindexIE7('.col-md-3', 6000);
	        fixZindexIE7('.row', 7000);
	    };

	    $scope.setPrivacy = function(email, priv, $event) {
	        $event.preventDefault();
	        email.visibility = priv;
	        $scope.curPrivToggle = null;
	        emailSrvc.saveEmail();
	    };

	    $scope.verifyEmail = function(email, popup) {
	        
	        $scope.verifyEmailObject = email;
	        
	        if(popup){
	            emailSrvc.verifyEmail(email,function(data) {
	                $scope.showEmailVerifBox = true;
	                $scope.$apply();
	                $.colorbox.resize();
	           });    
	        }else{
	            emailSrvc.verifyEmail(email,function(data) {
	                $.colorbox({
	                    html : $compile($('#settings-verify-email-modal').html())($scope) 
	                    //Name was changed to avoid conflicts with workspace verify email modal
	                });
	                $scope.$apply();
	                $.colorbox.resize();
	           });    
	        }
	        
	    };

	    $scope.closeModal = function() {
	        
	        angular.element('#cboxLoadedContent').css({         
	            overflow: 'auto'
	        });
	        
	        $.colorbox.close();
	    };
	    
	    $scope.closeDeleteBox = function(){
	        $scope.showDeleteBox = false;
	    };
	    
	    $scope.closeVerificationBox = function(){
	        $scope.showEmailVerifBox = false;
	    };

	    $scope.submitModal = function (obj, $event) {
	        emailSrvc.inputEmail.password = $scope.password;
	        emailSrvc.addEmail();
	        if(!$scope.emailSrvc.popUp){
	            $.colorbox.close();    
	        }
	    };

	    $scope.confirmDeleteEmail = function(email) {
	        emailSrvc.delEmail = email;
	        $.colorbox({
	            html : $compile($('#delete-email-modal').html())($scope)
	        });
	        $.colorbox.resize();
	    };
	    
	    $scope.confirmDeleteEmailInline = function(email, $event) {
	        $event.preventDefault();
	        $scope.showDeleteBox = true;
	        emailSrvc.delEmail = email;
	        
	        $scope.$watch(
	            function () {
	                return document.getElementsByClassName('delete-email-box').length; 
	            },
	            function (newValue, oldValue) {             
	                $.colorbox.resize();
	            }
	        );
	    };

	    $scope.deleteEmail = function () {
	        emailSrvc.deleteEmail(function() {
	            $scope.closeModal();
	        });
	    };
	    
	    $scope.deleteEmailInline = function () {
	        emailSrvc.deleteEmail(function(){
	            $scope.showDeleteBox = false;            
	        });
	    };

	    $scope.checkCredentials = function(popup) {
	        $scope.password = null;
	        if(orcidVar.isPasswordConfirmationRequired){
	            if (!popup){
	                $.colorbox({
	                    html: $compile($('#check-password-modal').html())($scope)
	                });
	                $.colorbox.resize();
	            }else{
	                $scope.showConfirmationBox = true;            
	            }
	        }else{
	            $scope.submitModal();
	        }
	    };
	    
	    $scope.showTooltip = function(el, event){       
	        $scope.position = angular.element(event.target.parentNode).parent().position();
	        angular.element('.edit-record-emails .popover-help-container').css({            
	            top: $scope.position.top + 33,
	            left: $scope.position.left
	        });
	        angular.element('#cboxLoadedContent').css({         
	            overflow: 'visible'
	        });
	        $scope.showElement[el] = true;
	    };
	    
	    $scope.hideTooltip = function(el){
	        $scope.showElement[el] = false;
	    };
	    
	    $scope.setBulkGroupPrivacy = function(priv) {
	        for (var idx in emailSrvc.emails.emails)            
	            emailSrvc.emails.emails[idx].visibility = priv;
	        emailSrvc.saveEmail();
	    };
	    
	    /* Workaround for dealing with the Email table styles in Asian languages */
	    $scope.asianEmailTableStyleFix = function(){
	        if ($cookies.get('locale_v3') == 'zh_CN' || $cookies.get('locale_v3') == 'zh_TW' || $cookies.get('locale_v3') == 'ja' || $cookies.get('locale_v3') == 'ko'){     
	            $scope.styleFix = false;
	            $scope.$watch(
	                function () {
	                    return angular.element(document.getElementsByClassName("email-verified")[0]).length; 
	                },
	                function (newValue, oldValue) {
	                    if(newValue > oldValue){
	                        $scope.styleFix = true;                        
	                    }        
	                }
	            );
	            
	         };
	    };
	    
	    $scope.asianEmailTableStyleFix();
	    
	}]);

/***/ },
/* 6 */
/***/ function(module, exports) {

	/**
	 * Fundings Controller
	 * */
	angular.module('orcidApp').controller('FundingCtrl',['$scope', '$rootScope', '$compile', '$filter', 'fundingSrvc', 'workspaceSrvc', 'commonSrvc', 'emailSrvc', 'initialConfigService', 'utilsService', function ($scope, $rootScope, $compile, $filter, fundingSrvc, workspaceSrvc, commonSrvc, emailSrvc, initialConfigService, utilsService) {
	    $scope.addingFunding = false;
	    $scope.disambiguatedFunding = null;
	    $scope.displayURLPopOver = {};
	    $scope.editFunding = null;
	    $scope.editSources = {};
	    $scope.editTranslatedTitle = false;
	    $scope.emailSrvc = emailSrvc;
	    $scope.fundingImportWizard = false;
	    $scope.fundingSrvc = fundingSrvc;
	    $scope.lastIndexedTerm = null;
	    $scope.moreInfo = {};
	    $scope.privacyHelp = {};
	    $scope.showElement = {};
	    $scope.wizardDescExpanded = {};
	    $scope.workspaceSrvc = workspaceSrvc;
	    
	    /////////////////////// Begin of verified email logic for work
	    var configuration = initialConfigService.getInitialConfiguration();
	    var emailVerified = false;
	    var emails = {};
	    var utilsService = utilsService;


	    var showEmailVerificationModal = function(){
	        $rootScope.$broadcast('emailVerifiedObj', {flag: emailVerified, emails: emails});
	    };
	    
	    $scope.emailSrvc.getEmails(
	        function(data) {
	            emails = data.emails;
	            data.emails.forEach(
	                function(element){
	                    if(element.verified == true) {
	                        emailVerified = true;
	                    }
	                }
	            );
	        }
	    );
	    /////////////////////// End of verified email logic for work

	    $scope.sortState = new ActSortState(GroupedActivities.FUNDING);
	    $scope.sort = function(key) {
	        $scope.sortState.sortBy(key);
	    };

	    $scope.getEmptyExtId = function() {
	        return {
	                "errors": [],
	                "type": {
	                    "errors": [],
	                    "value": "award",
	                    "required": true,
	                    "getRequiredMessage": null
	                },
	                "value": {
	                    "errors": [],
	                    "value": "",
	                    "required": true,
	                    "getRequiredMessage": null
	                },
	                "url": {
	                    "errors": [],
	                    "value": "",
	                    "required": true,
	                    "getRequiredMessage": null
	                },
	                "putCode": null,
	                "relationship": {
	                    "errors": [],
	                    "value": "self",
	                    "required": true,
	                    "getRequiredMessage": null
	                }
	            };
	    }
	    
	    // remove once grouping is live
	    $scope.toggleClickMoreInfo = function(key) {
	        if (!document.documentElement.className.contains('no-touch')) {
	            if ($scope.moreInfoCurKey != null
	                    && $scope.moreInfoCurKey != key) {
	                $scope.moreInfo[$scope.moreInfoCurKey]=false;
	            }
	            $scope.moreInfoCurKey = key;
	            $scope.moreInfo[key]=!$scope.moreInfo[key];
	        }
	    };

	    $scope.hideSources = function(group) {
	        $scope.editSources[group.groupId] = false;
	        group.activePutCode = group.defaultPutCode;
	    };

	    $scope.showSources = function(group) {
	        $scope.editSources[group.groupId] = true;
	    };

	    // remove once grouping is live
	    $scope.moreInfoMouseEnter = function(key, $event) {
	        $event.stopPropagation();
	        if (document.documentElement.className.contains('no-touch')) {
	            if ($scope.moreInfoCurKey != null
	                    && $scope.moreInfoCurKey != key) {
	                $scope.privacyHelp[$scope.moreInfoCurKey]=false;
	            }
	            $scope.moreInfoCurKey = key;
	            $scope.moreInfo[key]=true;
	        }
	    };

	    $scope.showDetailsMouseClick = function(key, $event) {
	        $event.stopPropagation();
	        $scope.moreInfo[key] = !$scope.moreInfo[key];        
	    };

	    $scope.closeMoreInfo = function(key) {
	        $scope.moreInfo[key]=false;
	    };

	    $scope.addFundingModal = function(data){
	        if(emailVerified === true || configuration.showModalManualEditVerificationEnabled == false){
	            if(data == undefined) {
	                $scope.removeDisambiguatedFunding();
	                $.ajax({
	                    url: getBaseUri() + '/fundings/funding.json',
	                    dataType: 'json',
	                    success: function(data) {
	                        $scope.$apply(function() {                      
	                            $scope.editFunding = data;
	                            $scope.showAddModal();
	                        });
	                    }
	                }).fail(function() {
	                    console.log("Error fetching funding: " + value);
	                });
	            } else {
	                $scope.editFunding = data;
	                if($scope.editFunding.externalIdentifiers == null || $scope.editFunding.externalIdentifiers.length == 0) {
	                    $scope.editFunding.externalIdentifiers.push($scope.getEmptyExtId());
	                }            
	                $scope.showAddModal();
	            }
	        }else{
	            showEmailVerificationModal();
	        }
	    };

	    $scope.showAddModal = function(){
	        $scope.editTranslatedTitle = false;
	        $.colorbox({
	            html: $compile($('#add-funding-modal').html())($scope),
	            width: utilsService.formColorBoxResize(),
	            onComplete: function() {
	                //resize to insure content fits
	                utilsService.formColorBoxResize();
	                $scope.bindTypeaheadForOrgs();
	                $scope.bindTypeaheadForSubTypes();
	            },
	            onClosed: function() {
	                $scope.closeAllMoreInfo();
	                fundingSrvc.getFundings('fundings/fundingIds.json');
	            }
	        });
	    };

	    $scope.closeAllMoreInfo = function() {
	        for (var idx in $scope.moreInfo){
	            $scope.moreInfo[idx]=false;
	        }
	    };

	    $scope.putFunding = function(){
	        if ($scope.addingFunding){    
	            return; // don't process if adding funding
	        } 
	        $scope.addingFunding = true;
	        $scope.editFunding.errors.length = 0;
	        $.ajax({
	            url: getBaseUri() + '/fundings/funding.json',
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            type: 'POST',
	            data:  angular.toJson($scope.editFunding),
	            success: function(data) {
	                if (data.errors.length == 0){
	                    $.colorbox.close();
	                } else {
	                    $scope.editFunding = data;
	                    if($scope.editFunding.externalIdentifiers.length == 0) {
	                        $scope.addFundingExternalIdentifier();
	                    }
	                    commonSrvc.copyErrorsLeft($scope.editFunding, data);
	                }
	                $scope.addingFunding = false;
	                $scope.$apply();
	            }
	        }).fail(function(){
	            // something bad is happening!
	            $scope.addingFunding = false;
	            console.log("error adding fundings");
	        });
	    };

	    //Resizing window after error message is shown
	    $scope.$watch('addingFunding', function() {
	        setTimeout(
	            function(){
	                $.colorbox.resize();;
	            }, 
	            50
	        );
	     });

	    $scope.showTemplateInModal = function(templateId) {
	        $.colorbox({
	            html : $compile($('#'+templateId).html())($scope),
	            onComplete: function() {$.colorbox.resize();}
	        });
	    };

	    $scope.openImportWizardUrl = function(url) {
	        openImportWizardUrl(url);
	    };

	    $scope.bindTypeaheadForOrgs = function () {
	        var numOfResults = 100;
	        $("#fundingName").typeahead({
	            name: 'fundingName',
	            limit: numOfResults,
	            remote: {
	                replace: function () {
	                    var q = getBaseUri()+'/fundings/disambiguated/name/';
	                    if ($('#fundingName').val()) {
	                        q += encodeURIComponent($('#fundingName').val());
	                    }
	                    q += '?limit=' + numOfResults + '&funders-only=true';
	                    return q;
	                }
	            },
	            template: function (datum) {
	                var forDisplay =
	                    '<span style=\'white-space: nowrap; font-weight: bold;\'>' + datum.value+ '</span>'
	                    +'<span style=\'font-size: 80%;\'>'
	                    + ' <br />' + datum.city;
	                if(datum.region){
	                    forDisplay += ", " + datum.region;
	                }
	                if (datum.orgType != null && datum.orgType.trim() != ''){
	                    forDisplay += ", " + datum.orgType;
	                }
	                forDisplay += '</span><hr />';

	                return forDisplay;
	            }
	        });
	        $("#fundingName").bind("typeahead:selected", function(obj, datum) {
	            $scope.selectFunding(datum);
	            $scope.$apply();
	        });
	    };

	    $scope.bindTypeaheadForSubTypes = function() {
	        var numOfResults = 20;
	        $("#organizationDefinedType").typeahead({
	            name: 'organizationDefinedType',
	            limit: numOfResults,
	            remote: {
	                replace: function () {
	                    var q = getBaseUri()+'/fundings/orgDefinedSubType/';
	                    if ($('#organizationDefinedType').val()) {
	                        q += encodeURIComponent($('#organizationDefinedType').val());
	                    }
	                    q += '?limit=' + numOfResults;
	                    return q;
	                }
	            },
	            template: function (datum) {
	                var forDisplay =
	                    '<span style=\'white-space: nowrap; font-weight: bold;\'>' + datum.value + '</span><hr />';
	                return forDisplay;
	            }
	        });
	        $("#organizationDefinedType").bind("typeahead:selected", function(obj, datum){
	            $scope.selectOrgDefinedFundingSubType(datum);
	            $scope.$apply();
	        });
	    };

	    $scope.setSubTypeAsNotIndexed = function() {
	        if($scope.lastIndexedTerm != $.trim($('#organizationDefinedType').val())) {
	            console.log("value changed: " + $scope.lastIndexedTerm + " <-> " + $('#organizationDefinedType').val());
	            $scope.editFunding.organizationDefinedFundingSubType.alreadyIndexed = false;
	        }
	    };

	    $scope.selectOrgDefinedFundingSubType = function(subtype) {
	        if (subtype != undefined && subtype != null) {
	            $scope.editFunding.organizationDefinedFundingSubType.subtype.value = subtype.value;
	            $scope.editFunding.organizationDefinedFundingSubType.alreadyIndexed = true;
	            $scope.lastIndexedTerm = subtype.value;
	            $scope.unbindTypeaheadForSubTypes();
	        }
	    };

	    $scope.selectFunding = function(datum) {
	        if (datum != undefined && datum != null) {
	            $scope.editFunding.fundingName.value = datum.value;
	            if(datum.value){
	                $scope.editFunding.fundingName.errors = [];
	            }
	            $scope.editFunding.city.value = datum.city;
	            if(datum.city){
	                $scope.editFunding.city.errors = [];
	            }
	            $scope.editFunding.region.value = datum.region;

	            if(datum.country != undefined && datum.country != null) {
	                $scope.editFunding.country.value = datum.country;
	                $scope.editFunding.country.errors = [];
	            }

	            if (datum.disambiguatedFundingIdentifier != undefined && datum.disambiguatedFundingIdentifier != null) {
	                $scope.getDisambiguatedFunding(datum.disambiguatedFundingIdentifier);
	                $scope.unbindTypeaheadForOrgs();
	            }
	        }
	    };

	    $scope.getDisambiguatedFunding = function(id) {
	        $.ajax({
	            url: getBaseUri() + '/fundings/disambiguated/id/' + id,
	            dataType: 'json',
	            type: 'GET',
	            success: function(data) {
	                if (data != null) {
	                    $scope.disambiguatedFunding = data;
	                    $scope.editFunding.disambiguatedFundingSourceId = data.sourceId;
	                    $scope.editFunding.disambiguationSource = data.sourceType;
	                    $scope.$apply();
	                }
	            }
	        }).fail(function(){
	            console.log("error getDisambiguatedFunding(id)");
	        });
	    };

	    $scope.deleteFundingConfirm = function(putCode, deleteGroup) {
	        var funding = fundingSrvc.getFunding(putCode);
	        var maxSize = 100;
	        
	        $scope.deletePutCode = putCode;
	        $scope.deleteGroup = deleteGroup;
	        
	        if (funding.fundingTitle && funding.fundingTitle.title){
	            $scope.fixedTitle = funding.fundingTitle.title.value;
	        }
	        else{
	            $scope.fixedTitle = '';
	        } 

	        if($scope.fixedTitle.length > maxSize){
	            $scope.fixedTitle = $scope.fixedTitle.substring(0, maxSize) + '...';
	        }

	        $.colorbox({
	            html : $compile($('#delete-funding-modal').html())($scope),
	            onComplete: function() {$.colorbox.resize();}
	        });
	    };

	    $scope.deleteFundingByPut = function(putCode, deleteGroup) {
	        if (deleteGroup){
	            fundingSrvc.deleteGroupFunding(putCode);
	        }
	        else {
	            fundingSrvc.deleteFunding(putCode);
	        }
	        $.colorbox.close();
	    };

	    //init
	    fundingSrvc.getFundings('fundings/fundingIds.json');

	    $scope.closeModal = function() {
	        $.colorbox.close();
	    };

	    // Add privacy for new fundings
	    $scope.setAddFundingPrivacy = function(priv, $event) {
	        $event.preventDefault();
	        $scope.editFunding.visibility.visibility = priv;
	    };

	    // Update privacy of an existing funding
	    $scope.setPrivacy = function(funding, priv, $event) {
	        $event.preventDefault();
	        funding.visibility.visibility = priv;
	        fundingSrvc.updateProfileFunding(funding);
	    };

	    $scope.removeDisambiguatedFunding = function() {
	        $scope.bindTypeaheadForOrgs();
	        if ($scope.disambiguatedFunding != undefined) {
	            delete $scope.disambiguatedFunding;
	        }
	        if ($scope.editFunding != undefined && $scope.editFunding.disambiguatedFundingSourceId != undefined) {
	            delete $scope.editFunding.disambiguatedFundingSourceId;
	        }
	    };

	    $scope.isValidClass = function (cur) {
	        var valid = true;

	        if (cur === undefined){
	            return '';
	        } 
	        if (cur.required && (cur.value == null || cur.value.trim() == '')) {
	            valid = false;
	        }
	        if (cur.errors !== undefined && cur.errors.length > 0) {
	            valid = false;
	        }

	        return valid ? '' : 'text-error';
	    };

	    // Server validations
	    $scope.serverValidate = function (relativePath) {
	        $.ajax({
	            url: getBaseUri() + '/' + relativePath,
	            type: 'POST',
	            data:  angular.toJson($scope.editFunding),
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                commonSrvc.copyErrorsLeft($scope.editFunding, data);
	                $scope.$apply();
	            }
	        }).fail(function() {
	            // something bad is happening!
	            console.log("FundingCtrl.serverValidate() error");
	        });
	    };

	    $scope.unbindTypeaheadForOrgs = function () {
	        $('#fundingName').typeahead('destroy');
	    };

	    $scope.unbindTypeaheadForSubTypes = function () {
	        $('#organizationDefinedType').typeahead('destroy');
	    };

	    $scope.addFundingExternalIdentifier = function () {
	        $scope.editFunding.externalIdentifiers.push({type: {value: ""}, value: {value: ""}, url: {value: ""}, relationship: {value: "self"} });
	    };

	    $scope.deleteFundingExternalIdentifier = function(obj) {
	        var index = $scope.editFunding.externalIdentifiers.indexOf(obj);
	        $scope.editFunding.externalIdentifiers.splice(index,1);
	    };

	    $scope.toggleTranslatedTitleModal = function(){
	        $scope.editTranslatedTitle = !$scope.editTranslatedTitle;
	        $('#translatedTitle').toggle();
	        $.colorbox.resize();
	    };
	    $scope.renderTranslatedTitleInfo = function(funding) {
	        var info = null;
	        if(funding != null && funding.fundingTitle != null && funding.fundingTitle.translatedTitle != null) {
	            info = funding.fundingTitle.translatedTitle.content + ' - ' + funding.fundingTitle.translatedTitle.languageName;
	        }
	        return info;
	    };

	    $scope.typeChanged = function() {
	        var selectedType = $scope.editFunding.fundingType.value;
	        switch (selectedType){
	        case 'award':
	            $("#funding-ext-ids-title").text(om.get("funding.add.external_id.title.award"));
	            $("#funding-ext-ids-value-label").text(om.get("funding.add.external_id.value.label.award"));
	            $("#funding-ext-ids-value-input").attr("placeholder", om.get("funding.add.external_id.value.placeholder.award"));
	            $("#funding-ext-ids-url-label").text(om.get("funding.add.external_id.url.label.award"));
	            $("#funding-ext-ids-url-input").attr("placeholder", om.get("funding.add.external_id.url.placeholder.award"));
	            break;
	        case 'contract':
	            $("#funding-ext-ids-title").text(om.get("funding.add.external_id.title.contract"));
	            $("#funding-ext-ids-value-label").text(om.get("funding.add.external_id.value.label.contract"));
	            $("#funding-ext-ids-value-input").attr("placeholder", om.get("funding.add.external_id.value.placeholder.contract"));
	            $("#funding-ext-ids-url-label").text(om.get("funding.add.external_id.url.label.contract"));
	            $("#funding-ext-ids-url-input").attr("placeholder", om.get("funding.add.external_id.url.placeholder.contract"));
	            break;
	        case 'grant':
	            $("#funding-ext-ids-title").text(om.get("funding.add.external_id.title.grant"));
	            $("#funding-ext-ids-value-label").text(om.get("funding.add.external_id.value.label.grant"));
	            $("#funding-ext-ids-value-input").attr("placeholder", om.get("funding.add.external_id.value.placeholder.grant"));
	            $("#funding-ext-ids-url-label").text(om.get("funding.add.external_id.url.label.grant"));
	            $("#funding-ext-ids-url-input").attr("placeholder", om.get("funding.add.external_id.url.placeholder.grant"));
	            break;
	        case 'salary-award':
	            $("#funding-ext-ids-value-label").text(om.get("funding.add.external_id.value.label.award"));
	            $("#funding-ext-ids-value-input").attr("placeholder", om.get("funding.add.external_id.value.placeholder.award"));
	            $("#funding-ext-ids-url-label").text(om.get("funding.add.external_id.url.label.award"));
	            $("#funding-ext-ids-url-input").attr("placeholder", om.get("funding.add.external_id.url.placeholder.award"));
	            $("#funding-ext-ids-title").text(om.get("funding.add.external_id.title.award"));
	            break;
	        default:
	            $("#funding-ext-ids-title").text(om.get("funding.add.external_id.title.grant"));
	            $("#funding-ext-ids-value-label").text(om.get("funding.add.external_id.value.label.grant"));
	            $("#funding-ext-ids-value-input").attr("placeholder", om.get("funding.add.external_id.value.placeholder.grant"));
	            $("#funding-ext-ids-url-label").text(om.get("funding.add.external_id.url.label.grant"));
	            $("#funding-ext-ids-url-input").attr("placeholder", om.get("funding.add.external_id.url.placeholder.grant"));
	            break;
	        }
	    };

	    $scope.openEditFunding = function(putCode) {
	        fundingSrvc.getEditable(putCode, function(bestMatch) {
	            $scope.addFundingModal(bestMatch);
	        });
	    };    
	    
	    $scope.showFundingImportWizard =  function() {
	        $scope.fundingImportWizard = !$scope.fundingImportWizard;               
	    };
	    
	    $scope.toggleWizardDesc = function(id){
	        $scope.wizardDescExpanded[id] = !$scope.wizardDescExpanded[id];
	    }
	    
	    $scope.showTooltip = function (key){
	        $scope.showElement[key] = true;
	    };

	    $scope.hideTooltip = function (key){
	        $scope.showElement[key] = false;
	    };
	    
	    $scope.userIsSource = function(funding) {
	        if (funding.source == orcidVar.orcidId){
	            return true;
	        }
	        return false;
	    };
	    
	    $scope.hideURLPopOver = function(id){
	        $scope.displayURLPopOver[id] = false;
	    };
	    
	    $scope.showURLPopOver = function(id){
	        $scope.displayURLPopOver[id] = true;
	    };
	    
	    $scope.moreInfoActive = function(groupID){
	        if ($scope.moreInfo[groupID] == true || $scope.moreInfo[groupID] != null) {
	            return 'truncate-anchor';
	        }
	    }
	    
	}]);

/***/ },
/* 7 */
/***/ function(module, exports) {

	angular.module('orcidApp').controller(
	    'KeywordsCtrl', 
	    [
	    '$scope', 
	    '$rootScope', 
	    '$compile', 
	    'bioBulkSrvc', 
	    'commonSrvc', 
	    'emailSrvc', 
	    'initialConfigService',
	    'utilsService',  
	    function ($scope, $rootScope, $compile, bioBulkSrvc, commonSrvc, emailSrvc, initialConfigService, utilsService) {
	    bioBulkSrvc.initScope($scope);
	    $scope.commonSrvc = commonSrvc;
	    $scope.defaultVisibility = null;
	    $scope.emailSrvc = emailSrvc;
	    $scope.keywordsForm = null;
	    $scope.modal = false;
	    $scope.newElementDefaultVisibility = null;
	    $scope.orcidId = orcidVar.orcidId; //Do not remove
	    $scope.privacyHelp = false;
	    $scope.scrollTop = 0;    
	    $scope.showEdit = false;
	    $scope.showElement = {};
	    
	    /////////////////////// Begin of verified email logic for work
	    var configuration = initialConfigService.getInitialConfiguration();
	    var emailVerified = false;
	    var emails = {};
	    var utilsService = utilsService;


	    var showEmailVerificationModal = function(){
	        $rootScope.$broadcast('emailVerifiedObj', {flag: emailVerified, emails: emails});
	    };
	    
	    $scope.emailSrvc.getEmails(
	        function(data) {
	            emails = data.emails;
	            data.emails.forEach(
	                function(element){
	                    if(element.verified == true) {
	                        emailVerified = true;
	                    }
	                }
	            );
	        }
	    );
	    /////////////////////// End of verified email logic for work

	    $scope.openEdit = function() {
	        $scope.addNew();
	        $scope.showEdit = true;
	    };

	    $scope.close = function() {
	        $scope.getKeywordsForm();
	        $scope.showEdit = false;
	    };

	    $scope.updateDisplayIndex = function(){
	        for (var idx in $scope.keywordsForm.keywords)
	            $scope.keywordsForm.keywords[idx]['displayIndex'] = $scope.keywordsForm.keywords.length - idx;
	    };
	    
	    $scope.addNew = function() {
	        $scope.keywordsForm.keywords.push({content: "", displayIndex: "1"});        
	        $scope.updateDisplayIndex();
	    };
	    
	    $scope.addNewModal = function() {                
	        var tmpObj = {"errors":[],"putCode":null,"content":"","visibility":{"errors":[],"required":true,"getRequiredMessage":null,"visibility":$scope.newElementDefaultVisibility},"displayIndex":1,"source":$scope.orcidId,"sourceName":""};
	        $scope.keywordsForm.keywords.push(tmpObj);
	        $scope.updateDisplayIndex();
	        $scope.newInput = true;
	    };

	    $scope.getKeywordsForm = function(){
	        $.ajax({
	            url: getBaseUri() + '/my-orcid/keywordsForms.json',
	            dataType: 'json',
	            success: function(data) {
	                $scope.keywordsForm = data;
	                $scope.newElementDefaultVisibility = $scope.keywordsForm.visibility.visibility;
	                //If there is at least one element, iterate over them to see if they have the same visibility, to set the default  visibility element                
	                if($scope.keywordsForm != null && $scope.keywordsForm.keywords != null && $scope.keywordsForm.keywords.length > 0) {
	                    for(var i = 0; i < $scope.keywordsForm.keywords.length; i ++) {
	                        var itemVisibility = null;
	                        if($scope.keywordsForm.keywords[i].visibility != null && $scope.keywordsForm.keywords[i].visibility.visibility) {
	                            itemVisibility = $scope.keywordsForm.keywords[i].visibility.visibility;
	                        }
	                        /**
	                         * The default visibility should be set only when all elements have the same visibility, so, we should follow this rules: 
	                         * 
	                         * Rules: 
	                         * - If the default visibility is null:
	                         *  - If the item visibility is not null, set the default visibility to the item visibility
	                         * - If the default visibility is not null:
	                         *  - If the default visibility is not equals to the item visibility, set the default visibility to null and stop iterating 
	                         * */
	                        if($scope.defaultVisibility == null) {
	                            if(itemVisibility != null) {
	                                $scope.defaultVisibility = itemVisibility;
	                            }                           
	                        } else {
	                            if(itemVisibility != null) {
	                                if($scope.defaultVisibility != itemVisibility) {
	                                    $scope.defaultVisibility = null;
	                                    break;
	                                }
	                            } else {
	                                $scope.defaultVisibility = null;
	                                break;
	                            }
	                        }                       
	                    }
	                } else {
	                    $scope.defaultVisibility = $scope.keywordsForm.visibility.visibility;
	                }
	                                                                
	                $scope.$apply();
	            }
	        }).fail(function(){
	            // something bad is happening!
	            console.log("error fetching keywords");
	        });
	    };

	    $scope.deleteKeyword = function(keyword){
	        var keywords = $scope.keywordsForm.keywords;
	        var len = keywords.length;
	        while (len--) {
	            if (keywords[len] == keyword){
	                keywords.splice(len,1);
	            }
	        }
	    };

	    $scope.setKeywordsForm = function(){        
	        $scope.keywordsForm.visibility = null;        
	        $.ajax({
	            url: getBaseUri() + '/my-orcid/keywordsForms.json',
	            type: 'POST',
	            data:  angular.toJson($scope.keywordsForm),
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                $scope.keywordsForm = data;
	                
	                if(data.errors.length == 0){
	                    $scope.close();
	                    $.colorbox.close();
	                }                   
	                $scope.$apply();
	            }
	        }).fail(function() {
	            // something bad is happening!
	            console.log("KeywordsCtrl.serverValidate() error");
	        });
	    };

	    $scope.setPrivacy = function(priv, $event) {
	        $event.preventDefault();
	        $scope.defaultVisibility = priv;
	    };
	    
	    $scope.setPrivacyModal = function(priv, $event, keyword) {        
	        $event.preventDefault();
	        
	        var keywords = $scope.keywordsForm.keywords;        
	        var len = keywords.length;
	        
	        while (len--) {
	            if (keywords[len] == keyword){
	                keywords[len].visibility.visibility = priv;
	                $scope.keywordsForm.keywords = keywords;
	            }
	        }
	    };
	    
	    $scope.openEditModal = function(){
	        if(emailVerified === true || configuration.showModalManualEditVerificationEnabled == false){
	            $scope.bulkEditShow = false;
	            $scope.modal = true;        
	            $.colorbox({
	                scrolling: true,
	                html: $compile($('#edit-keyword').html())($scope),
	                onLoad: function() {
	                    $('#cboxClose').remove();
	                    if ($scope.keywordsForm.keywords.length == 0){
	                        $scope.addNewModal();
	                        $scope.newInput = true;
	                        
	                    } else{
	                        $scope.updateDisplayIndex();
	                    }
	                },
	                width: utilsService.formColorBoxResize(),
	                onComplete: function() {
	                        
	                },
	                onClosed: function() {
	                    $scope.getKeywordsForm();
	                }            
	            });
	            $.colorbox.resize();
	        }else{
	            showEmailVerificationModal();
	        }
	    }
	    
	    $scope.closeEditModal = function(){        
	        $.colorbox.close();
	    }
	    
	    $scope.swapUp = function(index){
	        if (index > 0) {
	            var temp = $scope.keywordsForm.keywords[index];
	            var tempDisplayIndex = $scope.keywordsForm.keywords[index]['displayIndex'];
	            temp['displayIndex'] = $scope.keywordsForm.keywords[index - 1]['displayIndex']
	            $scope.keywordsForm.keywords[index] = $scope.keywordsForm.keywords[index - 1];
	            $scope.keywordsForm.keywords[index]['displayIndex'] = tempDisplayIndex;
	            $scope.keywordsForm.keywords[index - 1] = temp;
	        }
	    };

	    $scope.swapDown = function(index){
	        if (index < $scope.keywordsForm.keywords.length - 1) {
	            var temp = $scope.keywordsForm.keywords[index];
	            var tempDisplayIndex = $scope.keywordsForm.keywords[index]['displayIndex'];
	            temp['displayIndex'] = $scope.keywordsForm.keywords[index + 1]['displayIndex']
	            $scope.keywordsForm.keywords[index] = $scope.keywordsForm.keywords[index + 1];
	            $scope.keywordsForm.keywords[index]['displayIndex'] = tempDisplayIndex;
	            $scope.keywordsForm.keywords[index + 1] = temp;
	        }
	    };
	    
	    $scope.setBulkGroupPrivacy = function(priv) {
	        for (var idx in $scope.keywordsForm.keywords){
	            $scope.keywordsForm.keywords[idx].visibility.visibility = priv;        
	        }
	    };
	    
	    $scope.getKeywordsForm();
	}]);

/***/ },
/* 8 */
/***/ function(module, exports) {

	angular.module('orcidApp').controller('NameCtrl', ['$scope', '$compile',function NameCtrl($scope, $compile) {
	    $scope.nameForm = null;
	    $scope.privacyHelp = false;
	    $scope.showEdit = false;

	    $scope.toggleEdit = function() {
	        $scope.showEdit = !$scope.showEdit;
	    };

	    $scope.close = function() {
	        $scope.getNameForm();
	        $scope.showEdit = false;
	    };

	    $scope.getNameForm = function(){
	        $.ajax({
	            url: getBaseUri() + '/account/nameForm.json',
	            dataType: 'json',
	            success: function(data) {
	                $scope.nameForm = data;
	                $scope.$apply();
	            }
	        }).fail(function(){
	            // something bad is happening!
	            console.log("error fetching otherNames");
	        });
	    };

	    $scope.setNameForm = function(){
	        $.ajax({
	            url: getBaseUri() + '/account/nameForm.json',
	            type: 'POST',
	            data:  angular.toJson($scope.nameForm),
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                $scope.nameForm = data;
	                if(data.errors.length == 0)
	                   $scope.close();
	                $scope.$apply();
	            }
	        }).fail(function() {
	            // something bad is happening!
	            console.log("OtherNames.serverValidate() error");
	        });
	    };

	    $scope.setNamesVisibility = function(priv, $event) {
	        $event.preventDefault();
	        $scope.nameForm.namesVisibility.visibility = priv;
	    };

	    $scope.getNameForm();
	}]);

/***/ },
/* 9 */
/***/ function(module, exports) {

	// Controller for notifications
	angular.module('orcidApp').controller('NotificationsCtrl',['$scope', '$compile', 'notificationsSrvc', function ($scope, $compile, notificationsSrvc){
	    $scope.displayBody = {};
	    notificationsSrvc.displayBody = {};    
	    $scope.notificationsSrvc = notificationsSrvc;
	    $scope.notifications = notificationsSrvc.notifications;
	    $scope.showMore = notificationsSrvc.showMore;
	    $scope.areMore = notificationsSrvc.areMore;
	    $scope.archive = notificationsSrvc.archive;
	    $scope.getNotifications = notificationsSrvc.getNotifications;
	    $scope.reloadNotifications = notificationsSrvc.reloadNotifications;
	    $scope.notificationsSrvc = notificationsSrvc;
	    $scope.bulkChecked = notificationsSrvc.bulkChecked;
	    $scope.bulkArchiveMap = notificationsSrvc.bulkArchiveMap;
	    $scope.toggleDisplayBody = function (notificationId) {
	        $scope.displayBody[notificationId] = !$scope.displayBody[notificationId];        
	        notificationsSrvc.displayBody[notificationId] = $scope.displayBody[notificationId]; 
	        notificationsSrvc.flagAsRead(notificationId);
	        iframeResize(notificationId);
	    };    
	    
	    $scope.$watch(function () { return notificationsSrvc.bulkChecked }, function (newVal, oldVal) {
	        if (typeof newVal !== 'undefined') {
	            $scope.bulkChecked = notificationsSrvc.bulkChecked;
	        }
	    });

	    notificationsSrvc.getNotifications();    
	    notificationsSrvc.getNotificationAlerts();
	        
	}]);

/***/ },
/* 10 */
/***/ function(module, exports) {

	angular.module('orcidApp').controller('OtherNamesCtrl',['$scope', '$compile', 'bioBulkSrvc', 'commonSrvc', 'utilsService', function ($scope, $compile ,bioBulkSrvc, commonSrvc, utilsService) {
	 
	    bioBulkSrvc.initScope($scope);  
	 
	    $scope.commonSrvc = commonSrvc;
	    $scope.defaultVisibility = null;
	    $scope.newElementDefaultVisibility = null;
	    $scope.orcidId = orcidVar.orcidId; 
	    $scope.otherNamesForm = null;
	    $scope.privacyHelp = false;
	    $scope.scrollTop = 0;
	    $scope.showEdit = false;
	    $scope.showElement = {};

	    var utilsService = utilsService;
	        
	    $scope.openEdit = function() {
	        $scope.addNew();
	        $scope.showEdit = true;
	    };

	    $scope.close = function() {
	        $scope.getOtherNamesForm();
	        $scope.showEdit = false;
	    };

	    $scope.updateDisplayIndex = function(){
	        for (var idx in $scope.otherNamesForm.otherNames) {         
	            $scope.otherNamesForm.otherNames[idx]['displayIndex'] = $scope.otherNamesForm.otherNames.length - idx;
	        }
	    };
	    
	    $scope.addNew = function() {
	        $scope.otherNamesForm.otherNames.push({ url: "", urlName: "", displayIndex: "1" });
	        $scope.updateDisplayIndex();            
	    };
	    
	    $scope.addNewModal = function() {               
	        var tmpObj = {
	            "errors":[],
	            "url":null,
	            "urlName":null,
	            "putCode":null,
	            "visibility":{
	                "errors":[],
	                "required":true,
	                "getRequiredMessage":null,
	                "visibility":$scope.newElementDefaultVisibility
	            },
	            "source":$scope.orcidId,
	            "sourceName":"", 
	            "displayIndex": 1
	        };        
	        $scope.otherNamesForm.otherNames.push(tmpObj);        
	        $scope.updateDisplayIndex();          
	        $scope.newInput = true;
	    };

	    $scope.getOtherNamesForm = function(){
	        $.ajax({
	            url: getBaseUri() + '/my-orcid/otherNamesForms.json',
	            dataType: 'json',
	            success: function(data) {
	                var itemVisibility;          
	                $scope.otherNamesForm = data;   
	                $scope.newElementDefaultVisibility = $scope.otherNamesForm.visibility.visibility;
	                //If there is at least one element, iterate over them to see if they have the same visibility, to set the default  visibility element
	                if($scope.otherNamesForm != null && $scope.otherNamesForm.otherNames != null && $scope.otherNamesForm.otherNames.length > 0) {
	                    for(var i = 0; i < $scope.otherNamesForm.otherNames.length; i ++) {
	                        itemVisibility = null;
	                        
	                        if($scope.otherNamesForm.otherNames[i].visibility != null && $scope.otherNamesForm.otherNames[i].visibility.visibility) {
	                            itemVisibility = $scope.otherNamesForm.otherNames[i].visibility.visibility;
	                        }
	                        /**
	                         * The default visibility should be set only when all elements have the same visibility, so, we should follow this rules: 
	                         * 
	                         * Rules: 
	                         * - If the default visibility is null:
	                         *  - If the item visibility is not null, set the default visibility to the item visibility
	                         * - If the default visibility is not null:
	                         *  - If the default visibility is not equals to the item visibility, set the default visibility to null and stop iterating 
	                         * */
	                        if($scope.defaultVisibility == null) {
	                            if(itemVisibility != null) {
	                                $scope.defaultVisibility = itemVisibility;
	                            }                           
	                        } else {
	                            if(itemVisibility != null) {
	                                if($scope.defaultVisibility != itemVisibility) {
	                                    $scope.defaultVisibility = null;
	                                    break;
	                                }
	                            } else {
	                                $scope.defaultVisibility = null;
	                                break;
	                            }
	                        }                       
	                    }
	                } else {
	                    $scope.defaultVisibility = $scope.otherNamesForm.visibility.visibility;
	                }               
	                
	                $scope.$apply();                                
	            }
	        }).fail(function(e){
	            // something bad is happening!
	            console.log("error fetching otherNames");
	            logAjaxError(e);
	        });
	    };

	    $scope.deleteOtherName = function(otherName){
	        var otherNames = $scope.otherNamesForm.otherNames;
	        var len = otherNames.length;
	        while (len--) {            
	            if (otherNames[len] == otherName){                
	                otherNames.splice(len,1);
	            }
	        }        
	    };

	    $scope.setOtherNamesForm = function(){
	        $scope.otherNamesForm.visibility = null;
	        $.ajax({
	            url: getBaseUri() + '/my-orcid/otherNamesForms.json',
	            type: 'POST',
	            data:  angular.toJson($scope.otherNamesForm),
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {                
	                $scope.otherNamesForm = data;
	                if(data.errors.length == 0){
	                    $scope.close();                 
	                }
	                $.colorbox.close(); 
	                $scope.$apply();                
	            }
	        }).fail(function() {
	            // something bad is happening!
	            console.log("OtherNames.serverValidate() error");
	        });
	    };

	    $scope.setPrivacy = function(priv, $event) {
	        $event.preventDefault();
	        $scope.defaultVisibility = priv;
	    };
	    
	    $scope.setPrivacyModal = function(priv, $event, otherName) {
	        $event.preventDefault();
	        var otherNames = $scope.otherNamesForm.otherNames;        
	        var len = otherNames.length;
	        
	        while (len--) {
	            if (otherNames[len] == otherName){
	                otherNames[len].visibility.visibility = priv;
	                $scope.otherNamesForm.otherNames = otherNames;
	            }
	        }
	    };
	    
	    $scope.openEditModal = function(){
	        $scope.bulkEditShow = false;        
	        $.colorbox({
	            scrolling: true,
	            html: $compile($('#edit-aka').html())($scope),
	            onLoad: function() {
	                $('#cboxClose').remove();
	                if ($scope.otherNamesForm.otherNames.length == 0){
	                    $scope.addNewModal();
	                    $scope.newInput = true;
	                }   else {
	                    $scope.updateDisplayIndex();
	                } 
	            },
	            width: utilsService.formColorBoxResize(),
	            onComplete: function() {
	                    
	            },
	            onClosed: function() {
	                $scope.getOtherNamesForm();
	            }            
	        });
	        $.colorbox.resize();
	    }
	    
	    $scope.closeEditModal = function(){     
	        $.colorbox.close();     
	    }
	    
	    $scope.swapUp = function(index){
	        var temp;
	        var tempDisplayIndex;
	        if (index > 0) {
	            temp = $scope.otherNamesForm.otherNames[index];
	            tempDisplayIndex =$scope.otherNamesForm.otherNames[index]['displayIndex'];
	            temp['displayIndex'] = $scope.otherNamesForm.otherNames[index - 1]['displayIndex']
	            $scope.otherNamesForm.otherNames[index] = $scope.otherNamesForm.otherNames[index - 1];
	            $scope.otherNamesForm.otherNames[index]['displayIndex'] = tempDisplayIndex;
	            $scope.otherNamesForm.otherNames[index - 1] = temp;
	        }
	    };

	    $scope.swapDown = function(index){
	        var temp;
	        var tempDisplayIndex;
	        if (index < $scope.otherNamesForm.otherNames.length - 1) {
	            temp = $scope.otherNamesForm.otherNames[index];
	            tempDisplayIndex = $scope.otherNamesForm.otherNames[index]['displayIndex'];
	            temp['displayIndex'] = $scope.otherNamesForm.otherNames[index + 1]['displayIndex']
	            $scope.otherNamesForm.otherNames[index] = $scope.otherNamesForm.otherNames[index + 1];
	            $scope.otherNamesForm.otherNames[index]['displayIndex'] = tempDisplayIndex;
	            $scope.otherNamesForm.otherNames[index + 1] = temp;
	        }
	    };
	    
	    $scope.setBulkGroupPrivacy = function(priv) {
	        for (var idx in $scope.otherNamesForm.otherNames){
	            $scope.otherNamesForm.otherNames[idx].visibility.visibility = priv;    
	        }         
	    };
	           
	    $scope.getOtherNamesForm();
	}]);

/***/ },
/* 11 */
/***/ function(module, exports) {

	angular.module('orcidApp').controller('languageCtrl',['$scope', '$cookies', 'widgetSrvc', function ($scope, $cookies, widgetSrvc) {
	    var productionLangList =
	        [
	            {
	                "value": "cs",
	                "label": "čeština"
	            },
	            {
	                "value": "en",
	                "label": "English"
	            },
	            {
	                "value": 'es',
	                "label": 'Español'
	            },
	            {
	                "value": 'fr',
	                "label": 'Français'
	            },
	            {
	                "value": 'it',
	                "label": 'Italiano'
	            },
	            {
	                "value": 'ja',
	                "label": '日本語'
	            },
	            {
	                "value": 'ko',
	                "label": '한국어'
	            },
	            {
	                "value": 'pt',
	                "label": 'Português'
	            },
	            {
	                "value": 'ru',
	                "label": 'Русский'
	            },
	            {
	                "value": 'zh_CN',
	                "label": '简体中文'
	            },
	            {
	                "value": 'zh_TW',
	                "label": '繁體中文'
	            }
	        ];
	    var testingLangList =
	        [
	            {
	                "value": "cs",
	                "label": "čeština"
	            },
	            {
	                "value": "en",
	                "label": "English"
	            },
	            {
	                "value": 'es',
	                "label": 'Español'
	            },
	            {
	                "value": 'fr',
	                "label": 'Français'
	            },
	            {
	                "value": 'it',
	                "label": 'Italiano'
	            },
	            {
	                "value": 'ja',
	                "label": '日本語'
	            },
	            {
	                "value": 'ko',
	                "label": '한국어'
	            },
	            {
	                "value": 'lr',
	                "label": 'lr'
	            },
	            {
	                "value": 'pt',
	                "label": 'Português'
	            },
	            {
	                "value": 'rl',
	                "label": 'rl'
	            },
	            {
	                "value": 'ru',
	                "label": 'Русский'
	            },
	            {
	                "value": 'xx',
	                "label": 'X'
	            },
	            {
	                "value": 'zh_CN',
	                "label": '简体中文'
	            },
	            {
	                "value": 'zh_TW',
	                "label": '繁體中文'
	            }
	        ];
	    
	    $scope.widgetSrvc = widgetSrvc;

	    if (location == parent.location && window.location.hostname.toLowerCase() != "orcid.org"){
	        $scope.languages = testingLangList;
	    }
	    else{
	        $scope.languages = productionLangList;
	    }

	    //Load Language that is set in the cookie or set default language to english
	    $scope.getCurrentLanguage = function(){
	        $scope.language = $scope.languages[0]; //Default
	        typeof($cookies.get('locale_v3')) !== 'undefined' ? locale_v3 = $cookies.get('locale_v3') : locale_v3 = "en"; //If cookie exists we get the language value from it        
	        angular.forEach($scope.languages, function(value, key){ //angular.forEach doesn't support break
	            if (value.value == locale_v3){
	                $scope.language = $scope.languages[key];
	                $scope.widgetSrvc.locale = $scope.language.value; 
	            }
	        });
	    };

	    $scope.getCurrentLanguage(); //Checking for the current language value

	    $scope.selectedLanguage = function(){
	        $.ajax({
	            url: getBaseUri()+'/lang.json?lang=' + $scope.language.value,
	            type: 'GET',
	            dataType: 'json',
	            success: function(data){
	                angular.forEach($scope.languages, function(value, key){
	                    var params;
	                    if(value.value == data.locale){
	                        $scope.language = $scope.languages[key];                        
	                        $scope.widgetSrvc.setLocale($scope.language.value);
	                        //In case some parameters were sent via URL
	                        params = window.location.href.split("?")[1];
	                        if (typeof params != 'undefined'){
	                            params = params.split("&");
	                            //Removing language parameter (lang=[code]) if it exists
	                            for ( var i = 0; i < params.length; i++ ){
	                                if(params[i].indexOf("lang=") > -1){
	                                    params.splice(i, 1);    
	                                }
	                            }
	                            
	                            if ( params.length > 0 ) {                                
	                                window.location.href = window.location.href.split("?")[0] + '?' + params.join("&");
	                            } else {
	                                window.location.href = window.location.href.split("?")[0];
	                            }
	                            
	                        }else{
	                            window.location.reload(true);
	                        }
	                    }
	                });
	            }
	        }).fail(function(error) {
	            // something bad is happening!
	            console.log("Error setting up language cookie");
	        });
	    };
	    
	    
	}]);

/***/ },
/* 12 */
/***/ function(module, exports) {

	angular.module('orcidApp').controller('WebsitesCtrl', ['$scope', '$rootScope', '$compile','bioBulkSrvc', 'commonSrvc', 'emailSrvc', 'initialConfigService', 'utilsService', function WebsitesCtrl($scope, $rootScope, $compile, bioBulkSrvc, commonSrvc, emailSrvc, initialConfigService, utilsService) {
	    bioBulkSrvc.initScope($scope);

	    $scope.commonSrvc = commonSrvc;
	    $scope.defaultVisibility = null;
	    $scope.emailSrvc = emailSrvc;
	    $scope.newElementDefaultVisibility = null;
	    $scope.orcidId = orcidVar.orcidId; //Do not remove
	    $scope.privacyHelp = false;
	    $scope.scrollTop = 0;
	    $scope.showEdit = false;
	    $scope.showElement = {};
	    $scope.websitesForm = null;
	    
	    /////////////////////// Begin of verified email logic for work
	    var configuration = initialConfigService.getInitialConfiguration();
	    var emailVerified = false;
	    var emails = {};
	    var utilsService = utilsService;

	    var showEmailVerificationModal = function(){
	        $rootScope.$broadcast('emailVerifiedObj', {flag: emailVerified, emails: emails});
	    };
	    
	    $scope.emailSrvc.getEmails(
	        function(data) {
	            emails = data.emails;
	            data.emails.forEach(
	                function(element){
	                    if(element.verified == true) {
	                        emailVerified = true;
	                    }
	                }
	            );
	        }
	    );
	    /////////////////////// End of verified email logic for work

	    $scope.openEdit = function() {
	        $scope.addNew();
	        $scope.showEdit = true;
	    };

	    $scope.close = function() {
	        $scope.getWebsitesForm();
	        $scope.showEdit = false;
	    };

	    $scope.updateDisplayIndex = function() {
	        for (var idx in $scope.websitesForm.websites)
	            $scope.websitesForm.websites[idx]['displayIndex'] = $scope.websitesForm.websites.length - idx;
	    };
	    
	    $scope.addNew = function() {
	        $scope.websitesForm.websites.push({ url: "", urlName: "", displayIndex: "1" });
	        $scope.updateDisplayIndex();
	    };
	    
	    $scope.addNewModal = function() {         
	        var tmpObj = {"errors":[],"url":null,"urlName":null,"putCode":null,"visibility":{"errors":[],"required":true,"getRequiredMessage":null,"visibility":$scope.newElementDefaultVisibility},"source":$scope.orcidId,"sourceName":"", "displayIndex": 1};        
	        $scope.websitesForm.websites.push(tmpObj);
	        $scope.updateDisplayIndex();
	        $scope.newInput = true; 
	    };

	    $scope.getWebsitesForm = function(){
	        $.ajax({
	            url: getBaseUri() + '/my-orcid/websitesForms.json',
	            dataType: 'json',
	            success: function(data) {
	                $scope.websitesForm = data;
	                $scope.newElementDefaultVisibility = $scope.websitesForm.visibility.visibility;
	                var websites = $scope.websitesForm.websites;
	                var len = websites.length;
	                //Iterate over all elements to:
	                // -> see if they have the same visibility, to set the default visibility element
	                // -> set the default protocol when needed
	                if(len > 0) {
	                    while (len--) {
	                        if(websites[len].url != null) {
	                            if (!websites[len].url.toLowerCase().startsWith('http')) {
	                                websites[len].url = 'http://' + websites[len].url;
	                            }                            
	                        }     
	                        
	                        var itemVisibility = null;
	                        if(websites[len].visibility != null && websites[len].visibility.visibility) {
	                            itemVisibility = websites[len].visibility.visibility;
	                        }
	                        /**
	                         * The default visibility should be set only when all elements have the same visibility, so, we should follow this rules: 
	                         * 
	                         * Rules: 
	                         * - If the default visibility is null:
	                         *  - If the item visibility is not null, set the default visibility to the item visibility
	                         * - If the default visibility is not null:
	                         *  - If the default visibility is not equals to the item visibility, set the default visibility to null and stop iterating 
	                         * */
	                        if($scope.defaultVisibility == null) {
	                            if(itemVisibility != null) {
	                                $scope.defaultVisibility = itemVisibility;
	                            }                           
	                        } else {
	                            if(itemVisibility != null) {
	                                if($scope.defaultVisibility != itemVisibility) {
	                                    $scope.defaultVisibility = null;
	                                    break;
	                                }
	                            } else {
	                                $scope.defaultVisibility = null;
	                                break;
	                            }
	                        }                        
	                    }
	                } else {
	                    $scope.defaultVisibility = $scope.websitesForm.visibility.visibility;
	                }
	                                
	                $scope.$apply();
	            }
	        }).fail(function(e){
	            // something bad is happening!
	            console.log("error fetching websites");
	            logAjaxError(e);
	        });
	    };

	    $scope.deleteWebsite = function(website){
	        var websites = $scope.websitesForm.websites;
	        var len = websites.length;
	        while (len--) {
	            if (websites[len] == website)
	                websites.splice(len,1);
	        }
	    };

	    $scope.setWebsitesForm = function(){
	        $scope.websitesForm.visibility = null;
	                
	        var websites = $scope.websitesForm.websites;
	        var len = websites.length;
	        while (len--) {
	            if (websites[len].url == null || websites[len].url.trim() == '')
	                websites.splice(len,1);
	        }
	        $.ajax({
	            url: getBaseUri() + '/my-orcid/websitesForms.json',
	            type: 'POST',
	            data:  angular.toJson($scope.websitesForm),
	            contentType: 'application/json;charset=UTF-8',
	            dataType: 'json',
	            success: function(data) {
	                $scope.websitesForm = data;
	                if(data.errors.length == 0) {
	                    $scope.close();
	                    $.colorbox.close();
	                }                    
	                $scope.$apply();
	            }
	        }).fail(function() {
	            // something bad is happening!
	            console.log("WebsiteCtrl.serverValidate() error");
	        });
	    };

	    $scope.setPrivacy = function(priv, $event) {
	        $event.preventDefault();
	        $scope.defaultVisibility = priv;
	    };
	    
	    $scope.setPrivacyModal = function(priv, $event, website) {        
	        $event.preventDefault();
	        
	        var websites = $scope.websitesForm.websites;        
	        var len = websites.length;
	        
	        while (len--) {
	            if (websites[len] == website){
	                websites[len].visibility.visibility = priv;
	                $scope.websitesForm.websites = websites;
	            }   
	        }
	    };
	    
	    $scope.showTooltip = function(elem, event){     
	        $scope.top = angular.element(event.target.parentNode).parent().prop('offsetTop');
	        $scope.left = angular.element(event.target.parentNode).parent().prop('offsetLeft');
	        $scope.$watch('scrollTop', function (value) {
	            if (elem === '-privacy'){
	                angular.element('.edit-websites .popover-help-container').css({
	                    top: -195,
	                    left: -4
	                });
	            }else{
	                angular.element('.edit-websites .popover-help-container').css({
	                    top: $scope.top - $scope.scrollTop,
	                    left: $scope.left - 5
	                });
	            }
	        });
	        $scope.showElement[elem] = true; 
	    }
	    
	    $scope.hideTooltip = function(elem){
	        $scope.showElement[elem] = false;
	    }
	        
	    $scope.openEditModal = function(){
	        console.log( configuration.showModalManualEditVerificationEnabled == false, configuration.showModalManualEditVerificationEnabled );
	        if(emailVerified === true || configuration.showModalManualEditVerificationEnabled == false){
	            $scope.bulkEditShow = false;
	            $.colorbox({
	                scrolling: true,
	                html: $compile($('#edit-websites').html())($scope),
	                onLoad: function() {
	                    $('#cboxClose').remove();
	                    if ($scope.websitesForm.websites.length == 0){
	                        $scope.addNewModal();
	                    } else {
	                        if ($scope.websitesForm.websites.length == 1){
	                            if($scope.websitesForm.websites[0].source == null){
	                                $scope.websitesForm.websites[0].source = $scope.orcidId;
	                                $scope.websitesForm.websites[0].sourceName = "";
	                            }
	                        }
	                        $scope.updateDisplayIndex();
	                    }                
	                },
	                width: utilsService.formColorBoxResize(),
	                onComplete: function() {
	                        
	                },
	                onClosed: function() {
	                    $scope.getWebsitesForm();
	                }            
	            });
	            $.colorbox.resize();
	        }else{
	            showEmailVerificationModal();
	        }
	    }
	    
	    $scope.closeEditModal = function(){
	        $.colorbox.close();
	    }

	    $scope.swapUp = function(index){
	        if (index > 0) {
	            var temp = $scope.websitesForm.websites[index];
	            var tempDisplayIndex = $scope.websitesForm.websites[index]['displayIndex'];
	            temp['displayIndex'] = $scope.websitesForm.websites[index - 1]['displayIndex']
	            $scope.websitesForm.websites[index] = $scope.websitesForm.websites[index - 1];
	            $scope.websitesForm.websites[index]['displayIndex'] = tempDisplayIndex;
	            $scope.websitesForm.websites[index - 1] = temp;
	        }
	    };

	    $scope.swapDown = function(index){
	        if (index < $scope.websitesForm.websites.length - 1) {
	            var temp = $scope.websitesForm.websites[index];
	            var tempDisplayIndex = $scope.websitesForm.websites[index]['displayIndex'];
	            temp['displayIndex'] = $scope.websitesForm.websites[index + 1]['displayIndex']
	            $scope.websitesForm.websites[index] = $scope.websitesForm.websites[index + 1];
	            $scope.websitesForm.websites[index]['displayIndex'] = tempDisplayIndex;
	            $scope.websitesForm.websites[index + 1] = temp;
	        }
	    };
	    
	    $scope.setBulkGroupPrivacy = function(priv) {
	        for (var idx in $scope.websitesForm.websites)
	            $scope.websitesForm.websites[idx].visibility.visibility = priv;        
	    };
	    
	    $scope.getWebsitesForm();
	}]);

/***/ },
/* 13 */
/***/ function(module, exports) {

	angular.module('orcidApp').controller(
	    'WorkCtrl', 
	    [
	        '$scope', 
	        '$rootScope', 
	        '$compile', 
	        '$filter', 
	        '$timeout', 
	        '$q', 
	        'actBulkSrvc', 
	        'commonSrvc', 
	        'emailSrvc', 
	        'initialConfigService', 
	        'utilsService', 
	        'worksSrvc', 
	        'workspaceSrvc',     
	        function ($scope, $rootScope, $compile, $filter, $timeout, $q, actBulkSrvc, commonSrvc, emailSrvc, initialConfigService, utilsService, worksSrvc, workspaceSrvc ) {

	            var utilsService = utilsService;

	            actBulkSrvc.initScope($scope);
	           
	            $scope.badgesRequested = {};
	            $scope.bibtexExportError = false;
	            $scope.bibtexGenerated = false;
	            $scope.bibtexParsingError = false;
	            $scope.bibtexURL = "";
	            $scope.bibtextWork = false;
	            $scope.bibtextWorkIndex = null;
	            $scope.bulkDeleteCount = 0;
	            $scope.bulkDeleteSubmit = false;
	            $scope.canReadFiles = false;
	            $scope.combiningWorks = false;
	            $scope.contentCopy = {
	                titleLabel: om.get("orcid.frontend.manual_work_form_contents.defaultTitle"),
	                titlePlaceholder: om.get("orcid.frontend.manual_work_form_contents.defaultTitlePlaceholder")
	            };
	            $scope.delCountVerify = 0;
	            $scope.displayURLPopOver = {};
	            $scope.editSources = {};
	            $scope.editTranslatedTitle = false;
	            $scope.emailSrvc = emailSrvc;
	            $scope.generatingBibtex = false;
	            $scope.geoArea = ['All'];
	            $scope.moreInfo = {};
	            $scope.moreInfoOpen = false;
	            $scope.noLinkFlag = true;
	            $scope.privacyHelp = {};
	            $scope.scriptsLoaded = false;
	            $scope.showBibtex = {};
	            $scope.showBibtexExport = false;
	            $scope.showBibtexImportWizard = false;
	            $scope.showElement = {};
	            $scope.sortState = new ActSortState(GroupedActivities.ABBR_WORK);
	            $scope.textFiles = [];
	            $scope.types = null;
	            $scope.wizardDescExpanded = {};
	            $scope.workImportWizard = false;
	            $scope.worksFromBibtex = null;
	            $scope.workspaceSrvc = workspaceSrvc;
	            $scope.worksSrvc = worksSrvc;
	            $scope.workType = ['All'];

	            /////////////////////// Begin of verified email logic for work
	            var configuration = initialConfigService.getInitialConfiguration();
	            var emailVerified = false;
	            var emails = {};

	            var showEmailVerificationModal = function(){
	                $rootScope.$broadcast('emailVerifiedObj', {flag: emailVerified, emails: emails});
	            };
	            
	            // Check for the various File API support.
	            if (window.File && window.FileReader && window.FileList && window.Blob) {
	                $scope.canReadFiles = true;
	            };

	            $scope.emailSrvc.getEmails(
	                function(data) {
	                    emails = data.emails;
	                    data.emails.forEach(
	                        function(element){
	                            if(element.verified == true) {
	                                emailVerified = true;
	                            }
	                        }
	                    );
	                }
	            );
	            /////////////////////// End of verified email logic for work

	            $scope.applyLabelWorkType = function() {
	                var obj = null;
	                $timeout(
	                    function() {
	                        obj = $scope.worksSrvc.getLabelMapping($scope.editWork.workCategory.value, $scope.editWork.workType.value)
	                        $scope.contentCopy = obj;
	                    }, 
	                    100
	                );
	            };

	            $scope.sort = function(key) {
	                $scope.sortState.sortBy(key);
	            };

	            $scope.toggleBulkEdit = function() {

	                if(emailVerified === true || configuration.showModalManualEditVerificationEnabled == false){
	                    if (!$scope.bulkEditShow) {
	                        $scope.bulkEditMap = {};
	                        $scope.bulkChecked = false;
	                        for (var idx in worksSrvc.groups){
	                            $scope.bulkEditMap[worksSrvc.groups[idx].getActive().putCode.value] = false;
	                        }
	                    };
	                    $scope.bulkEditShow = !$scope.bulkEditShow;
	                    $scope.showBibtexImportWizard = false;
	                    $scope.workImportWizard = false;
	                    $scope.showBibtexExport = false;
	                }else{
	                    showEmailVerificationModal();
	                }
	            };


	            $scope.bulkApply = function(func) {
	                for (var idx in worksSrvc.groups) {
	                    if ($scope.bulkEditMap[worksSrvc.groups[idx].getActive().putCode.value]){
	                        func(worksSrvc.groups[idx].getActive().putCode.value);
	                    }
	                }
	            };

	            $scope.swapbulkChangeAll = function() {
	                $scope.bulkChecked = !$scope.bulkChecked;
	                for (var idx in worksSrvc.groups){
	                    $scope.bulkEditMap[worksSrvc.groups[idx].getActive().putCode.value] = $scope.bulkChecked;
	                }
	                $scope.bulkDisplayToggle = false;
	            };

	            $scope.bulkChangeAll = function(bool) {
	                $scope.bulkChecked = bool;
	                $scope.bulkDisplayToggle = false;
	                for (var idx in worksSrvc.groups){
	                    $scope.bulkEditMap[worksSrvc.groups[idx].getActive().putCode.value] = bool;
	                }
	            };

	            $scope.setBulkGroupPrivacy = function(priv) {
	                var putCodes = new Array();
	                for (var idx in worksSrvc.groups){
	                    if ($scope.bulkEditMap[worksSrvc.groups[idx].getActive().putCode.value]){    
	                        for (var idj in worksSrvc.groups[idx].activities) {
	                            putCodes.push(worksSrvc.groups[idx].activities[idj].putCode.value);
	                            worksSrvc.groups[idx].activities[idj].visibility = priv;
	                        }
	                    }
	                }
	                worksSrvc.updateVisibility(putCodes, priv);
	            };

	            $scope.deleteBulk = function () {
	                if ($scope.delCountVerify != parseInt($scope.bulkDeleteCount)) {
	                    $scope.bulkDeleteSubmit = true;
	                    return;
	                }
	                var delPuts = new Array();
	                for (var idx in worksSrvc.groups){
	                    if ($scope.bulkEditMap[worksSrvc.groups[idx].getActive().putCode.value]){
	                        delPuts.push(worksSrvc.groups[idx].getActive().putCode.value);
	                    }
	                }
	                worksSrvc.deleteGroupWorks(delPuts);
	                $.colorbox.close();
	                $scope.bulkEditShow = false;
	            };


	            $scope.deleteBulkConfirm = function(idx) {
	                $scope.bulkDeleteCount = 0;
	                $scope.bulkDeleteSubmit = false;        
	                $scope.delCountVerify = 0;
	                for (var idx in worksSrvc.groups){
	                    if ($scope.bulkEditMap[worksSrvc.groups[idx].getActive().putCode.value]){
	                        $scope.bulkDeleteCount++;
	                    }
	                }

	                $scope.bulkDeleteFunction = $scope.deleteBulk;

	                $.colorbox({
	                    html: $compile($('#bulk-delete-modal').html())($scope)
	                });
	                $.colorbox.resize();
	            };

	            $scope.sortOtherLast = function(type) {
	                if (type.key == 'other'){    
	                    return 'ZZZZZ';
	                } 
	                return type.value;
	            };

	            $scope.loadBibtexJs = function() {
	                try {
	                    $scope.worksFromBibtex = new Array();
	                    $.each(
	                        $scope.textFiles, 
	                        function (index, bibtex) {
	                            var parsed = bibtexParse.toJSON(bibtex);
	                            if (parsed.length == 0) {
	                                throw "bibtex parse return nothing";
	                            }
	                            worksSrvc.getBlankWork(
	                                function(blankWork) {
	                                    var newWorks = new Array();
	                                    while (parsed.length > 0) {
	                                        var cur = parsed.shift();
	                                        var bibtexEntry = cur.entryType.toLowerCase();
	                                        if (bibtexEntry != 'preamble' && bibtexEntry != 'comment') {    
	                                            //Filtering @PREAMBLE and @COMMENT
	                                            newWorks.push( populateWorkAjaxForm( cur,JSON.parse( JSON.stringify(blankWork) ) ) );
	                                        }
	                                    };
	                                    worksSrvc.worksValidate(
	                                        newWorks, 
	                                        function(data) {
	                                            for (var i in data) {                           
	                                                $scope.worksFromBibtex.push(data[i]);
	                                            }
	                                            $scope.$apply();
	                                        }
	                                    );
	                                }
	                            );
	                        }
	                    );
	                    $scope.textFiles.length = 0;
	                    $scope.bibtexParsingError = false;
	                       
	                } catch (err) {
	                    $scope.bibtexParsingError = true;
	                };
	            };

	            $scope.rmWorkFromBibtex = function(work) {
	                var index = $scope.worksFromBibtex.indexOf(work);
	                
	                $scope.worksFromBibtex.splice(index, 1);
	            };

	            $scope.editWorkFromBibtex = function(work) {
	                $scope.bibtextWork = true;
	                $scope.bibtextWorkIndex = $scope.worksFromBibtex.indexOf(work);
	                
	                $scope.addWorkModal($scope.worksFromBibtex[$scope.bibtextWorkIndex]);        
	            };
	            
	            $scope.addWorkFromBibtex = function(work) {
	                $scope.bibtextWork = true;              
	                $scope.bibtextWorkIndex = $scope.worksFromBibtex.indexOf(work);     
	                $scope.editWork = $scope.worksFromBibtex[$scope.bibtextWorkIndex];
	                
	                $scope.putWork();        
	            };
	    
	            $scope.saveAllFromBibtex = function(){
	                var warksToSave =  new Array();
	                angular.forEach($scope.worksFromBibtex, function( work, key ) {
	                    if (work.errors.length == 0){
	                        warksToSave.push(work);
	                    } 
	                });
	                var numToSave = warksToSave.length;
	                angular.forEach( warksToSave, function( work, key ) {
	                    worksSrvc.putWork(work,function(data) {
	                        index = $scope.worksFromBibtex.indexOf(work);
	                        $scope.worksFromBibtex.splice(index, 1);
	                        $scope.$apply();
	                        numToSave--;
	                        if (numToSave == 0){
	                            $scope.worksSrvc.loadAbbrWorks(worksSrvc.constants.access_type.USER);
	                        }
	                    });
	                });
	            };

	            $scope.openBibTextWizard = function () {
	                if(emailVerified === true || configuration.showModalManualEditVerificationEnabled == false){
	                    $scope.bibtexParsingError = false;
	                    $scope.bulkEditShow = false;
	                    $scope.showBibtexExport = false;
	                    $scope.showBibtexImportWizard = !($scope.showBibtexImportWizard);
	                    $scope.workImportWizard = false;
	                    $scope.worksFromBibtex = null;
	                }else{
	                    showEmailVerificationModal();
	                }
	            };

	            $scope.bibtextCancel = function(){
	                $scope.worksFromBibtex = null;
	            };    

	            $scope.toggleClickPrivacyHelp = function(key) {
	                if (!document.documentElement.className.contains('no-touch')){
	                    $scope.privacyHelp[key]=!$scope.privacyHelp[key];
	                }
	            };

	            $scope.addExternalIdentifier = function () {
	                $scope.editWork.workExternalIdentifiers.push({workExternalIdentifierId: {value: ""}, workExternalIdentifierType: {value: ""}, relationship: {value: "self"}, url: {value: ""}});
	            };

	            $scope.deleteExternalIdentifier = function(obj) {
	                var index = $scope.editWork.workExternalIdentifiers.indexOf(obj);
	                
	                $scope.editWork.workExternalIdentifiers.splice(index,1);
	            };

	            $scope.deleteContributor = function(obj) {
	                var index = $scope.editWork.contributors.indexOf(obj);
	                
	                $scope.editWork.contributors.splice(index,1);
	            };

	            $scope.userIsSource = function(work) {
	                if (work.source == orcidVar.orcidId){
	                    return true;
	                }
	                return false;
	            };

	            $scope.hasCombineableEIs = function(work) {
	                if (work.workExternalIdentifiers != null){
	                    for (var idx in work.workExternalIdentifiers){
	                        if (work.workExternalIdentifiers[idx].workExternalIdentifierType.value != 'issn'){
	                            return true;
	                        }
	                    }
	                }
	                return false;
	            };

	            $scope.canBeCombined = function(work) {
	                if ($scope.userIsSource(work)){
	                    return true;
	                }
	                return $scope.hasCombineableEIs(work);
	            };

	            $scope.validCombineSel = function(selectedWork,work) {
	                if ($scope.hasCombineableEIs(selectedWork)){
	                    return $scope.userIsSource(work) || $scope.hasCombineableEIs(work);
	                }
	                else{
	                    return $scope.hasCombineableEIs(work);
	                }
	            };


	            $scope.combined = function(work1, work2) {
	                // no duplicate request;
	                var putWork;
	                if ($scope.combiningWorks){
	                    return;
	                }
	                $scope.combiningWorks = true;
	                
	                if ($scope.userIsSource(work1)) {
	                    putWork = worksSrvc.copyEIs(work2, work1);
	                } else if ($scope.userIsSource(work2)) {
	                    putWork = worksSrvc.copyEIs(work1, work2);
	                } else {
	                    putWork = worksSrvc.createNew(work1);
	                    putWork = worksSrvc.copyEIs(work1, work2);
	                }
	                worksSrvc.putWork(
	                    putWork,
	                    function(data){
	                        $scope.combiningWorks = false;
	                        $scope.closeModal();
	                    },
	                    function() {
	                        $scope.combiningWorks = false;
	                    }
	                );
	            };

	            $scope.showCombineMatches = function( work1 ) {
	                $scope.combineWork = work1;
	                $.colorbox({
	                    scrolling: true,
	                    html: $compile($('#combine-work-template').html())($scope),
	                    onLoad: function() {$('#cboxClose').remove();},
	                    // start the colorbox off with the correct width
	                    width: utilsService.formColorBoxResize(),
	                    onComplete: function() {$.colorbox.resize();},
	                    onClosed: function() {
	                        $scope.closeAllMoreInfo();
	                        $scope.worksSrvc.loadAbbrWorks(worksSrvc.constants.access_type.USER);
	                    }
	                });
	                return false;
	            };

	            $scope.showAddWorkModal = function(){
	                $scope.editTranslatedTitle = false;
	                $.colorbox({
	                    scrolling: true,
	                    html: $compile($('#add-work-modal').html())($scope),
	                    onLoad: function() {$('#cboxClose').remove();},
	                    // start the colorbox off with the correct width
	                    width: utilsService.formColorBoxResize(),
	                    onComplete: function() {
	                        //resize to insure content fits
	                    },
	                    onClosed: function() {
	                        $scope.closeAllMoreInfo();
	                        $scope.worksSrvc.loadAbbrWorks(worksSrvc.constants.access_type.USER);
	                    }
	                });
	            };

	            $scope.toggleTranslatedTitleModal = function(){
	                $scope.editTranslatedTitle = !$scope.editTranslatedTitle;
	                $('#translatedTitle').toggle();
	                $.colorbox.resize();
	            };

	            $scope.bibtexShowToggle = function (putCode) {
	                $scope.showBibtex[putCode] = !($scope.showBibtex[putCode]);
	            };

	            $scope.showWorkImportWizard =  function() {
	                if(!$scope.workImportWizard) {
	                    loadWorkImportWizardList();
	                }
	                $scope.workImportWizard = !$scope.workImportWizard;
	            };   

	            function loadWorkImportWizardList() {
	                $.ajax({
	                    url: getBaseUri() + '/workspace/retrieve-work-impor-wizards.json',
	                    type: 'GET',
	                    contentType: 'application/json;charset=UTF-8',
	                    dataType: 'json',
	                    success: function(data) {
	                        if(data == null || data.length == 0) {
	                            $scope.noLinkFlag = false;
	                        }
	                        
	                        $scope.selectedWorkType = 'Articles';
	                        $scope.selectedGeoArea = 'Global';
	                        $scope.workImportWizardsOriginal = data;
	                        $scope.bulkEditShow = false;
	                        $scope.showBibtexImportWizard = false;
	                        for(var i = 0; i < $scope.workImportWizardsOriginal.length; i ++) {
	                            for(var j = 0; j < $scope.workImportWizardsOriginal[i].redirectUris.redirectUri.length; j ++) {
	                                $scope.workImportWizardsOriginal[i].redirectUris.redirectUri[j].actType =  JSON.parse($scope.workImportWizardsOriginal[i].redirectUris.redirectUri[j].actType);
	                                $scope.workImportWizardsOriginal[i].redirectUris.redirectUri[j].geoArea =  JSON.parse($scope.workImportWizardsOriginal[i].redirectUris.redirectUri[j].geoArea);
	                                for(var k = 0; k < $scope.workImportWizardsOriginal[i].redirectUris.redirectUri[j].actType['import-works-wizard'].length; k ++) {
	                                    if(!utilsService.contains($scope.workType, $scope.workImportWizardsOriginal[i].redirectUris.redirectUri[j].actType['import-works-wizard'][k])){
	                                        $scope.workType.push($scope.workImportWizardsOriginal[i].redirectUris.redirectUri[j].actType['import-works-wizard'][k]);
	                                    }
	                                }
	                                
	                                for(var k = 0; k < $scope.workImportWizardsOriginal[i].redirectUris.redirectUri[j].geoArea['import-works-wizard'].length; k ++) {
	                                    if(!utilsService.contains($scope.geoArea, $scope.workImportWizardsOriginal[i].redirectUris.redirectUri[j].geoArea['import-works-wizard'][k])){
	                                        $scope.geoArea.push($scope.workImportWizardsOriginal[i].redirectUris.redirectUri[j].geoArea['import-works-wizard'][k]);
	                                    }
	                                }
	                            }
	                        }               
	                        if( utilsService.getParameterByName('import_works_wizard') != 'true' ) {
	                            $scope.selectedWorkType = 'All';
	                            $scope.selectedGeoArea = 'All';
	                        }
	                        $scope.$apply();
	                    }
	                }).fail(function(e) {
	                    // something bad is happening!
	                    console.log("WorkImportWizardError");
	                    logAjaxError(e);
	                });
	            }
	    
	            $scope.addWorkModal = function(data){
	                if(emailVerified === true || configuration.showModalManualEditVerificationEnabled == false){
	                    if (data == undefined) {
	                        worksSrvc.getBlankWork(function(data) {
	                            $scope.editWork = data;
	                            $scope.$apply(function() {
	                                $scope.loadWorkTypes();
	                                $scope.showAddWorkModal();
	                            });
	                        });
	                    } else {
	                        $scope.editWork = data;            
	                        $scope.loadWorkTypes();
	                        $scope.showAddWorkModal();
	                    }
	                } else {
	                    showEmailVerificationModal();
	                }
	            };

	            $scope.openEditWork = function(putCode){
	                worksSrvc.getEditable(putCode, function(data) {$scope.addWorkModal(data);});
	            };       

	            $scope.putWork = function(){
	                if(emailVerified === true || configuration.showModalManualEditVerificationEnabled == false){
	                    if ($scope.addingWork) {
	                        return; // don't process if adding work
	                    }
	                    $scope.addingWork = true;
	                    $scope.editWork.errors.length = 0;
	                    worksSrvc.putWork($scope.editWork,
	                        function(data){
	                            if (data.errors.length == 0) {
	                                if ($scope.bibtextWork == false){
	                                    $.colorbox.close();
	                                    $scope.addingWork = false;
	                                } else {
	                                    $scope.worksFromBibtex.splice($scope.bibtextWorkIndex, 1);
	                                    $scope.bibtextWork = false;
	                                    $scope.addingWork = false;
	                                    $scope.$apply();
	                                    $.colorbox.close();
	                                    $scope.worksSrvc.loadAbbrWorks(worksSrvc.constants.access_type.USER);
	                                }
	                            } else {
	                                $scope.editWork = data;                    
	                                commonSrvc.copyErrorsLeft($scope.editWork, data);
	                                
	                                $scope.addingWork = false;
	                                $scope.$apply();
	                                // make sure colorbox is shown if there are errors
	                                if (!($("#colorbox").css("display")=="block")) {
	                                    $scope.addWorkModal(data);
	                                }
	                            }
	                        },
	                        function() {
	                            // something bad is happening!
	                            $scope.addingWork = false;
	                        }
	                    );
	                } else {
	                    showEmailVerificationModal();
	                }
	            };

	            $scope.closeAllMoreInfo = function() {
	                for (var idx in $scope.moreInfo){
	                    $scope.moreInfo[idx]=false;
	                }
	            };

	            $scope.validateCitation = function() {
	                if ($scope.editWork.citation
	                        && $scope.editWork.citation.citation.value
	                        && $scope.editWork.citation.citation.value.length > 0
	                        && $scope.editWork.citation.citationType.value == 'bibtex') {
	                    try {
	                        var parsed = bibtexParse.toJSON($scope.editWork.citation.citation.value);
	                        var index = $scope.editWork.citation.citation.errors.indexOf(om.get('manualWork.bibtext.notValid'));
	                        if (parsed.length == 0){
	                            throw "bibtex parse return nothing";
	                        } 
	                        if (index > -1) {
	                            $scope.editWork.citation.citation.errors.splice(index, 1);
	                        }
	                    } catch (err) {
	                        $scope.editWork.citation.citation.errors.push(om.get('manualWork.bibtext.notValid'));
	                    };
	                };
	            };

	            $scope.renderTranslatedTitleInfo = function(putCode) {
	                var info = null;

	                if(putCode != null && $scope.worksSrvc.details[putCode] != null && $scope.worksSrvc.details[putCode].translatedTitle != null) {
	                    info = $scope.worksSrvc.details[putCode].translatedTitle.content + ' - ' + $scope.worksSrvc.details[putCode].translatedTitle.languageName;
	                }

	                return info;
	            };

	            $scope.loadWorkTypes = function(){
	                var workCategory = "";
	                if($scope.editWork != null && $scope.editWork.workCategory != null && $scope.editWork.workCategory.value != null && $scope.editWork.workCategory.value != ""){
	                    workCategory = $scope.editWork.workCategory.value;
	                }
	                else{
	                    return; //do nothing if we have not types
	                }
	                $.ajax({
	                    url: getBaseUri() + '/works/loadWorkTypes.json?workCategory=' + workCategory,
	                    contentType: 'application/json;charset=UTF-8',
	                    dataType: 'json',
	                    success: function(data) {
	                        $scope.$apply(function() {
	                            $scope.types = data;
	                            if($scope.editWork != null && $scope.editWork.workCategory != null) {
	                                // if the edit works doesn't have a value that matches types
	                                var hasType = false;
	                                for (var idx in $scope.types){
	                                    if ($scope.types[idx].key == $scope.editWork.workType.value) hasType = true;
	                                }
	                                if(!hasType) {
	                                    switch ($scope.editWork.workCategory.value){
	                                    case "conference":
	                                        $scope.editWork.workType.value="conference-paper";
	                                        break;
	                                    case "intellectual_property":
	                                        $scope.editWork.workType.value="patent";
	                                        break;
	                                    case "other_output":
	                                        $scope.editWork.workType.value="data-set";
	                                        break;
	                                    case "publication":
	                                        $scope.editWork.workType.value="journal-article";
	                                        break;
	                                    }
	                                }
	                            }
	                        });
	                    }
	                }).fail(function() {
	                    console.log("Error loading work types.");
	                });
	            };

	            $scope.fillUrl = function(extId) {
	                var url;
	                if(extId != null) {
	                    url = workIdLinkJs.getLink(extId.workExternalIdentifierId.value, extId.workExternalIdentifierType.value);
	                    if(extId.url == null) {
	                        extId.url = {value:""};
	                    }
	                    extId.url.value=url;
	                }
	            };
	    
	            //init
	            $scope.worksSrvc.loadAbbrWorks(worksSrvc.constants.access_type.USER);
	            loadWorkImportWizardList();

	            // remove once grouping is live
	            $scope.moreInfoClick = function(work, $event) {
	                if (!document.documentElement.className.contains('no-touch')){
	                    $scope.moreInfoOpen?$scope.closePopover():$scope.loadWorkInfo(work.putCode.value, $event);
	                }
	            };

	            // remove once grouping is live
	            $scope.moreInfoMouseEnter = function(work, $event) {
	                $event.stopPropagation();
	                if (document.documentElement.className.contains('no-touch')){
	                    $scope.loadWorkInfo(work.putCode.value, $event);
	                }
	                else{
	                    $scope.moreInfoOpen?$scope.closePopover():$scope.loadWorkInfo(work.putCode.value, $event);
	                }
	            };

	            $scope.showDetailsMouseClick = function(group, $event) {
	                $event.stopPropagation();
	                $scope.moreInfo[group.groupId] = !$scope.moreInfo[group.groupId];
	                for (var idx in group.activities){
	                    $scope.loadDetails(group.activities[idx].putCode.value, $event);
	                }
	            };

	            $scope.hideSources = function(group) {
	                $scope.editSources[group.groupId] = false;
	                group.activePutCode = group.defaultPutCode;
	            };

	            $scope.showSources = function(group) {
	                $scope.editSources[group.groupId] = true;
	            };

	            $scope.loadDetails = function(putCode, event) {
	                //Close any open popover
	                $scope.closePopover(event);
	                $scope.moreInfoOpen = true;
	                //Display the popover
	                $(event.target).next().css('display','inline');
	                $scope.worksSrvc.getGroupDetails(putCode, worksSrvc.constants.access_type.USER);
	            };


	            $scope.loadWorkInfo = function(putCode, event) {
	                //Close any open popover
	                $scope.closePopover(event);
	                $scope.moreInfoOpen = true;
	                //Display the popover
	                $(event.target).next().css('display','inline');
	                if($scope.worksSrvc.details[putCode] == null) {
	                    $scope.worksSrvc.getGroupDetails(putCode, worksSrvc.constants.access_type.USER);
	                } else {
	                    $(event.target).next().css('display','inline');
	                }
	            };

	            $scope.closePopover = function(event) {
	                $scope.moreInfoOpen = false;
	                $('.work-more-info-container').css('display', 'none');
	            };

	            $scope.deleteWorkConfirm = function(putCode, deleteGroup) {
	                var maxSize = 100;
	                var work = worksSrvc.getWork(putCode);
	                $scope.deletePutCode = putCode;
	                $scope.deleteGroup = deleteGroup;
	                if (work.title){
	                    $scope.fixedTitle = work.title.value;
	                }
	                else {  
	                    $scope.fixedTitle = '';
	                } 
	                if($scope.fixedTitle.length > maxSize){
	                    $scope.fixedTitle = $scope.fixedTitle.substring(0, maxSize) + '...';
	                }
	                $.colorbox({
	                    html : $compile($('#delete-work-modal').html())($scope),
	                    onComplete: function() {$.colorbox.resize();}
	                });
	            };

	            $scope.deleteByPutCode = function(putCode, deleteGroup) {
	                if (deleteGroup) {
	                   worksSrvc.deleteGroupWorks(putCode);
	                }
	                else {
	                   worksSrvc.deleteWork(putCode);
	                }
	                $.colorbox.close();
	            };

	            $scope.closeModal = function() {
	                $.colorbox.close();
	            };

	            $scope.openImportWizardUrl = function(url) {
	                openImportWizardUrl(url);
	            };
	    
	            $scope.openImportWizardUrlFilter = function(url, param) {
	                url = url + '?client_id='+param.clientId+'&response_type=code&scope='+param.redirectUris.redirectUri[0].scopeAsSingleString+'&redirect_uri='+param.redirectUris.redirectUri[0].value;
	                openImportWizardUrl(url);
	            };

	            $scope.setAddWorkPrivacy = function(priv, $event) {
	                $event.preventDefault();
	                $scope.editWork.visibility = priv;
	            };

	            $scope.serverValidate = function (relativePath) {
	                $.ajax({
	                    url: getBaseUri() + '/' + relativePath,
	                    type: 'POST',
	                    data:  angular.toJson($scope.editWork),
	                    contentType: 'application/json;charset=UTF-8',
	                    dataType: 'json',
	                    success: function(data) {
	                        commonSrvc.copyErrorsLeft($scope.editWork, data);
	                        if ( relativePath == 'works/work/citationValidate.json') {
	                            $scope.validateCitation();
	                        }
	                        $scope.$apply();
	                    }
	                }).fail(function() {
	                    // something bad is happening!
	                    console.log("WorkCtrl.serverValidate() error");
	                });
	            };

	            $scope.isValidClass = function (cur) {
	                var valid = true;
	                if (cur === undefined || cur == null) {
	                    return '';
	                }
	                if ( ( cur.required && (cur.value == null || cur.value.trim() == '') ) || ( cur.errors !== undefined && cur.errors.length > 0 ) ){
	                    valid = false;
	                }
	                return valid ? '' : 'text-error';
	            };

	            $scope.clearErrors = function() {
	                $scope.editWork.workCategory.errors = [];
	                $scope.editWork.workType.errors = [];
	            };
	    
	            $scope.showTooltip = function (key){        
	                $scope.showElement[key] = true;     
	            };
	    
	            $scope.hideTooltip = function (key){        
	                $scope.showElement[key] = false;
	            };
	    
	            $scope.openFileDialog = function(){
	                $scope.textFiles = [];
	                $scope.bibtexParsingError = false;
	                $timeout(
	                    function() { //To avoid '$apply already in progress' error
	                        angular.element('#inputBibtex').trigger('click');
	                    }, 
	                    0
	                );
	            };
	    
	            $scope.toggleWizardDesc = function(id){
	                $scope.wizardDescExpanded[id] = !$scope.wizardDescExpanded[id];
	            };
	            
	            $scope.showURLPopOver = function(id){       
	                $scope.displayURLPopOver[id] = true;
	            }
	            
	            $scope.hideURLPopOver = function(id){       
	                $scope.displayURLPopOver[id] = false;
	            }
	    
	            $scope.showMozillaBadges = function(putCode){
	                $scope.$watch(
	                    function () { 
	                        return document.getElementsByClassName('badge-container-' + putCode).length; 
	                    },
	                    function (newValue, oldValue) {
	                          if (newValue !== oldValue) {
	                              if ($scope.badgesRequested[putCode] == null){
	                                var dois = worksSrvc.getUniqueDois(putCode);
	                                var c = document.getElementsByClassName('badge-container-' + putCode);
	                                for (var i = 0; i <= dois.length - 1; i++){
	                                    var code = 'var conf={"article-doi": "' + dois[i].trim() + '", "container-class": "badge-container-' + putCode + '"};showBadges(conf);';
	                                    var s = document.createElement('script');
	                                    s.type = 'text/javascript';
	                                    try {
	                                        s.appendChild(document.createTextNode(code));
	                                        c[0].appendChild(s);
	                                    } catch (e) {
	                                        s.text = code;
	                                        c[0].appendChild(s);
	                                    }
	                                }
	                                $scope.badgesRequested[putCode] = true;
	                            }
	                        }
	                    }
	                );
	            };
	    
	            $scope.toggleBibtexExport = function(){
	                $scope.bibtexExportError = false;
	                $scope.bibtexLoading = false;
	                $scope.bibtexParsingError = false;
	                $scope.bulkEditShow = false;        
	                $scope.loadingScripts = false;
	                $scope.scriptsLoaded = false;
	                $scope.showBibtexExport  = !$scope.showBibtexExport;
	                $scope.showBibtexImportWizard = false;
	                $scope.workImportWizard = false;
	            }


	            $scope.fetchBibtexExport = function(){
	                $scope.bibtexLoading = true;
	                $scope.bibtexExportError = false; 
	                
	                $.ajax({
	                    url: getBaseUri() + '/' + 'works/works.bib',
	                    type: 'GET',
	                    success: function(data) {
	                        $scope.bibtexLoading = false;
	                        if(window.navigator.msSaveOrOpenBlob) {
	                            var fileData = [data];
	                            blobObject = new Blob(fileData, {type: 'text/plain'});
	                            window.navigator.msSaveOrOpenBlob(blobObject, "works.bib");                              
	                        } else {
	                            var anchor = angular.element('<a/>');
	                            anchor.css({display: 'none'});
	                            angular.element(document.body).append(anchor);
	                            anchor.attr({
	                                href: 'data:text/x-bibtex;charset=utf-8,' + encodeURIComponent(data),
	                                target: '_self',
	                                download: 'works.bib'
	                            })[0].click();
	                            anchor.remove();
	                        }
	                    }
	                }).fail(function() {
	                    $scope.bibtexExportError = true;
	                    console.log("bibtex export error");
	                });        
	            };


	            $scope.downloadBibtexExport = function(citations){
	                $scope.bibtexGenerated = false;
	                if (citations.length > 0){
	                    var text = "";
	                    for (var c in citations){
	                        text += citations[c] +"\n"; 
	                    }
	                    text = text.replace(/<div class="csl-entry">/g, '');
	                    text = text.replace(/<\/div>/g, '');
	                    
	                    if(window.navigator.msSaveOrOpenBlob) {
	                        var fileData = [text];
	                        blobObject = new Blob(fileData, {type: 'text/plain'});
	                        window.navigator.msSaveOrOpenBlob(blobObject, "orcid.bib");                
	                    } else {
	                        $scope.bibtexGenerated = true;
	                        $scope.bibtexURL = "data:text/plain;charset=utf-8," + encodeURIComponent(text);   
	                    }
	                }else{
	                    $scope.$apply(
	                        function() {
	                            $scope.bibtexExportError = true;
	                        }
	                    );   
	                }
	            };
	        }
	    ]
	);

/***/ },
/* 14 */
/***/ function(module, exports) {

	function webpackContext(req) {
		throw new Error("Cannot find module '" + req + "'.");
	}
	webpackContext.keys = function() { return []; };
	webpackContext.resolve = webpackContext;
	module.exports = webpackContext;
	webpackContext.id = 14;


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./fnForm.js": 16,
		"./focusMe.js": 17,
		"./modalEmailUnVerified.js": 18,
		"./ngEnter.js": 19,
		"./ngEnterSubmit.js": 20
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 15;


/***/ },
/* 16 */
/***/ function(module, exports) {

	/*
	 * For forms submitted using a custom function, Scope: Document
	 * 
	 * Example:
	 * <fn-form update-fn="theCustomFunction()">
	 * 
	 * </fn-form>
	 * 
	 */
	angular.module('orcidApp').directive('fnForm', function($document) {
	    return {
	        restrict: 'E',
	        scope: {
	            updateFn: '&'
	        },
	        link: function(scope, elm, attrs) {

	            $(document).unbind("keydown.keydownUpfateFn");

	            $document.bind(
	                "keydown.keydownUpfateFn",
	                function(event) {
	                    if (event.which === 13) {
	                        scope.updateFn();                 
	                        event.stopPropagation();
	                    }
	                }
	            );                   
	        }
	    }
	});

/***/ },
/* 17 */
/***/ function(module, exports) {

	angular.module('orcidApp').directive(
	    'focusMe', 
	    function($timeout) {
	        return {
	            scope: { trigger: '=focusMe' },
	            link: function(scope, element) {
	                $timeout( //[fn], [delay], [invokeApply], [Pass]
	                    function(){
	                        if (scope.trigger) {
	                            element[0].focus();
	                            scope.trigger = false;
	                        }
	                    },
	                    1000
	                );
	            }
	        };
	    }
	);

/***/ },
/* 18 */
/***/ function(module, exports) {

	/*
	 * For modal with email verification validation
	 */



	angular.module('orcidApp').directive(
	    'modalEmailUnVerified', 
	    [
	        '$compile',
	        '$rootScope',
	        '$timeout',
	        function( $compile, $rootScope, $timeout ) {

	            var closeModal = function(){
	                $.colorbox.remove();
	                $('modal-email-un-verified').html('<div id="modal-email-unverified-container"></div>');
	            }

	            var openModal = function( scope, data ){
	                emailVerifiedObj = data;
	                $.colorbox(
	                    {
	                        html : $compile($('#modal-email-unverified-container').html('<div class="lightbox-container" id="modal-email-unverified"><div class="row"><div class="col-md-12 col-xs-12 col-sm-12"><h4>' + om.get("orcid.frontend.workspace.your_primary_email") + '</h4><p>' + om.get("orcid.frontend.workspace.ensure_future_access") + '</p><p>' + om.get("orcid.frontend.workspace.ensure_future_access2") + '<br /><a href="mailto:' + data.emails[0].value + '" target="_blank">' + data.emails[0].value + '</a></p><p>' + om.get("orcid.frontend.workspace.ensure_future_access3") + ' <a target="_blank" href="' + om.get("orcid.frontend.link.url.knowledgebase") + '">' + om.get("orcid.frontend.workspace.ensure_future_access4") + '</a> ' + om.get("orcid.frontend.workspace.ensure_future_access5") + ' <a target="_blank" href="mailto:' + om.get("orcid.frontend.link.email.support") + '">' + om.get("orcid.frontend.link.email.support") + '</a>.</p><button class="btn btn-primary" id="modal-close" ng-click="verifyEmail()">' + om.get("orcid.frontend.workspace.send_verification") + '</button><a class="cancel-option inner-row" ng-click="closeColorBox()">' + om.get("orcid.frontend.freemarker.btncancel") + '</a></div></div></div>'))(scope),
	                        escKey: true,
	                        overlayClose: true,
	                        transition: 'fade',
	                        close: '',
	                        scrolling: false
	                    }
	                );
	                $.colorbox.resize({height:"250px", width:"500px"});
	            }

	            var verifyEmail = function( scope ){
	                var colorboxHtml = null;
	                $.ajax({
	                    url: getBaseUri() + '/account/verifyEmail.json',
	                    type: 'get',
	                    data:  { "email": emailVerifiedObj.emails[0].value },
	                    contentType: 'application/json;charset=UTF-8',
	                    dataType: 'json',
	                    success: function(data) {
	                        //alert( "Verification Email Send To: " + $scope.emailsPojo.emails[idx].value);
	                    }
	                }).fail(function() {
	                    // something bad is happening!
	                    console.log("error with multi email");
	                });
	                
	                colorboxHtml = $compile($('#verify-email-modal-sent').html())(scope);

	                $.colorbox({
	                    html : colorboxHtml,
	                    escKey: true,
	                    overlayClose: true,
	                    transition: 'fade',
	                    close: '',
	                    scrolling: false
	                });
	                $.colorbox.resize({height:"200px", width:"500px"});
	            }

	            function link( scope, element, attrs ) {

	                scope.verifyEmail = function() {
	                    verifyEmail( scope );
	                };

	                scope.closeColorBox = function() {
	                    closeModal();
	                };

	                scope.openModal = function( scope, data ){
	                    openModal( scope, data );
	                }

	                scope.$on(
	                    'emailVerifiedObj',
	                    function(event, data){
	                        if (data.flag == false ) {
	                            scope.openModal( scope, data ); 
	                        }
	                        else {
	                            scope.closeColorBox(); 
	                        }
	                    }

	                );
	            }

	            return {
	                link: link,
	                template: '<div id="modal-email-unverified-container"></div>',
	                transclude: true
	            };
	        }
	    ]
	);

/***/ },
/* 19 */
/***/ function(module, exports) {

	/*
	 * Scope: element
	 */
	angular.module('orcidApp').directive('ngEnter', function() {
	    return function(scope, element, attrs) {
	        $(document).unbind("keydown.ngEnter keypress.ngEnter");
	        element.bind("keydown.ngEnter keypress.ngEnter", function(event) {
	            if(event.which === 13) {                
	                scope.$apply(function(){
	                    scope.$eval(attrs.ngEnter, {'event': event});
	                });
	                event.preventDefault();
	                event.stopPropagation();
	            }
	        });
	    };
	});

/***/ },
/* 20 */
/***/ function(module, exports) {

	/*
	 * For forms submitted using the default submit function (Scope: document)
	 * Not necessary to be inside an element, for inputs use ngEnter
	 */
	angular.module('orcidApp').directive('ngEnterSubmit', function($document) {
	    return {
	        restrict: 'A',
	        link: function(scope, element, attr) {
	            $(document).unbind("keydown.ngEnterSubmit keypress.ngEnterSubmit");
	            $document.bind("keydown.ngEnterSubmit keypress.ngEnterSubmit", function(event) {
	                if (event.which === 13) {
	                   element.submit();
	                }
	            });
	        }
	    };
	});

/***/ },
/* 21 */
/***/ function(module, exports) {

	function webpackContext(req) {
		throw new Error("Cannot find module '" + req + "'.");
	}
	webpackContext.keys = function() { return []; };
	webpackContext.resolve = webpackContext;
	module.exports = webpackContext;
	webpackContext.id = 21;


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./ui.multiselect.js": 23
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 22;


/***/ },
/* 23 */
/***/ function(module, exports) {

	/* Angular Multi-selectbox */
	angular.module('ui.multiselect', [])

	.factory('optionParser', ['$parse', function ($parse) {

	    //                      00000111000000000000022200000000000000003333333333333330000000000044000
	    var TYPEAHEAD_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+(.*)$/;

	    return {
	      parse: function (input) {

	        var match = input.match(TYPEAHEAD_REGEXP), modelMapper, viewMapper, source;
	        if (!match) {
	          throw new Error(
	            "Expected typeahead specification in form of '_modelValue_ (as _label_)? for _item_ in _collection_'" +
	              " but got '" + input + "'.");
	        }

	        return {
	          itemName: match[3],
	          source: $parse(match[4]),
	          viewMapper: $parse(match[2] || match[1]),
	          modelMapper: $parse(match[1])
	        };
	      }
	    };
	  }])

	  .directive('multiselect', ['$parse', '$document', '$compile', '$interpolate', 'optionParser',

	    function ($parse, $document, $compile, $interpolate, optionParser) {
	      return {
	        restrict: 'E',
	        require: 'ngModel',
	        link: function (originalScope, element, attrs, modelCtrl) {

	          var exp = attrs.options,
	            parsedResult = optionParser.parse(exp),
	            isMultiple = attrs.multiple ? true : false,
	            required = false,
	            scope = originalScope.$new(),
	            changeHandler = attrs.change || angular.noop;

	          scope.items = [];
	          scope.header = 'Select';
	          scope.multiple = isMultiple;
	          scope.disabled = false;

	          originalScope.$on('$destroy', function () {
	            scope.$destroy();
	          });

	          var popUpEl = angular.element('<multiselect-popup></multiselect-popup>');

	          //required validator
	          if (attrs.required || attrs.ngRequired) {
	            required = true;
	          }
	          attrs.$observe('required', function(newVal) {
	            required = newVal;
	          });

	          //watch disabled state
	          scope.$watch(function () {
	            return $parse(attrs.disabled)(originalScope);
	          }, function (newVal) {
	            scope.disabled = newVal;
	          });

	          //watch single/multiple state for dynamically change single to multiple
	          scope.$watch(function () {
	            return $parse(attrs.multiple)(originalScope);
	          }, function (newVal) {
	            isMultiple = newVal || false;
	          });

	          //watch option changes for options that are populated dynamically
	          scope.$watch(function () {
	            return parsedResult.source(originalScope);
	          }, function (newVal) {
	            if (angular.isDefined(newVal))
	              parseModel();
	          }, true);

	          //watch model change
	          scope.$watch(
	            function () {
	                return modelCtrl.$modelValue;
	            }, 
	            function (newVal, oldVal) {
	                //when directive initialize, newVal usually undefined. Also, if model value already set in the controller
	                //for preselected list then we need to mark checked in our scope item. But we don't want to do this every time
	                //model changes. We need to do this only if it is done outside directive scope, from controller, for example.
	                if (angular.isDefined(newVal)) {
	                  markChecked(newVal);
	                  scope.$eval(changeHandler);
	                }
	                getHeaderText();
	                modelCtrl.$setValidity('required', scope.valid());
	              }, 
	              true
	          );

	          function parseModel() {
	            scope.items.length = 0;
	            var model = parsedResult.source(originalScope);
	            if(!angular.isDefined(model)) return;
	            for (var i = 0; i < model.length; i++) {
	              var local = {};
	              local[parsedResult.itemName] = model[i];
	              scope.items.push({
	                label: parsedResult.viewMapper(local),
	                model: parsedResult.modelMapper(local),
	                checked: false
	              });
	            }
	          }

	          parseModel();

	          element.append($compile(popUpEl)(scope));

	          function getHeaderText() {
	            if (is_empty(modelCtrl.$modelValue)) return scope.header = attrs.msHeader || 'Select';

	              if (isMultiple) {
	                  if (attrs.msSelected) {
	                      scope.header = $interpolate(attrs.msSelected)(scope);
	                  } else {
	                      scope.header = modelCtrl.$modelValue.length + ' ' + 'selected';
	                  }

	            } else {
	              var local = {};
	              local[parsedResult.itemName] = modelCtrl.$modelValue;
	              scope.header = parsedResult.viewMapper(local);
	            }
	          }

	          function is_empty(obj) {
	            if (!obj) return true;
	            if (obj.length && obj.length > 0) return false;
	            for (var prop in obj) if (obj[prop]) return false;
	            return true;
	          };

	          scope.valid = function validModel() {
	            if(!required) return true;
	            var value = modelCtrl.$modelValue;
	            return (angular.isArray(value) && value.length > 0) || (!angular.isArray(value) && value != null);
	          };

	          function selectSingle(item) {
	          scope.uncheckAll();
	            if (!item.checked) {
	              item.checked = !item.checked;
	            }
	            setModelValue(false);
	          }

	          function selectMultiple(item) {
	            item.checked = !item.checked;
	            setModelValue(true);
	          }

	          function setModelValue(isMultiple) {
	            var value;

	            if (isMultiple) {
	              value = [];
	              angular.forEach(scope.items, function (item) {
	                if (item.checked) value.push(item.model);
	              })
	            } else {
	              angular.forEach(scope.items, function (item) {
	                if (item.checked) {
	                  value = item.model;
	                  return false;
	                }
	              })
	            }
	            modelCtrl.$setViewValue(value);
	          }

	          function markChecked(newVal) {
	            if (!angular.isArray(newVal)) {
	              angular.forEach(scope.items, function (item) {
	                if (angular.equals(item.model, newVal)) {
	                  scope.uncheckAll();
	                  item.checked = true;
	                  setModelValue(false);
	                  return false;
	                }
	              });
	            } else {
	              angular.forEach(scope.items, function (item) {
	                item.checked = false;
	                angular.forEach(newVal, function (i) {
	                  if (angular.equals(item.model, i)) {
	                    item.checked = true;
	                  }
	                });
	              });
	            }
	          }

	          scope.checkAll = function () {
	            if (!isMultiple) return;
	            angular.forEach(scope.items, function (item) {
	              item.checked = true;
	            });
	            setModelValue(true);
	          };

	          scope.uncheckAll = function () {
	            angular.forEach(scope.items, function (item) {
	              item.checked = false;
	            });
	            setModelValue(true);
	          };

	          scope.select = function (item) {
	            if (isMultiple === false) {
	              selectSingle(item);
	              scope.toggleSelect();
	            } else {
	              selectMultiple(item);
	            }
	          }
	        }
	      };
	    }])

	  .directive('multiselectPopup', ['$compile','$document','$templateCache', function ($compile, $document, $templateCache) {
	    return {
	      restrict: 'E',
	      scope: false,
	      replace: true,
	      template: $templateCache.get('multiselect'),
	      link: function (scope, element, attrs) {

	        scope.isVisible = false;

	        scope.toggleSelect = function () {
	          if (element.hasClass('open')) {
	            element.removeClass('open');
	            $document.unbind('click', clickHandler);
	          } else {
	            element.addClass('open');
	            $document.bind('click', clickHandler);
	            scope.focus();
	          }
	        };

	        function clickHandler(event) {
	          if (elementMatchesAnyInArray(event.target, element.find(event.target.tagName)))
	            return;
	          element.removeClass('open');
	          $document.unbind('click', clickHandler);
	          scope.$apply();
	        }

	        scope.focus = function focus(){
	          var searchBox = element.find('input')[0];
	          searchBox.focus();
	        }

	        var elementMatchesAnyInArray = function (element, elementArray) {
	          for (var i = 0; i < elementArray.length; i++)
	            if (element == elementArray[i])
	              return true;
	          return false;
	        }
	      }
	    }
	}]);

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./ng1_app.ts": 25,
		"./ng2_app.ts": 26
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 24;


/***/ },
/* 25 */
/***/ function(module, exports) {

	//import * as angular from 'angular'
	//export const orcidApp = angular.module('orcidApp', ['ngCookies','ngSanitize', 'ui.multiselect', 'vcRecaptcha']);
	//var orcidApp = angular.module('orcidApp', ['ngCookies','ngSanitize', 'ui.multiselect', 'vcRecaptcha']);
	//var orcidNgModule = angular.module('orcidApp', ['ngCookies','ngSanitize', 'ui.multiselect', 'vcRecaptcha']);
	//angular.bootstrap(document.body, ['orcidApp']);
	/**
	 * This file defines the root module of the Angular 1 of the application.
	 */
	//import 'reflect-metadata';
	// import app modules
	//import {MessagesModule} from './messages';
	//import {MenuModule} from './menu';
	//import * as angular from 'angular'
	//import 'angular-route'
	//export const Ng1AppModule = angular.module('Ng1AppModule', ['ngRoute']); 


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	__webpack_require__(27);
	var core_1 = __webpack_require__(28);
	var platform_browser_1 = __webpack_require__(46);
	var static_1 = __webpack_require__(48);
	/*
	@Component({
	  selector: 'root-cmp',
	  template: `
	    <div class="ng-view"></div>
	  `,
	})
	export class RootCmp {}
	*/
	var Ng2AppModule = (function () {
	    function Ng2AppModule() {
	    }
	    //constructor(){}
	    Ng2AppModule.prototype.ngDoBootstrap = function () { };
	    return Ng2AppModule;
	}());
	Ng2AppModule = __decorate([
	    core_1.NgModule({
	        imports: [
	            platform_browser_1.BrowserModule,
	            static_1.UpgradeModule
	        ] //,
	    })
	], Ng2AppModule);
	exports.Ng2AppModule = Ng2AppModule;


/***/ },
/* 27 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/*! *****************************************************************************
	Copyright (C) Microsoft. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0

	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.

	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */
	var Reflect;
	(function (Reflect) {
	    "use strict";
	    var hasOwn = Object.prototype.hasOwnProperty;
	    // feature test for Object.create support
	    var supportsCreate = typeof Object.create === "function";
	    // feature test for __proto__ support
	    var supportsProto = { __proto__: [] } instanceof Array;
	    // feature test for Symbol support
	    var supportsSymbol = typeof Symbol === "function";
	    var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
	    var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
	    // create an object in dictionary mode (a.k.a. "slow" mode in v8)
	    var createDictionary = supportsCreate ? function () { return MakeDictionary(Object.create(null)); } :
	        supportsProto ? function () { return MakeDictionary({ __proto__: null }); } :
	            function () { return MakeDictionary({}); };
	    var HashMap;
	    (function (HashMap) {
	        var downLevel = !supportsCreate && !supportsProto;
	        HashMap.has = downLevel
	            ? function (map, key) { return hasOwn.call(map, key); }
	            : function (map, key) { return key in map; };
	        HashMap.get = downLevel
	            ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }
	            : function (map, key) { return map[key]; };
	    })(HashMap || (HashMap = {}));
	    // Load global or shim versions of Map, Set, and WeakMap
	    var functionPrototype = Object.getPrototypeOf(Function);
	    var _Map = typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
	    var _Set = typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
	    var _WeakMap = typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
	    // [[Metadata]] internal slot
	    var Metadata = new _WeakMap();
	    /**
	      * Applies a set of decorators to a property of a target object.
	      * @param decorators An array of decorators.
	      * @param target The target object.
	      * @param targetKey (Optional) The property key to decorate.
	      * @param targetDescriptor (Optional) The property descriptor for the target key
	      * @remarks Decorators are applied in reverse order.
	      * @example
	      *
	      *     class Example {
	      *         // property declarations are not part of ES6, though they are valid in TypeScript:
	      *         // static staticProperty;
	      *         // property;
	      *
	      *         constructor(p) { }
	      *         static staticMethod(p) { }
	      *         method(p) { }
	      *     }
	      *
	      *     // constructor
	      *     Example = Reflect.decorate(decoratorsArray, Example);
	      *
	      *     // property (on constructor)
	      *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
	      *
	      *     // property (on prototype)
	      *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
	      *
	      *     // method (on constructor)
	      *     Object.defineProperty(Example, "staticMethod",
	      *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
	      *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
	      *
	      *     // method (on prototype)
	      *     Object.defineProperty(Example.prototype, "method",
	      *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
	      *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
	      *
	      */
	    function decorate(decorators, target, targetKey, targetDescriptor) {
	        if (!IsUndefined(targetKey)) {
	            if (!IsArray(decorators))
	                throw new TypeError();
	            if (!IsObject(target))
	                throw new TypeError();
	            if (!IsObject(targetDescriptor) && !IsUndefined(targetDescriptor) && !IsNull(targetDescriptor))
	                throw new TypeError();
	            if (IsNull(targetDescriptor))
	                targetDescriptor = undefined;
	            targetKey = ToPropertyKey(targetKey);
	            return DecorateProperty(decorators, target, targetKey, targetDescriptor);
	        }
	        else {
	            if (!IsArray(decorators))
	                throw new TypeError();
	            if (!IsConstructor(target))
	                throw new TypeError();
	            return DecorateConstructor(decorators, target);
	        }
	    }
	    Reflect.decorate = decorate;
	    /**
	      * A default metadata decorator factory that can be used on a class, class member, or parameter.
	      * @param metadataKey The key for the metadata entry.
	      * @param metadataValue The value for the metadata entry.
	      * @returns A decorator function.
	      * @remarks
	      * If `metadataKey` is already defined for the target and target key, the
	      * metadataValue for that key will be overwritten.
	      * @example
	      *
	      *     // constructor
	      *     @Reflect.metadata(key, value)
	      *     class Example {
	      *     }
	      *
	      *     // property (on constructor, TypeScript only)
	      *     class Example {
	      *         @Reflect.metadata(key, value)
	      *         static staticProperty;
	      *     }
	      *
	      *     // property (on prototype, TypeScript only)
	      *     class Example {
	      *         @Reflect.metadata(key, value)
	      *         property;
	      *     }
	      *
	      *     // method (on constructor)
	      *     class Example {
	      *         @Reflect.metadata(key, value)
	      *         static staticMethod() { }
	      *     }
	      *
	      *     // method (on prototype)
	      *     class Example {
	      *         @Reflect.metadata(key, value)
	      *         method() { }
	      *     }
	      *
	      */
	    function metadata(metadataKey, metadataValue) {
	        function decorator(target, targetKey) {
	            if (!IsUndefined(targetKey)) {
	                if (!IsObject(target))
	                    throw new TypeError();
	                targetKey = ToPropertyKey(targetKey);
	                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, targetKey);
	            }
	            else {
	                if (!IsConstructor(target))
	                    throw new TypeError();
	                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, /*targetKey*/ undefined);
	            }
	        }
	        return decorator;
	    }
	    Reflect.metadata = metadata;
	    /**
	      * Define a unique metadata entry on the target.
	      * @param metadataKey A key used to store and retrieve metadata.
	      * @param metadataValue A value that contains attached metadata.
	      * @param target The target object on which to define metadata.
	      * @param targetKey (Optional) The property key for the target.
	      * @example
	      *
	      *     class Example {
	      *         // property declarations are not part of ES6, though they are valid in TypeScript:
	      *         // static staticProperty;
	      *         // property;
	      *
	      *         constructor(p) { }
	      *         static staticMethod(p) { }
	      *         method(p) { }
	      *     }
	      *
	      *     // constructor
	      *     Reflect.defineMetadata("custom:annotation", options, Example);
	      *
	      *     // property (on constructor)
	      *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
	      *
	      *     // property (on prototype)
	      *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
	      *
	      *     // method (on constructor)
	      *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
	      *
	      *     // method (on prototype)
	      *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
	      *
	      *     // decorator factory as metadata-producing annotation.
	      *     function MyAnnotation(options): Decorator {
	      *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
	      *     }
	      *
	      */
	    function defineMetadata(metadataKey, metadataValue, target, targetKey) {
	        if (!IsObject(target))
	            throw new TypeError();
	        if (!IsUndefined(targetKey))
	            targetKey = ToPropertyKey(targetKey);
	        return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, targetKey);
	    }
	    Reflect.defineMetadata = defineMetadata;
	    /**
	      * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
	      * @param metadataKey A key used to store and retrieve metadata.
	      * @param target The target object on which the metadata is defined.
	      * @param targetKey (Optional) The property key for the target.
	      * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
	      * @example
	      *
	      *     class Example {
	      *         // property declarations are not part of ES6, though they are valid in TypeScript:
	      *         // static staticProperty;
	      *         // property;
	      *
	      *         constructor(p) { }
	      *         static staticMethod(p) { }
	      *         method(p) { }
	      *     }
	      *
	      *     // constructor
	      *     result = Reflect.hasMetadata("custom:annotation", Example);
	      *
	      *     // property (on constructor)
	      *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
	      *
	      *     // property (on prototype)
	      *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
	      *
	      *     // method (on constructor)
	      *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
	      *
	      *     // method (on prototype)
	      *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
	      *
	      */
	    function hasMetadata(metadataKey, target, targetKey) {
	        if (!IsObject(target))
	            throw new TypeError();
	        if (!IsUndefined(targetKey))
	            targetKey = ToPropertyKey(targetKey);
	        return OrdinaryHasMetadata(metadataKey, target, targetKey);
	    }
	    Reflect.hasMetadata = hasMetadata;
	    /**
	      * Gets a value indicating whether the target object has the provided metadata key defined.
	      * @param metadataKey A key used to store and retrieve metadata.
	      * @param target The target object on which the metadata is defined.
	      * @param targetKey (Optional) The property key for the target.
	      * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
	      * @example
	      *
	      *     class Example {
	      *         // property declarations are not part of ES6, though they are valid in TypeScript:
	      *         // static staticProperty;
	      *         // property;
	      *
	      *         constructor(p) { }
	      *         static staticMethod(p) { }
	      *         method(p) { }
	      *     }
	      *
	      *     // constructor
	      *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
	      *
	      *     // property (on constructor)
	      *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
	      *
	      *     // property (on prototype)
	      *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
	      *
	      *     // method (on constructor)
	      *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
	      *
	      *     // method (on prototype)
	      *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
	      *
	      */
	    function hasOwnMetadata(metadataKey, target, targetKey) {
	        if (!IsObject(target))
	            throw new TypeError();
	        if (!IsUndefined(targetKey))
	            targetKey = ToPropertyKey(targetKey);
	        return OrdinaryHasOwnMetadata(metadataKey, target, targetKey);
	    }
	    Reflect.hasOwnMetadata = hasOwnMetadata;
	    /**
	      * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
	      * @param metadataKey A key used to store and retrieve metadata.
	      * @param target The target object on which the metadata is defined.
	      * @param targetKey (Optional) The property key for the target.
	      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
	      * @example
	      *
	      *     class Example {
	      *         // property declarations are not part of ES6, though they are valid in TypeScript:
	      *         // static staticProperty;
	      *         // property;
	      *
	      *         constructor(p) { }
	      *         static staticMethod(p) { }
	      *         method(p) { }
	      *     }
	      *
	      *     // constructor
	      *     result = Reflect.getMetadata("custom:annotation", Example);
	      *
	      *     // property (on constructor)
	      *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
	      *
	      *     // property (on prototype)
	      *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
	      *
	      *     // method (on constructor)
	      *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
	      *
	      *     // method (on prototype)
	      *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
	      *
	      */
	    function getMetadata(metadataKey, target, targetKey) {
	        if (!IsObject(target))
	            throw new TypeError();
	        if (!IsUndefined(targetKey))
	            targetKey = ToPropertyKey(targetKey);
	        return OrdinaryGetMetadata(metadataKey, target, targetKey);
	    }
	    Reflect.getMetadata = getMetadata;
	    /**
	      * Gets the metadata value for the provided metadata key on the target object.
	      * @param metadataKey A key used to store and retrieve metadata.
	      * @param target The target object on which the metadata is defined.
	      * @param targetKey (Optional) The property key for the target.
	      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
	      * @example
	      *
	      *     class Example {
	      *         // property declarations are not part of ES6, though they are valid in TypeScript:
	      *         // static staticProperty;
	      *         // property;
	      *
	      *         constructor(p) { }
	      *         static staticMethod(p) { }
	      *         method(p) { }
	      *     }
	      *
	      *     // constructor
	      *     result = Reflect.getOwnMetadata("custom:annotation", Example);
	      *
	      *     // property (on constructor)
	      *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
	      *
	      *     // property (on prototype)
	      *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
	      *
	      *     // method (on constructor)
	      *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
	      *
	      *     // method (on prototype)
	      *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
	      *
	      */
	    function getOwnMetadata(metadataKey, target, targetKey) {
	        if (!IsObject(target))
	            throw new TypeError();
	        if (!IsUndefined(targetKey))
	            targetKey = ToPropertyKey(targetKey);
	        return OrdinaryGetOwnMetadata(metadataKey, target, targetKey);
	    }
	    Reflect.getOwnMetadata = getOwnMetadata;
	    /**
	      * Gets the metadata keys defined on the target object or its prototype chain.
	      * @param target The target object on which the metadata is defined.
	      * @param targetKey (Optional) The property key for the target.
	      * @returns An array of unique metadata keys.
	      * @example
	      *
	      *     class Example {
	      *         // property declarations are not part of ES6, though they are valid in TypeScript:
	      *         // static staticProperty;
	      *         // property;
	      *
	      *         constructor(p) { }
	      *         static staticMethod(p) { }
	      *         method(p) { }
	      *     }
	      *
	      *     // constructor
	      *     result = Reflect.getMetadataKeys(Example);
	      *
	      *     // property (on constructor)
	      *     result = Reflect.getMetadataKeys(Example, "staticProperty");
	      *
	      *     // property (on prototype)
	      *     result = Reflect.getMetadataKeys(Example.prototype, "property");
	      *
	      *     // method (on constructor)
	      *     result = Reflect.getMetadataKeys(Example, "staticMethod");
	      *
	      *     // method (on prototype)
	      *     result = Reflect.getMetadataKeys(Example.prototype, "method");
	      *
	      */
	    function getMetadataKeys(target, targetKey) {
	        if (!IsObject(target))
	            throw new TypeError();
	        if (!IsUndefined(targetKey))
	            targetKey = ToPropertyKey(targetKey);
	        return OrdinaryMetadataKeys(target, targetKey);
	    }
	    Reflect.getMetadataKeys = getMetadataKeys;
	    /**
	      * Gets the unique metadata keys defined on the target object.
	      * @param target The target object on which the metadata is defined.
	      * @param targetKey (Optional) The property key for the target.
	      * @returns An array of unique metadata keys.
	      * @example
	      *
	      *     class Example {
	      *         // property declarations are not part of ES6, though they are valid in TypeScript:
	      *         // static staticProperty;
	      *         // property;
	      *
	      *         constructor(p) { }
	      *         static staticMethod(p) { }
	      *         method(p) { }
	      *     }
	      *
	      *     // constructor
	      *     result = Reflect.getOwnMetadataKeys(Example);
	      *
	      *     // property (on constructor)
	      *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
	      *
	      *     // property (on prototype)
	      *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
	      *
	      *     // method (on constructor)
	      *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
	      *
	      *     // method (on prototype)
	      *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
	      *
	      */
	    function getOwnMetadataKeys(target, targetKey) {
	        if (!IsObject(target))
	            throw new TypeError();
	        if (!IsUndefined(targetKey))
	            targetKey = ToPropertyKey(targetKey);
	        return OrdinaryOwnMetadataKeys(target, targetKey);
	    }
	    Reflect.getOwnMetadataKeys = getOwnMetadataKeys;
	    /**
	      * Deletes the metadata entry from the target object with the provided key.
	      * @param metadataKey A key used to store and retrieve metadata.
	      * @param target The target object on which the metadata is defined.
	      * @param targetKey (Optional) The property key for the target.
	      * @returns `true` if the metadata entry was found and deleted; otherwise, false.
	      * @example
	      *
	      *     class Example {
	      *         // property declarations are not part of ES6, though they are valid in TypeScript:
	      *         // static staticProperty;
	      *         // property;
	      *
	      *         constructor(p) { }
	      *         static staticMethod(p) { }
	      *         method(p) { }
	      *     }
	      *
	      *     // constructor
	      *     result = Reflect.deleteMetadata("custom:annotation", Example);
	      *
	      *     // property (on constructor)
	      *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
	      *
	      *     // property (on prototype)
	      *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
	      *
	      *     // method (on constructor)
	      *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
	      *
	      *     // method (on prototype)
	      *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
	      *
	      */
	    function deleteMetadata(metadataKey, target, targetKey) {
	        // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#deletemetadata-metadatakey-p-
	        if (!IsObject(target))
	            throw new TypeError();
	        if (!IsUndefined(targetKey))
	            targetKey = ToPropertyKey(targetKey);
	        var metadataMap = GetOrCreateMetadataMap(target, targetKey, /*create*/ false);
	        if (IsUndefined(metadataMap))
	            return false;
	        if (!metadataMap.delete(metadataKey))
	            return false;
	        if (metadataMap.size > 0)
	            return true;
	        var targetMetadata = Metadata.get(target);
	        targetMetadata.delete(targetKey);
	        if (targetMetadata.size > 0)
	            return true;
	        Metadata.delete(target);
	        return true;
	    }
	    Reflect.deleteMetadata = deleteMetadata;
	    function DecorateConstructor(decorators, target) {
	        for (var i = decorators.length - 1; i >= 0; --i) {
	            var decorator = decorators[i];
	            var decorated = decorator(target);
	            if (!IsUndefined(decorated) && !IsNull(decorated)) {
	                if (!IsConstructor(decorated))
	                    throw new TypeError();
	                target = decorated;
	            }
	        }
	        return target;
	    }
	    function DecorateProperty(decorators, target, propertyKey, descriptor) {
	        for (var i = decorators.length - 1; i >= 0; --i) {
	            var decorator = decorators[i];
	            var decorated = decorator(target, propertyKey, descriptor);
	            if (!IsUndefined(decorated) && !IsNull(decorated)) {
	                if (!IsObject(decorated))
	                    throw new TypeError();
	                descriptor = decorated;
	            }
	        }
	        return descriptor;
	    }
	    function GetOrCreateMetadataMap(O, P, Create) {
	        var targetMetadata = Metadata.get(O);
	        if (IsUndefined(targetMetadata)) {
	            if (!Create)
	                return undefined;
	            targetMetadata = new _Map();
	            Metadata.set(O, targetMetadata);
	        }
	        var metadataMap = targetMetadata.get(P);
	        if (IsUndefined(metadataMap)) {
	            if (!Create)
	                return undefined;
	            metadataMap = new _Map();
	            targetMetadata.set(P, metadataMap);
	        }
	        return metadataMap;
	    }
	    // Ordinary Object Internal Methods and Internal Slots
	    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinary-object-internal-methods-and-internal-slots
	    // OrdinaryHasMetadata(MetadataKey, O, P)
	    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinaryhasmetadata--metadatakey-o-p-
	    function OrdinaryHasMetadata(MetadataKey, O, P) {
	        var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
	        if (hasOwn)
	            return true;
	        var parent = OrdinaryGetPrototypeOf(O);
	        if (!IsNull(parent))
	            return OrdinaryHasMetadata(MetadataKey, parent, P);
	        return false;
	    }
	    // OrdinaryHasOwnMetadata(MetadataKey, O, P)
	    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinaryhasownmetadata--metadatakey-o-p-
	    function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
	        var metadataMap = GetOrCreateMetadataMap(O, P, /*create*/ false);
	        if (IsUndefined(metadataMap))
	            return false;
	        return ToBoolean(metadataMap.has(MetadataKey));
	    }
	    // OrdinaryGetMetadata(MetadataKey, O, P)
	    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinarygetmetadata--metadatakey-o-p-
	    function OrdinaryGetMetadata(MetadataKey, O, P) {
	        var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
	        if (hasOwn)
	            return OrdinaryGetOwnMetadata(MetadataKey, O, P);
	        var parent = OrdinaryGetPrototypeOf(O);
	        if (!IsNull(parent))
	            return OrdinaryGetMetadata(MetadataKey, parent, P);
	        return undefined;
	    }
	    // OrdinaryGetOwnMetadata(MetadataKey, O, P)
	    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinarygetownmetadata--metadatakey-o-p-
	    function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
	        var metadataMap = GetOrCreateMetadataMap(O, P, /*create*/ false);
	        if (IsUndefined(metadataMap))
	            return undefined;
	        return metadataMap.get(MetadataKey);
	    }
	    // OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
	    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinarydefineownmetadata--metadatakey-metadatavalue-o-p-
	    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
	        var metadataMap = GetOrCreateMetadataMap(O, P, /*create*/ true);
	        metadataMap.set(MetadataKey, MetadataValue);
	    }
	    // OrdinaryMetadataKeys(O, P)
	    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinarymetadatakeys--o-p-
	    function OrdinaryMetadataKeys(O, P) {
	        var ownKeys = OrdinaryOwnMetadataKeys(O, P);
	        var parent = OrdinaryGetPrototypeOf(O);
	        if (parent === null)
	            return ownKeys;
	        var parentKeys = OrdinaryMetadataKeys(parent, P);
	        if (parentKeys.length <= 0)
	            return ownKeys;
	        if (ownKeys.length <= 0)
	            return parentKeys;
	        var set = new _Set();
	        var keys = [];
	        for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
	            var key = ownKeys_1[_i];
	            var hasKey = set.has(key);
	            if (!hasKey) {
	                set.add(key);
	                keys.push(key);
	            }
	        }
	        for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
	            var key = parentKeys_1[_a];
	            var hasKey = set.has(key);
	            if (!hasKey) {
	                set.add(key);
	                keys.push(key);
	            }
	        }
	        return keys;
	    }
	    // OrdinaryOwnMetadataKeys(O, P)
	    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinaryownmetadatakeys--o-p-
	    function OrdinaryOwnMetadataKeys(O, P) {
	        var metadataMap = GetOrCreateMetadataMap(O, P, /*create*/ false);
	        var keys = [];
	        if (IsUndefined(metadataMap))
	            return keys;
	        var keysObj = metadataMap.keys();
	        var iterator = GetIterator(keysObj);
	        while (true) {
	            var next = IteratorStep(iterator);
	            try {
	                if (!next)
	                    return keys;
	                var nextValue = IteratorValue(next);
	                keys.push(nextValue);
	            }
	            catch (e) {
	                try {
	                    if (next) {
	                        next = false;
	                        IteratorClose(iterator);
	                    }
	                }
	                finally {
	                    throw e;
	                }
	            }
	            finally {
	                if (next)
	                    IteratorClose(iterator);
	            }
	        }
	    }
	    // ECMAScript Specification
	    // https://tc39.github.io/ecma262/
	    // 6 ECMAScript Data Typ0es and Values
	    // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
	    function Type(x) {
	        if (x === null)
	            return 1 /* Null */;
	        switch (typeof x) {
	            case "undefined": return 0 /* Undefined */;
	            case "boolean": return 2 /* Boolean */;
	            case "string": return 3 /* String */;
	            case "symbol": return 4 /* Symbol */;
	            case "number": return 5 /* Number */;
	            case "object": return x === null ? 1 /* Null */ : 6 /* Object */;
	            default: return 6 /* Object */;
	        }
	    }
	    // 6.1.1 The Undefined Type
	    // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
	    function IsUndefined(x) {
	        return x === undefined;
	    }
	    // 6.1.2 The Null Type
	    // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
	    function IsNull(x) {
	        return x === null;
	    }
	    // 6.1.5 The Symbol Type
	    // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
	    function IsSymbol(x) {
	        return typeof x === "symbol";
	    }
	    // 6.1.7 The Object Type
	    // https://tc39.github.io/ecma262/#sec-object-type
	    function IsObject(x) {
	        return typeof x === "object" ? x !== null : typeof x === "function";
	    }
	    // 7.1 Type Conversion
	    // https://tc39.github.io/ecma262/#sec-type-conversion
	    // 7.1.1 ToPrimitive(input [, PreferredType])
	    // https://tc39.github.io/ecma262/#sec-toprimitive
	    function ToPrimitive(input, PreferredType) {
	        switch (Type(input)) {
	            case 0 /* Undefined */: return input;
	            case 1 /* Null */: return input;
	            case 2 /* Boolean */: return input;
	            case 3 /* String */: return input;
	            case 4 /* Symbol */: return input;
	            case 5 /* Number */: return input;
	        }
	        var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
	        var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
	        if (exoticToPrim !== undefined) {
	            var result = exoticToPrim.call(input, hint);
	            if (IsObject(result))
	                throw new TypeError();
	            return result;
	        }
	        return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
	    }
	    // 7.1.1.1 OrdinaryToPrimitive(O, hint)
	    // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
	    function OrdinaryToPrimitive(O, hint) {
	        if (hint === "string") {
	            var toString_1 = O.toString;
	            if (IsCallable(toString_1)) {
	                var result = toString_1.call(O);
	                if (!IsObject(result))
	                    return result;
	            }
	            var valueOf = O.valueOf;
	            if (IsCallable(valueOf)) {
	                var result = valueOf.call(O);
	                if (!IsObject(result))
	                    return result;
	            }
	        }
	        else {
	            var valueOf = O.valueOf;
	            if (IsCallable(valueOf)) {
	                var result = valueOf.call(O);
	                if (!IsObject(result))
	                    return result;
	            }
	            var toString_2 = O.toString;
	            if (IsCallable(toString_2)) {
	                var result = toString_2.call(O);
	                if (!IsObject(result))
	                    return result;
	            }
	        }
	        throw new TypeError();
	    }
	    // 7.1.2 ToBoolean(argument)
	    // https://tc39.github.io/ecma262/2016/#sec-toboolean
	    function ToBoolean(argument) {
	        return !!argument;
	    }
	    // 7.1.12 ToString(argument)
	    // https://tc39.github.io/ecma262/#sec-tostring
	    function ToString(argument) {
	        return "" + argument;
	    }
	    // 7.1.14 ToPropertyKey(argument)
	    // https://tc39.github.io/ecma262/#sec-topropertykey
	    function ToPropertyKey(argument) {
	        var key = ToPrimitive(argument, 3 /* String */);
	        if (IsSymbol(key))
	            return key;
	        return ToString(key);
	    }
	    // 7.2 Testing and Comparison Operations
	    // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
	    // 7.2.2 IsArray(argument)
	    // https://tc39.github.io/ecma262/#sec-isarray
	    function IsArray(argument) {
	        return Array.isArray
	            ? Array.isArray(argument)
	            : argument instanceof Object
	                ? argument instanceof Array
	                : Object.prototype.toString.call(argument) === "[object Array]";
	    }
	    // 7.2.3 IsCallable(argument)
	    // https://tc39.github.io/ecma262/#sec-iscallable
	    function IsCallable(argument) {
	        // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
	        return typeof argument === "function";
	    }
	    // 7.2.4 IsConstructor(argument)
	    // https://tc39.github.io/ecma262/#sec-isconstructor
	    function IsConstructor(argument) {
	        // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
	        return typeof argument === "function";
	    }
	    // 7.3 Operations on Objects
	    // https://tc39.github.io/ecma262/#sec-operations-on-objects
	    // 7.3.9 GetMethod(V, P)
	    // https://tc39.github.io/ecma262/#sec-getmethod
	    function GetMethod(V, P) {
	        var func = V[P];
	        if (func === undefined || func === null)
	            return undefined;
	        if (!IsCallable(func))
	            throw new TypeError();
	        return func;
	    }
	    // 7.4 Operations on Iterator Objects
	    // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
	    function GetIterator(obj) {
	        var method = GetMethod(obj, iteratorSymbol);
	        if (!IsCallable(method))
	            throw new TypeError(); // from Call
	        var iterator = method.call(obj);
	        if (!IsObject(iterator))
	            throw new TypeError();
	        return iterator;
	    }
	    // 7.4.4 IteratorValue(iterResult)
	    // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
	    function IteratorValue(iterResult) {
	        return iterResult.value;
	    }
	    // 7.4.5 IteratorStep(iterator)
	    // https://tc39.github.io/ecma262/#sec-iteratorstep
	    function IteratorStep(iterator) {
	        var result = iterator.next();
	        return result.done ? false : result;
	    }
	    // 7.4.6 IteratorClose(iterator, completion)
	    // https://tc39.github.io/ecma262/#sec-iteratorclose
	    function IteratorClose(iterator) {
	        var f = iterator["return"];
	        if (f)
	            f.call(iterator);
	    }
	    // 9.1 Ordinary Object Internal Methods and Internal Slots
	    // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
	    // 9.1.1.1 OrdinaryGetPrototypeOf(O)
	    // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
	    function OrdinaryGetPrototypeOf(O) {
	        var proto = Object.getPrototypeOf(O);
	        if (typeof O !== "function" || O === functionPrototype)
	            return proto;
	        // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
	        // Try to determine the superclass constructor. Compatible implementations
	        // must either set __proto__ on a subclass constructor to the superclass constructor,
	        // or ensure each class has a valid `constructor` property on its prototype that
	        // points back to the constructor.
	        // If this is not the same as Function.[[Prototype]], then this is definately inherited.
	        // This is the case when in ES6 or when using __proto__ in a compatible browser.
	        if (proto !== functionPrototype)
	            return proto;
	        // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
	        var prototype = O.prototype;
	        var prototypeProto = prototype && Object.getPrototypeOf(prototype);
	        if (prototypeProto == null || prototypeProto === Object.prototype)
	            return proto;
	        // If the constructor was not a function, then we cannot determine the heritage.
	        var constructor = prototypeProto.constructor;
	        if (typeof constructor !== "function")
	            return proto;
	        // If we have some kind of self-reference, then we cannot determine the heritage.
	        if (constructor === O)
	            return proto;
	        // we have a pretty good guess at the heritage.
	        return constructor;
	    }
	    // naive Map shim
	    function CreateMapPolyfill() {
	        var cacheSentinel = {};
	        var arraySentinel = [];
	        var MapIterator = (function () {
	            function MapIterator(keys, values, selector) {
	                this._index = 0;
	                this._keys = keys;
	                this._values = values;
	                this._selector = selector;
	            }
	            MapIterator.prototype["@@iterator"] = function () { return this; };
	            MapIterator.prototype[iteratorSymbol] = function () { return this; };
	            MapIterator.prototype.next = function () {
	                var index = this._index;
	                if (index >= 0 && index < this._keys.length) {
	                    var result = this._selector(this._keys[index], this._values[index]);
	                    if (index + 1 >= this._keys.length) {
	                        this._index = -1;
	                        this._keys = arraySentinel;
	                        this._values = arraySentinel;
	                    }
	                    else {
	                        this._index++;
	                    }
	                    return { value: result, done: false };
	                }
	                return { value: undefined, done: true };
	            };
	            MapIterator.prototype.throw = function (error) {
	                if (this._index >= 0) {
	                    this._index = -1;
	                    this._keys = arraySentinel;
	                    this._values = arraySentinel;
	                }
	                throw error;
	            };
	            MapIterator.prototype.return = function (value) {
	                if (this._index >= 0) {
	                    this._index = -1;
	                    this._keys = arraySentinel;
	                    this._values = arraySentinel;
	                }
	                return { value: value, done: true };
	            };
	            return MapIterator;
	        }());
	        return (function () {
	            function Map() {
	                this._keys = [];
	                this._values = [];
	                this._cacheKey = cacheSentinel;
	                this._cacheIndex = -2;
	            }
	            Object.defineProperty(Map.prototype, "size", {
	                get: function () { return this._keys.length; },
	                enumerable: true,
	                configurable: true
	            });
	            Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };
	            Map.prototype.get = function (key) {
	                var index = this._find(key, /*insert*/ false);
	                return index >= 0 ? this._values[index] : undefined;
	            };
	            Map.prototype.set = function (key, value) {
	                var index = this._find(key, /*insert*/ true);
	                this._values[index] = value;
	                return this;
	            };
	            Map.prototype.delete = function (key) {
	                var index = this._find(key, /*insert*/ false);
	                if (index >= 0) {
	                    var size = this._keys.length;
	                    for (var i = index + 1; i < size; i++) {
	                        this._keys[i - 1] = this._keys[i];
	                        this._values[i - 1] = this._values[i];
	                    }
	                    this._keys.length--;
	                    this._values.length--;
	                    if (key === this._cacheKey) {
	                        this._cacheKey = cacheSentinel;
	                        this._cacheIndex = -2;
	                    }
	                    return true;
	                }
	                return false;
	            };
	            Map.prototype.clear = function () {
	                this._keys.length = 0;
	                this._values.length = 0;
	                this._cacheKey = cacheSentinel;
	                this._cacheIndex = -2;
	            };
	            Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };
	            Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };
	            Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };
	            Map.prototype["@@iterator"] = function () { return this.entries(); };
	            Map.prototype[iteratorSymbol] = function () { return this.entries(); };
	            Map.prototype._find = function (key, insert) {
	                if (this._cacheKey === key)
	                    return this._cacheIndex;
	                var index = this._keys.indexOf(key);
	                if (index < 0 && insert) {
	                    index = this._keys.length;
	                    this._keys.push(key);
	                    this._values.push(undefined);
	                }
	                return this._cacheKey = key, this._cacheIndex = index;
	            };
	            return Map;
	        }());
	        function getKey(key, _) {
	            return key;
	        }
	        function getValue(_, value) {
	            return value;
	        }
	        function getEntry(key, value) {
	            return [key, value];
	        }
	    }
	    // naive Set shim
	    function CreateSetPolyfill() {
	        return (function () {
	            function Set() {
	                this._map = new _Map();
	            }
	            Object.defineProperty(Set.prototype, "size", {
	                get: function () { return this._map.size; },
	                enumerable: true,
	                configurable: true
	            });
	            Set.prototype.has = function (value) { return this._map.has(value); };
	            Set.prototype.add = function (value) { return this._map.set(value, value), this; };
	            Set.prototype.delete = function (value) { return this._map.delete(value); };
	            Set.prototype.clear = function () { this._map.clear(); };
	            Set.prototype.keys = function () { return this._map.keys(); };
	            Set.prototype.values = function () { return this._map.values(); };
	            Set.prototype.entries = function () { return this._map.entries(); };
	            Set.prototype["@@iterator"] = function () { return this.keys(); };
	            Set.prototype[iteratorSymbol] = function () { return this.keys(); };
	            return Set;
	        }());
	    }
	    // naive WeakMap shim
	    function CreateWeakMapPolyfill() {
	        var UUID_SIZE = 16;
	        var keys = createDictionary();
	        var rootKey = CreateUniqueKey();
	        return (function () {
	            function WeakMap() {
	                this._key = CreateUniqueKey();
	            }
	            WeakMap.prototype.has = function (target) {
	                var table = GetOrCreateWeakMapTable(target, /*create*/ false);
	                return table !== undefined ? HashMap.has(table, this._key) : false;
	            };
	            WeakMap.prototype.get = function (target) {
	                var table = GetOrCreateWeakMapTable(target, /*create*/ false);
	                return table !== undefined ? HashMap.get(table, this._key) : undefined;
	            };
	            WeakMap.prototype.set = function (target, value) {
	                var table = GetOrCreateWeakMapTable(target, /*create*/ true);
	                table[this._key] = value;
	                return this;
	            };
	            WeakMap.prototype.delete = function (target) {
	                var table = GetOrCreateWeakMapTable(target, /*create*/ false);
	                return table !== undefined ? delete table[this._key] : false;
	            };
	            WeakMap.prototype.clear = function () {
	                // NOTE: not a real clear, just makes the previous data unreachable
	                this._key = CreateUniqueKey();
	            };
	            return WeakMap;
	        }());
	        function CreateUniqueKey() {
	            var key;
	            do
	                key = "@@WeakMap@@" + CreateUUID();
	            while (HashMap.has(keys, key));
	            keys[key] = true;
	            return key;
	        }
	        function GetOrCreateWeakMapTable(target, create) {
	            if (!hasOwn.call(target, rootKey)) {
	                if (!create)
	                    return undefined;
	                Object.defineProperty(target, rootKey, { value: createDictionary() });
	            }
	            return target[rootKey];
	        }
	        function FillRandomBytes(buffer, size) {
	            for (var i = 0; i < size; ++i)
	                buffer[i] = Math.random() * 0xff | 0;
	            return buffer;
	        }
	        function GenRandomBytes(size) {
	            if (typeof Uint8Array === "function") {
	                if (typeof crypto !== "undefined")
	                    return crypto.getRandomValues(new Uint8Array(size));
	                if (typeof msCrypto !== "undefined")
	                    return msCrypto.getRandomValues(new Uint8Array(size));
	                return FillRandomBytes(new Uint8Array(size), size);
	            }
	            return FillRandomBytes(new Array(size), size);
	        }
	        function CreateUUID() {
	            var data = GenRandomBytes(UUID_SIZE);
	            // mark as random - RFC 4122 § 4.4
	            data[6] = data[6] & 0x4f | 0x40;
	            data[8] = data[8] & 0xbf | 0x80;
	            var result = "";
	            for (var offset = 0; offset < UUID_SIZE; ++offset) {
	                var byte = data[offset];
	                if (offset === 4 || offset === 6 || offset === 8)
	                    result += "-";
	                if (byte < 16)
	                    result += "0";
	                result += byte.toString(16).toLowerCase();
	            }
	            return result;
	        }
	    }
	    // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
	    function MakeDictionary(obj) {
	        obj.__ = undefined;
	        delete obj.__;
	        return obj;
	    }
	    // patch global Reflect
	    (function (__global) {
	        if (typeof __global.Reflect !== "undefined") {
	            if (__global.Reflect !== Reflect) {
	                for (var p in Reflect) {
	                    if (hasOwn.call(Reflect, p)) {
	                        __global.Reflect[p] = Reflect[p];
	                    }
	                }
	            }
	        }
	        else {
	            __global.Reflect = Reflect;
	        }
	    })(typeof global !== "undefined" ? global :
	        typeof self !== "undefined" ? self :
	            Function("return this;")());
	})(Reflect || (Reflect = {}));
	//# sourceMappingURL=Reflect.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * @license Angular v2.4.4
	 * (c) 2010-2016 Google, Inc. https://angular.io/
	 * License: MIT
	 */
	(function (global, factory) {
	     true ? factory(exports, __webpack_require__(29), __webpack_require__(30)) :
	    typeof define === 'function' && define.amd ? define(['exports', 'rxjs/Subject', 'rxjs/Observable'], factory) :
	    (factory((global.ng = global.ng || {}, global.ng.core = global.ng.core || {}),global.Rx,global.Rx));
	}(this, function (exports,rxjs_Subject,rxjs_Observable) { 'use strict';

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var /** @type {?} */ globalScope;
	    if (typeof window === 'undefined') {
	        if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
	            // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
	            globalScope = (self);
	        }
	        else {
	            globalScope = (global);
	        }
	    }
	    else {
	        globalScope = (window);
	    }
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    function scheduleMicroTask(fn) {
	        Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
	    }
	    // Need to declare a new variable for global here since TypeScript
	    // exports the original value of the symbol.
	    var /** @type {?} */ global$1 = globalScope;
	    /**
	     * @param {?} type
	     * @return {?}
	     */
	    function getTypeNameForDebugging(type) {
	        return type['name'] || typeof type;
	    }
	    // TODO: remove calls to assert in production environment
	    // Note: Can't just export this and import in in other files
	    // as `assert` is a reserved keyword in Dart
	    global$1.assert = function assert(condition) {
	        // TODO: to be fixed properly via #2830, noop for now
	    };
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isPresent(obj) {
	        return obj != null;
	    }
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isBlank(obj) {
	        return obj == null;
	    }
	    /**
	     * @param {?} token
	     * @return {?}
	     */
	    function stringify(token) {
	        if (typeof token === 'string') {
	            return token;
	        }
	        if (token == null) {
	            return '' + token;
	        }
	        if (token.overriddenName) {
	            return "" + token.overriddenName;
	        }
	        if (token.name) {
	            return "" + token.name;
	        }
	        var /** @type {?} */ res = token.toString();
	        var /** @type {?} */ newLineIndex = res.indexOf('\n');
	        return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
	    }
	    /**
	     * @param {?} a
	     * @param {?} b
	     * @return {?}
	     */
	    function looseIdentical(a, b) {
	        return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);
	    }
	    /**
	     * @param {?} o
	     * @return {?}
	     */
	    function isJsObject(o) {
	        return o !== null && (typeof o === 'function' || typeof o === 'object');
	    }
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function print(obj) {
	        // tslint:disable-next-line:no-console
	        console.log(obj);
	    }
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function warn(obj) {
	        console.warn(obj);
	    }
	    var /** @type {?} */ _symbolIterator = null;
	    /**
	     * @return {?}
	     */
	    function getSymbolIterator() {
	        if (!_symbolIterator) {
	            if (((globalScope)).Symbol && Symbol.iterator) {
	                _symbolIterator = Symbol.iterator;
	            }
	            else {
	                // es6-shim specific logic
	                var /** @type {?} */ keys = Object.getOwnPropertyNames(Map.prototype);
	                for (var /** @type {?} */ i = 0; i < keys.length; ++i) {
	                    var /** @type {?} */ key = keys[i];
	                    if (key !== 'entries' && key !== 'size' &&
	                        ((Map)).prototype[key] === Map.prototype['entries']) {
	                        _symbolIterator = key;
	                    }
	                }
	            }
	        }
	        return _symbolIterator;
	    }
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isPrimitive(obj) {
	        return !isJsObject(obj);
	    }

	    var /** @type {?} */ _nextClassId = 0;
	    var /** @type {?} */ Reflect = global$1.Reflect;
	    /**
	     * @param {?} annotation
	     * @return {?}
	     */
	    function extractAnnotation(annotation) {
	        if (typeof annotation === 'function' && annotation.hasOwnProperty('annotation')) {
	            // it is a decorator, extract annotation
	            annotation = annotation.annotation;
	        }
	        return annotation;
	    }
	    /**
	     * @param {?} fnOrArray
	     * @param {?} key
	     * @return {?}
	     */
	    function applyParams(fnOrArray, key) {
	        if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function ||
	            fnOrArray === Number || fnOrArray === Array) {
	            throw new Error("Can not use native " + stringify(fnOrArray) + " as constructor");
	        }
	        if (typeof fnOrArray === 'function') {
	            return fnOrArray;
	        }
	        if (Array.isArray(fnOrArray)) {
	            var /** @type {?} */ annotations = fnOrArray;
	            var /** @type {?} */ annoLength = annotations.length - 1;
	            var /** @type {?} */ fn = fnOrArray[annoLength];
	            if (typeof fn !== 'function') {
	                throw new Error("Last position of Class method array must be Function in key " + key + " was '" + stringify(fn) + "'");
	            }
	            if (annoLength != fn.length) {
	                throw new Error("Number of annotations (" + annoLength + ") does not match number of arguments (" + fn.length + ") in the function: " + stringify(fn));
	            }
	            var /** @type {?} */ paramsAnnotations = [];
	            for (var /** @type {?} */ i = 0, /** @type {?} */ ii = annotations.length - 1; i < ii; i++) {
	                var /** @type {?} */ paramAnnotations = [];
	                paramsAnnotations.push(paramAnnotations);
	                var /** @type {?} */ annotation = annotations[i];
	                if (Array.isArray(annotation)) {
	                    for (var /** @type {?} */ j = 0; j < annotation.length; j++) {
	                        paramAnnotations.push(extractAnnotation(annotation[j]));
	                    }
	                }
	                else if (typeof annotation === 'function') {
	                    paramAnnotations.push(extractAnnotation(annotation));
	                }
	                else {
	                    paramAnnotations.push(annotation);
	                }
	            }
	            Reflect.defineMetadata('parameters', paramsAnnotations, fn);
	            return fn;
	        }
	        throw new Error("Only Function or Array is supported in Class definition for key '" + key + "' is '" + stringify(fnOrArray) + "'");
	    }
	    /**
	     * Provides a way for expressing ES6 classes with parameter annotations in ES5.
	     *
	     * ## Basic Example
	     *
	     * ```
	     * var Greeter = ng.Class({
	     *   constructor: function(name) {
	     *     this.name = name;
	     *   },
	     *
	     *   greet: function() {
	     *     alert('Hello ' + this.name + '!');
	     *   }
	     * });
	     * ```
	     *
	     * is equivalent to ES6:
	     *
	     * ```
	     * class Greeter {
	     *   constructor(name) {
	     *     this.name = name;
	     *   }
	     *
	     *   greet() {
	     *     alert('Hello ' + this.name + '!');
	     *   }
	     * }
	     * ```
	     *
	     * or equivalent to ES5:
	     *
	     * ```
	     * var Greeter = function (name) {
	     *   this.name = name;
	     * }
	     *
	     * Greeter.prototype.greet = function () {
	     *   alert('Hello ' + this.name + '!');
	     * }
	     * ```
	     *
	     * ### Example with parameter annotations
	     *
	     * ```
	     * var MyService = ng.Class({
	     *   constructor: [String, [new Optional(), Service], function(name, myService) {
	     *     ...
	     *   }]
	     * });
	     * ```
	     *
	     * is equivalent to ES6:
	     *
	     * ```
	     * class MyService {
	     *   constructor(name: string, \@Optional() myService: Service) {
	     *     ...
	     *   }
	     * }
	     * ```
	     *
	     * ### Example with inheritance
	     *
	     * ```
	     * var Shape = ng.Class({
	     *   constructor: (color) {
	     *     this.color = color;
	     *   }
	     * });
	     *
	     * var Square = ng.Class({
	     *   extends: Shape,
	     *   constructor: function(color, size) {
	     *     Shape.call(this, color);
	     *     this.size = size;
	     *   }
	     * });
	     * ```
	     * \@stable
	     * @param {?} clsDef
	     * @return {?}
	     */
	    function Class(clsDef) {
	        var /** @type {?} */ constructor = applyParams(clsDef.hasOwnProperty('constructor') ? clsDef.constructor : undefined, 'constructor');
	        var /** @type {?} */ proto = constructor.prototype;
	        if (clsDef.hasOwnProperty('extends')) {
	            if (typeof clsDef.extends === 'function') {
	                ((constructor)).prototype = proto =
	                    Object.create(((clsDef.extends)).prototype);
	            }
	            else {
	                throw new Error("Class definition 'extends' property must be a constructor function was: " + stringify(clsDef.extends));
	            }
	        }
	        for (var key in clsDef) {
	            if (key !== 'extends' && key !== 'prototype' && clsDef.hasOwnProperty(key)) {
	                proto[key] = applyParams(clsDef[key], key);
	            }
	        }
	        if (this && this.annotations instanceof Array) {
	            Reflect.defineMetadata('annotations', this.annotations, constructor);
	        }
	        var /** @type {?} */ constructorName = constructor['name'];
	        if (!constructorName || constructorName === 'constructor') {
	            ((constructor))['overriddenName'] = "class" + _nextClassId++;
	        }
	        return (constructor);
	    }
	    /**
	     * @param {?} name
	     * @param {?} props
	     * @param {?=} parentClass
	     * @param {?=} chainFn
	     * @return {?}
	     */
	    function makeDecorator(name, props, parentClass, chainFn) {
	        if (chainFn === void 0) { chainFn = null; }
	        var /** @type {?} */ metaCtor = makeMetadataCtor([props]);
	        /**
	         * @param {?} objOrType
	         * @return {?}
	         */
	        function DecoratorFactory(objOrType) {
	            if (!(Reflect && Reflect.getOwnMetadata)) {
	                throw 'reflect-metadata shim is required when using class decorators';
	            }
	            if (this instanceof DecoratorFactory) {
	                metaCtor.call(this, objOrType);
	                return this;
	            }
	            var /** @type {?} */ annotationInstance = new ((DecoratorFactory))(objOrType);
	            var /** @type {?} */ chainAnnotation = typeof this === 'function' && Array.isArray(this.annotations) ? this.annotations : [];
	            chainAnnotation.push(annotationInstance);
	            var /** @type {?} */ TypeDecorator = (function TypeDecorator(cls) {
	                var /** @type {?} */ annotations = Reflect.getOwnMetadata('annotations', cls) || [];
	                annotations.push(annotationInstance);
	                Reflect.defineMetadata('annotations', annotations, cls);
	                return cls;
	            });
	            TypeDecorator.annotations = chainAnnotation;
	            TypeDecorator.Class = Class;
	            if (chainFn)
	                chainFn(TypeDecorator);
	            return TypeDecorator;
	        }
	        if (parentClass) {
	            DecoratorFactory.prototype = Object.create(parentClass.prototype);
	        }
	        DecoratorFactory.prototype.toString = function () { return ("@" + name); };
	        ((DecoratorFactory)).annotationCls = DecoratorFactory;
	        return DecoratorFactory;
	    }
	    /**
	     * @param {?} props
	     * @return {?}
	     */
	    function makeMetadataCtor(props) {
	        return function ctor() {
	            var _this = this;
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i - 0] = arguments[_i];
	            }
	            props.forEach(function (prop, i) {
	                var /** @type {?} */ argVal = args[i];
	                if (Array.isArray(prop)) {
	                    // plain parameter
	                    _this[prop[0]] = argVal === undefined ? prop[1] : argVal;
	                }
	                else {
	                    for (var propName in prop) {
	                        _this[propName] =
	                            argVal && argVal.hasOwnProperty(propName) ? argVal[propName] : prop[propName];
	                    }
	                }
	            });
	        };
	    }
	    /**
	     * @param {?} name
	     * @param {?} props
	     * @param {?=} parentClass
	     * @return {?}
	     */
	    function makeParamDecorator(name, props, parentClass) {
	        var /** @type {?} */ metaCtor = makeMetadataCtor(props);
	        /**
	         * @param {...?} args
	         * @return {?}
	         */
	        function ParamDecoratorFactory() {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i - 0] = arguments[_i];
	            }
	            if (this instanceof ParamDecoratorFactory) {
	                metaCtor.apply(this, args);
	                return this;
	            }
	            var /** @type {?} */ annotationInstance = new ((_a = ((ParamDecoratorFactory))).bind.apply(_a, [void 0].concat(args)))();
	            ((ParamDecorator)).annotation = annotationInstance;
	            return ParamDecorator;
	            /**
	             * @param {?} cls
	             * @param {?} unusedKey
	             * @param {?} index
	             * @return {?}
	             */
	            function ParamDecorator(cls, unusedKey, index) {
	                var /** @type {?} */ parameters = Reflect.getOwnMetadata('parameters', cls) || [];
	                // there might be gaps if some in between parameters do not have annotations.
	                // we pad with nulls.
	                while (parameters.length <= index) {
	                    parameters.push(null);
	                }
	                parameters[index] = parameters[index] || [];
	                parameters[index].push(annotationInstance);
	                Reflect.defineMetadata('parameters', parameters, cls);
	                return cls;
	            }
	            var _a;
	        }
	        if (parentClass) {
	            ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);
	        }
	        ParamDecoratorFactory.prototype.toString = function () { return ("@" + name); };
	        ((ParamDecoratorFactory)).annotationCls = ParamDecoratorFactory;
	        return ParamDecoratorFactory;
	    }
	    /**
	     * @param {?} name
	     * @param {?} props
	     * @param {?=} parentClass
	     * @return {?}
	     */
	    function makePropDecorator(name, props, parentClass) {
	        var /** @type {?} */ metaCtor = makeMetadataCtor(props);
	        /**
	         * @param {...?} args
	         * @return {?}
	         */
	        function PropDecoratorFactory() {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i - 0] = arguments[_i];
	            }
	            if (this instanceof PropDecoratorFactory) {
	                metaCtor.apply(this, args);
	                return this;
	            }
	            var /** @type {?} */ decoratorInstance = new ((_a = ((PropDecoratorFactory))).bind.apply(_a, [void 0].concat(args)))();
	            return function PropDecorator(target, name) {
	                var /** @type {?} */ meta = Reflect.getOwnMetadata('propMetadata', target.constructor) || {};
	                meta[name] = meta.hasOwnProperty(name) && meta[name] || [];
	                meta[name].unshift(decoratorInstance);
	                Reflect.defineMetadata('propMetadata', meta, target.constructor);
	            };
	            var _a;
	        }
	        if (parentClass) {
	            PropDecoratorFactory.prototype = Object.create(parentClass.prototype);
	        }
	        PropDecoratorFactory.prototype.toString = function () { return ("@" + name); };
	        ((PropDecoratorFactory)).annotationCls = PropDecoratorFactory;
	        return PropDecoratorFactory;
	    }

	    /**
	     * Inject decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ Inject = makeParamDecorator('Inject', [['token', undefined]]);
	    /**
	     * Optional decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ Optional = makeParamDecorator('Optional', []);
	    /**
	     * Injectable decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ Injectable = (makeDecorator('Injectable', []));
	    /**
	     * Self decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ Self = makeParamDecorator('Self', []);
	    /**
	     * SkipSelf decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ SkipSelf = makeParamDecorator('SkipSelf', []);
	    /**
	     * Host decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ Host = makeParamDecorator('Host', []);

	    var OpaqueToken = (function () {
	        /**
	         * @param {?} _desc
	         */
	        function OpaqueToken(_desc) {
	            this._desc = _desc;
	        }
	        /**
	         * @return {?}
	         */
	        OpaqueToken.prototype.toString = function () { return "Token " + this._desc; };
	        OpaqueToken.decorators = [
	            { type: Injectable },
	        ];
	        /** @nocollapse */
	        OpaqueToken.ctorParameters = function () { return [
	            null,
	        ]; };
	        return OpaqueToken;
	    }());

	    /**
	     * This token can be used to create a virtual provider that will populate the
	     * `entryComponents` fields of components and ng modules based on its `useValue`.
	     * All components that are referenced in the `useValue` value (either directly
	     * or in a nested array or map) will be added to the `entryComponents` property.
	     *
	     * ### Example
	     * The following example shows how the router can populate the `entryComponents`
	     * field of an NgModule based on the router configuration which refers
	     * to components.
	     *
	     * ```typescript
	     * // helper function inside the router
	     * function provideRoutes(routes) {
	     *   return [
	     *     {provide: ROUTES, useValue: routes},
	     *     {provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: routes, multi: true}
	     *   ];
	     * }
	     *
	     * // user code
	     * let routes = [
	     *   {path: '/root', component: RootComp},
	     *   {path: '/teams', component: TeamsComp}
	     * ];
	     *
	     * @NgModule({
	     *   providers: [provideRoutes(routes)]
	     * })
	     * class ModuleWithRoutes {}
	     * ```
	     *
	     * @experimental
	     */
	    var /** @type {?} */ ANALYZE_FOR_ENTRY_COMPONENTS = new OpaqueToken('AnalyzeForEntryComponents');
	    /**
	     * Attribute decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ Attribute = makeParamDecorator('Attribute', [['attributeName', undefined]]);
	    /**
	     * Base class for query metadata.
	     *
	     * See {\@link ContentChildren}, {\@link ContentChild}, {\@link ViewChildren}, {\@link ViewChild} for
	     * more information.
	     *
	     * \@stable
	     * @abstract
	     */
	    var Query = (function () {
	        function Query() {
	        }
	        return Query;
	    }());
	    /**
	     * ContentChildren decorator and metadata.
	     *
	     *  @stable
	     *  @Annotation
	     */
	    var /** @type {?} */ ContentChildren = (makePropDecorator('ContentChildren', [
	        ['selector', undefined], {
	            first: false,
	            isViewQuery: false,
	            descendants: false,
	            read: undefined,
	        }
	    ], Query));
	    /**
	     * ContentChild decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ ContentChild = makePropDecorator('ContentChild', [
	        ['selector', undefined], {
	            first: true,
	            isViewQuery: false,
	            descendants: true,
	            read: undefined,
	        }
	    ], Query);
	    /**
	     * ViewChildren decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ ViewChildren = makePropDecorator('ViewChildren', [
	        ['selector', undefined], {
	            first: false,
	            isViewQuery: true,
	            descendants: true,
	            read: undefined,
	        }
	    ], Query);
	    /**
	     * ViewChild decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ ViewChild = makePropDecorator('ViewChild', [
	        ['selector', undefined], {
	            first: true,
	            isViewQuery: true,
	            descendants: true,
	            read: undefined,
	        }
	    ], Query);

	    var ChangeDetectionStrategy = {};
	    ChangeDetectionStrategy.OnPush = 0;
	    ChangeDetectionStrategy.Default = 1;
	    ChangeDetectionStrategy[ChangeDetectionStrategy.OnPush] = "OnPush";
	    ChangeDetectionStrategy[ChangeDetectionStrategy.Default] = "Default";
	    var ChangeDetectorStatus = {};
	    ChangeDetectorStatus.CheckOnce = 0;
	    ChangeDetectorStatus.Checked = 1;
	    ChangeDetectorStatus.CheckAlways = 2;
	    ChangeDetectorStatus.Detached = 3;
	    ChangeDetectorStatus.Errored = 4;
	    ChangeDetectorStatus.Destroyed = 5;
	    ChangeDetectorStatus[ChangeDetectorStatus.CheckOnce] = "CheckOnce";
	    ChangeDetectorStatus[ChangeDetectorStatus.Checked] = "Checked";
	    ChangeDetectorStatus[ChangeDetectorStatus.CheckAlways] = "CheckAlways";
	    ChangeDetectorStatus[ChangeDetectorStatus.Detached] = "Detached";
	    ChangeDetectorStatus[ChangeDetectorStatus.Errored] = "Errored";
	    ChangeDetectorStatus[ChangeDetectorStatus.Destroyed] = "Destroyed";
	    /**
	     * @param {?} changeDetectionStrategy
	     * @return {?}
	     */
	    function isDefaultChangeDetectionStrategy(changeDetectionStrategy) {
	        return isBlank(changeDetectionStrategy) ||
	            changeDetectionStrategy === ChangeDetectionStrategy.Default;
	    }

	    /**
	     * Directive decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ Directive = (makeDecorator('Directive', {
	        selector: undefined,
	        inputs: undefined,
	        outputs: undefined,
	        host: undefined,
	        providers: undefined,
	        exportAs: undefined,
	        queries: undefined
	    }));
	    /**
	     * Component decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ Component = (makeDecorator('Component', {
	        selector: undefined,
	        inputs: undefined,
	        outputs: undefined,
	        host: undefined,
	        exportAs: undefined,
	        moduleId: undefined,
	        providers: undefined,
	        viewProviders: undefined,
	        changeDetection: ChangeDetectionStrategy.Default,
	        queries: undefined,
	        templateUrl: undefined,
	        template: undefined,
	        styleUrls: undefined,
	        styles: undefined,
	        animations: undefined,
	        encapsulation: undefined,
	        interpolation: undefined,
	        entryComponents: undefined
	    }, Directive));
	    /**
	     * Pipe decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ Pipe = (makeDecorator('Pipe', {
	        name: undefined,
	        pure: true,
	    }));
	    /**
	     * Input decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ Input = makePropDecorator('Input', [['bindingPropertyName', undefined]]);
	    /**
	     * Output decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ Output = makePropDecorator('Output', [['bindingPropertyName', undefined]]);
	    /**
	     * HostBinding decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ HostBinding = makePropDecorator('HostBinding', [['hostPropertyName', undefined]]);
	    /**
	     * HostListener decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ HostListener = makePropDecorator('HostListener', [['eventName', undefined], ['args', []]]);

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var LifecycleHooks = {};
	    LifecycleHooks.OnInit = 0;
	    LifecycleHooks.OnDestroy = 1;
	    LifecycleHooks.DoCheck = 2;
	    LifecycleHooks.OnChanges = 3;
	    LifecycleHooks.AfterContentInit = 4;
	    LifecycleHooks.AfterContentChecked = 5;
	    LifecycleHooks.AfterViewInit = 6;
	    LifecycleHooks.AfterViewChecked = 7;
	    LifecycleHooks[LifecycleHooks.OnInit] = "OnInit";
	    LifecycleHooks[LifecycleHooks.OnDestroy] = "OnDestroy";
	    LifecycleHooks[LifecycleHooks.DoCheck] = "DoCheck";
	    LifecycleHooks[LifecycleHooks.OnChanges] = "OnChanges";
	    LifecycleHooks[LifecycleHooks.AfterContentInit] = "AfterContentInit";
	    LifecycleHooks[LifecycleHooks.AfterContentChecked] = "AfterContentChecked";
	    LifecycleHooks[LifecycleHooks.AfterViewInit] = "AfterViewInit";
	    LifecycleHooks[LifecycleHooks.AfterViewChecked] = "AfterViewChecked";
	    var /** @type {?} */ LIFECYCLE_HOOKS_VALUES = [
	        LifecycleHooks.OnInit, LifecycleHooks.OnDestroy, LifecycleHooks.DoCheck, LifecycleHooks.OnChanges,
	        LifecycleHooks.AfterContentInit, LifecycleHooks.AfterContentChecked, LifecycleHooks.AfterViewInit,
	        LifecycleHooks.AfterViewChecked
	    ];
	    /**
	     * \@whatItDoes Lifecycle hook that is called when any data-bound property of a directive changes.
	     * \@howToUse
	     * {\@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnChanges'}
	     *
	     * \@description
	     * `ngOnChanges` is called right after the data-bound properties have been checked and before view
	     * and content children are checked if at least one of them has changed.
	     * The `changes` parameter contains the changed properties.
	     *
	     * See {\@linkDocs guide/lifecycle-hooks#onchanges "Lifecycle Hooks Guide"}.
	     *
	     * \@stable
	     * @abstract
	     */
	    var OnChanges = (function () {
	        function OnChanges() {
	        }
	        /**
	         * @abstract
	         * @param {?} changes
	         * @return {?}
	         */
	        OnChanges.prototype.ngOnChanges = function (changes) { };
	        return OnChanges;
	    }());
	    /**
	     * \@whatItDoes Lifecycle hook that is called after data-bound properties of a directive are
	     * initialized.
	     * \@howToUse
	     * {\@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnInit'}
	     *
	     * \@description
	     * `ngOnInit` is called right after the directive's data-bound properties have been checked for the
	     * first time, and before any of its children have been checked. It is invoked only once when the
	     * directive is instantiated.
	     *
	     * See {\@linkDocs guide/lifecycle-hooks "Lifecycle Hooks Guide"}.
	     *
	     * \@stable
	     * @abstract
	     */
	    var OnInit = (function () {
	        function OnInit() {
	        }
	        /**
	         * @abstract
	         * @return {?}
	         */
	        OnInit.prototype.ngOnInit = function () { };
	        return OnInit;
	    }());
	    /**
	     * \@whatItDoes Lifecycle hook that is called when Angular dirty checks a directive.
	     * \@howToUse
	     * {\@example core/ts/metadata/lifecycle_hooks_spec.ts region='DoCheck'}
	     *
	     * \@description
	     * `ngDoCheck` gets called to check the changes in the directives in addition to the default
	     * algorithm. The default change detection algorithm looks for differences by comparing
	     * bound-property values by reference across change detection runs.
	     *
	     * Note that a directive typically should not use both `DoCheck` and {\@link OnChanges} to respond to
	     * changes on the same input, as `ngOnChanges` will continue to be called when the default change
	     * detector detects changes.
	     *
	     * See {\@link KeyValueDiffers} and {\@link IterableDiffers} for implementing custom dirty checking
	     * for collections.
	     *
	     * See {\@linkDocs guide/lifecycle-hooks#docheck "Lifecycle Hooks Guide"}.
	     *
	     * \@stable
	     * @abstract
	     */
	    var DoCheck = (function () {
	        function DoCheck() {
	        }
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DoCheck.prototype.ngDoCheck = function () { };
	        return DoCheck;
	    }());
	    /**
	     * \@whatItDoes Lifecycle hook that is called when a directive, pipe or service is destroyed.
	     * \@howToUse
	     * {\@example core/ts/metadata/lifecycle_hooks_spec.ts region='OnDestroy'}
	     *
	     * \@description
	     * `ngOnDestroy` callback is typically used for any custom cleanup that needs to occur when the
	     * instance is destroyed.
	     *
	     * See {\@linkDocs guide/lifecycle-hooks "Lifecycle Hooks Guide"}.
	     *
	     * \@stable
	     * @abstract
	     */
	    var OnDestroy = (function () {
	        function OnDestroy() {
	        }
	        /**
	         * @abstract
	         * @return {?}
	         */
	        OnDestroy.prototype.ngOnDestroy = function () { };
	        return OnDestroy;
	    }());
	    /**
	     *
	     * \@whatItDoes Lifecycle hook that is called after a directive's content has been fully
	     * initialized.
	     * \@howToUse
	     * {\@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterContentInit'}
	     *
	     * \@description
	     * See {\@linkDocs guide/lifecycle-hooks#aftercontent "Lifecycle Hooks Guide"}.
	     *
	     * \@stable
	     * @abstract
	     */
	    var AfterContentInit = (function () {
	        function AfterContentInit() {
	        }
	        /**
	         * @abstract
	         * @return {?}
	         */
	        AfterContentInit.prototype.ngAfterContentInit = function () { };
	        return AfterContentInit;
	    }());
	    /**
	     * \@whatItDoes Lifecycle hook that is called after every check of a directive's content.
	     * \@howToUse
	     * {\@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterContentChecked'}
	     *
	     * \@description
	     * See {\@linkDocs guide/lifecycle-hooks#aftercontent "Lifecycle Hooks Guide"}.
	     *
	     * \@stable
	     * @abstract
	     */
	    var AfterContentChecked = (function () {
	        function AfterContentChecked() {
	        }
	        /**
	         * @abstract
	         * @return {?}
	         */
	        AfterContentChecked.prototype.ngAfterContentChecked = function () { };
	        return AfterContentChecked;
	    }());
	    /**
	     * \@whatItDoes Lifecycle hook that is called after a component's view has been fully
	     * initialized.
	     * \@howToUse
	     * {\@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterViewInit'}
	     *
	     * \@description
	     * See {\@linkDocs guide/lifecycle-hooks#afterview "Lifecycle Hooks Guide"}.
	     *
	     * \@stable
	     * @abstract
	     */
	    var AfterViewInit = (function () {
	        function AfterViewInit() {
	        }
	        /**
	         * @abstract
	         * @return {?}
	         */
	        AfterViewInit.prototype.ngAfterViewInit = function () { };
	        return AfterViewInit;
	    }());
	    /**
	     * \@whatItDoes Lifecycle hook that is called after every check of a component's view.
	     * \@howToUse
	     * {\@example core/ts/metadata/lifecycle_hooks_spec.ts region='AfterViewChecked'}
	     *
	     * \@description
	     * See {\@linkDocs guide/lifecycle-hooks#afterview "Lifecycle Hooks Guide"}.
	     *
	     * \@stable
	     * @abstract
	     */
	    var AfterViewChecked = (function () {
	        function AfterViewChecked() {
	        }
	        /**
	         * @abstract
	         * @return {?}
	         */
	        AfterViewChecked.prototype.ngAfterViewChecked = function () { };
	        return AfterViewChecked;
	    }());

	    /**
	     * Defines a schema that will allow:
	     * - any non-Angular elements with a `-` in their name,
	     * - any properties on elements with a `-` in their name which is the common rule for custom
	     * elements.
	     *
	     * @stable
	     */
	    var /** @type {?} */ CUSTOM_ELEMENTS_SCHEMA = {
	        name: 'custom-elements'
	    };
	    /**
	     * Defines a schema that will allow any property on any element.
	     *
	     * @experimental
	     */
	    var /** @type {?} */ NO_ERRORS_SCHEMA = {
	        name: 'no-errors-schema'
	    };
	    /**
	     * NgModule decorator and metadata.
	     *
	     * @stable
	     * @Annotation
	     */
	    var /** @type {?} */ NgModule = (makeDecorator('NgModule', {
	        providers: undefined,
	        declarations: undefined,
	        imports: undefined,
	        exports: undefined,
	        entryComponents: undefined,
	        bootstrap: undefined,
	        schemas: undefined,
	        id: undefined,
	    }));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var ViewEncapsulation = {};
	    ViewEncapsulation.Emulated = 0;
	    ViewEncapsulation.Native = 1;
	    ViewEncapsulation.None = 2;
	    ViewEncapsulation[ViewEncapsulation.Emulated] = "Emulated";
	    ViewEncapsulation[ViewEncapsulation.Native] = "Native";
	    ViewEncapsulation[ViewEncapsulation.None] = "None";
	    /**
	     * Metadata properties available for configuring Views.
	     *
	     * For details on the `\@Component` annotation, see {\@link Component}.
	     *
	     * ### Example
	     *
	     * ```
	     * \@Component({
	     *   selector: 'greet',
	     *   template: 'Hello {{name}}!',
	     * })
	     * class Greet {
	     *   name: string;
	     *
	     *   constructor() {
	     *     this.name = 'World';
	     *   }
	     * }
	     * ```
	     *
	     * @deprecated Use Component instead.
	     *
	     * {\@link Component}
	     */
	    var ViewMetadata = (function () {
	        /**
	         * @param {?=} __0
	         */
	        function ViewMetadata(_a) {
	            var _b = _a === void 0 ? {} : _a, templateUrl = _b.templateUrl, template = _b.template, encapsulation = _b.encapsulation, styles = _b.styles, styleUrls = _b.styleUrls, animations = _b.animations, interpolation = _b.interpolation;
	            this.templateUrl = templateUrl;
	            this.template = template;
	            this.styleUrls = styleUrls;
	            this.styles = styles;
	            this.encapsulation = encapsulation;
	            this.animations = animations;
	            this.interpolation = interpolation;
	        }
	        return ViewMetadata;
	    }());

	    /**
	     * \@whatItDoes Represents the version of Angular
	     *
	     * \@stable
	     */
	    var Version = (function () {
	        /**
	         * @param {?} full
	         */
	        function Version(full) {
	            this.full = full;
	        }
	        Object.defineProperty(Version.prototype, "major", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.full.split('.')[0]; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(Version.prototype, "minor", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.full.split('.')[1]; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(Version.prototype, "patch", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.full.split('.').slice(2).join('.'); },
	            enumerable: true,
	            configurable: true
	        });
	        return Version;
	    }());
	    /**
	     * @stable
	     */
	    var /** @type {?} */ VERSION = new Version('2.4.4');

	    /**
	     * Allows to refer to references which are not yet defined.
	     *
	     * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of
	     * DI is declared,
	     * but not yet defined. It is also used when the `token` which we use when creating a query is not
	     * yet defined.
	     *
	     * ### Example
	     * {\@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}
	     * \@experimental
	     * @param {?} forwardRefFn
	     * @return {?}
	     */
	    function forwardRef(forwardRefFn) {
	        ((forwardRefFn)).__forward_ref__ = forwardRef;
	        ((forwardRefFn)).toString = function () { return stringify(this()); };
	        return (((forwardRefFn)));
	    }
	    /**
	     * Lazily retrieves the reference value from a forwardRef.
	     *
	     * Acts as the identity function when given a non-forward-ref value.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/GU72mJrk1fiodChcmiDR?p=preview))
	     *
	     * {\@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}
	     *
	     * See: {\@link forwardRef}
	     * \@experimental
	     * @param {?} type
	     * @return {?}
	     */
	    function resolveForwardRef(type) {
	        if (typeof type === 'function' && type.hasOwnProperty('__forward_ref__') &&
	            type.__forward_ref__ === forwardRef) {
	            return ((type))();
	        }
	        else {
	            return type;
	        }
	    }

	    var __extends = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     * @return {?}
	     */
	    function unimplemented() {
	        throw new Error('unimplemented');
	    }
	    /**
	     * \@stable
	     */
	    var BaseError = (function (_super) {
	        __extends(BaseError, _super);
	        /**
	         * @param {?} message
	         */
	        function BaseError(message) {
	            _super.call(this, message);
	            // Errors don't use current this, instead they create a new instance.
	            // We have to do forward all of our api to the nativeInstance.
	            // TODO(bradfordcsmith): Remove this hack when
	            //     google/closure-compiler/issues/2102 is fixed.
	            var nativeError = new Error(message);
	            this._nativeError = nativeError;
	        }
	        Object.defineProperty(BaseError.prototype, "message", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._nativeError.message; },
	            /**
	             * @param {?} message
	             * @return {?}
	             */
	            set: function (message) { this._nativeError.message = message; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(BaseError.prototype, "name", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._nativeError.name; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(BaseError.prototype, "stack", {
	            /**
	             * @return {?}
	             */
	            get: function () { return ((this._nativeError)).stack; },
	            /**
	             * @param {?} value
	             * @return {?}
	             */
	            set: function (value) { ((this._nativeError)).stack = value; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        BaseError.prototype.toString = function () { return this._nativeError.toString(); };
	        return BaseError;
	    }(Error));
	    /**
	     * \@stable
	     */
	    var WrappedError = (function (_super) {
	        __extends(WrappedError, _super);
	        /**
	         * @param {?} message
	         * @param {?} error
	         */
	        function WrappedError(message, error) {
	            _super.call(this, message + " caused by: " + (error instanceof Error ? error.message : error));
	            this.originalError = error;
	        }
	        Object.defineProperty(WrappedError.prototype, "stack", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return (((this.originalError instanceof Error ? this.originalError : this._nativeError)))
	                    .stack;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        return WrappedError;
	    }(BaseError));

	    var /** @type {?} */ _THROW_IF_NOT_FOUND = new Object();
	    var /** @type {?} */ THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
	    var _NullInjector = (function () {
	        function _NullInjector() {
	        }
	        /**
	         * @param {?} token
	         * @param {?=} notFoundValue
	         * @return {?}
	         */
	        _NullInjector.prototype.get = function (token, notFoundValue) {
	            if (notFoundValue === void 0) { notFoundValue = _THROW_IF_NOT_FOUND; }
	            if (notFoundValue === _THROW_IF_NOT_FOUND) {
	                throw new Error("No provider for " + stringify(token) + "!");
	            }
	            return notFoundValue;
	        };
	        return _NullInjector;
	    }());
	    /**
	     * \@whatItDoes Injector interface
	     * \@howToUse
	     * ```
	     * const injector: Injector = ...;
	     * injector.get(...);
	     * ```
	     *
	     * \@description
	     * For more details, see the {\@linkDocs guide/dependency-injection "Dependency Injection Guide"}.
	     *
	     * ### Example
	     *
	     * {\@example core/di/ts/injector_spec.ts region='Injector'}
	     *
	     * `Injector` returns itself when given `Injector` as a token:
	     * {\@example core/di/ts/injector_spec.ts region='injectInjector'}
	     *
	     * \@stable
	     * @abstract
	     */
	    var Injector = (function () {
	        function Injector() {
	        }
	        /**
	         * Retrieves an instance from the injector based on the provided token.
	         * If not found:
	         * - Throws {\@link NoProviderError} if no `notFoundValue` that is not equal to
	         * Injector.THROW_IF_NOT_FOUND is given
	         * - Returns the `notFoundValue` otherwise
	         * @param {?} token
	         * @param {?=} notFoundValue
	         * @return {?}
	         */
	        Injector.prototype.get = function (token, notFoundValue) { return unimplemented(); };
	        Injector.THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
	        Injector.NULL = new _NullInjector();
	        return Injector;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$1 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * @param {?} keys
	     * @return {?}
	     */
	    function findFirstClosedCycle(keys) {
	        var /** @type {?} */ res = [];
	        for (var /** @type {?} */ i = 0; i < keys.length; ++i) {
	            if (res.indexOf(keys[i]) > -1) {
	                res.push(keys[i]);
	                return res;
	            }
	            res.push(keys[i]);
	        }
	        return res;
	    }
	    /**
	     * @param {?} keys
	     * @return {?}
	     */
	    function constructResolvingPath(keys) {
	        if (keys.length > 1) {
	            var /** @type {?} */ reversed = findFirstClosedCycle(keys.slice().reverse());
	            var /** @type {?} */ tokenStrs = reversed.map(function (k) { return stringify(k.token); });
	            return ' (' + tokenStrs.join(' -> ') + ')';
	        }
	        return '';
	    }
	    /**
	     * Base class for all errors arising from misconfigured providers.
	     * \@stable
	     */
	    var AbstractProviderError = (function (_super) {
	        __extends$1(AbstractProviderError, _super);
	        /**
	         * @param {?} injector
	         * @param {?} key
	         * @param {?} constructResolvingMessage
	         */
	        function AbstractProviderError(injector, key, constructResolvingMessage) {
	            _super.call(this, 'DI Error');
	            this.keys = [key];
	            this.injectors = [injector];
	            this.constructResolvingMessage = constructResolvingMessage;
	            this.message = this.constructResolvingMessage(this.keys);
	        }
	        /**
	         * @param {?} injector
	         * @param {?} key
	         * @return {?}
	         */
	        AbstractProviderError.prototype.addKey = function (injector, key) {
	            this.injectors.push(injector);
	            this.keys.push(key);
	            this.message = this.constructResolvingMessage(this.keys);
	        };
	        return AbstractProviderError;
	    }(BaseError));
	    /**
	     * Thrown when trying to retrieve a dependency by key from {\@link Injector}, but the
	     * {\@link Injector} does not have a {\@link Provider} for the given key.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/vq8D3FRB9aGbnWJqtEPE?p=preview))
	     *
	     * ```typescript
	     * class A {
	     *   constructor(b:B) {}
	     * }
	     *
	     * expect(() => Injector.resolveAndCreate([A])).toThrowError();
	     * ```
	     * \@stable
	     */
	    var NoProviderError = (function (_super) {
	        __extends$1(NoProviderError, _super);
	        /**
	         * @param {?} injector
	         * @param {?} key
	         */
	        function NoProviderError(injector, key) {
	            _super.call(this, injector, key, function (keys) {
	                var first = stringify(keys[0].token);
	                return "No provider for " + first + "!" + constructResolvingPath(keys);
	            });
	        }
	        return NoProviderError;
	    }(AbstractProviderError));
	    /**
	     * Thrown when dependencies form a cycle.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/wYQdNos0Tzql3ei1EV9j?p=info))
	     *
	     * ```typescript
	     * var injector = Injector.resolveAndCreate([
	     *   {provide: "one", useFactory: (two) => "two", deps: [[new Inject("two")]]},
	     *   {provide: "two", useFactory: (one) => "one", deps: [[new Inject("one")]]}
	     * ]);
	     *
	     * expect(() => injector.get("one")).toThrowError();
	     * ```
	     *
	     * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.
	     * \@stable
	     */
	    var CyclicDependencyError = (function (_super) {
	        __extends$1(CyclicDependencyError, _super);
	        /**
	         * @param {?} injector
	         * @param {?} key
	         */
	        function CyclicDependencyError(injector, key) {
	            _super.call(this, injector, key, function (keys) {
	                return "Cannot instantiate cyclic dependency!" + constructResolvingPath(keys);
	            });
	        }
	        return CyclicDependencyError;
	    }(AbstractProviderError));
	    /**
	     * Thrown when a constructing type returns with an Error.
	     *
	     * The `InstantiationError` class contains the original error plus the dependency graph which caused
	     * this object to be instantiated.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/7aWYdcqTQsP0eNqEdUAf?p=preview))
	     *
	     * ```typescript
	     * class A {
	     *   constructor() {
	     *     throw new Error('message');
	     *   }
	     * }
	     *
	     * var injector = Injector.resolveAndCreate([A]);
	     * try {
	     *   injector.get(A);
	     * } catch (e) {
	     *   expect(e instanceof InstantiationError).toBe(true);
	     *   expect(e.originalException.message).toEqual("message");
	     *   expect(e.originalStack).toBeDefined();
	     * }
	     * ```
	     * \@stable
	     */
	    var InstantiationError = (function (_super) {
	        __extends$1(InstantiationError, _super);
	        /**
	         * @param {?} injector
	         * @param {?} originalException
	         * @param {?} originalStack
	         * @param {?} key
	         */
	        function InstantiationError(injector, originalException, originalStack, key) {
	            _super.call(this, 'DI Error', originalException);
	            this.keys = [key];
	            this.injectors = [injector];
	        }
	        /**
	         * @param {?} injector
	         * @param {?} key
	         * @return {?}
	         */
	        InstantiationError.prototype.addKey = function (injector, key) {
	            this.injectors.push(injector);
	            this.keys.push(key);
	        };
	        Object.defineProperty(InstantiationError.prototype, "message", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                var /** @type {?} */ first = stringify(this.keys[0].token);
	                return this.originalError.message + ": Error during instantiation of " + first + "!" + constructResolvingPath(this.keys) + ".";
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(InstantiationError.prototype, "causeKey", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.keys[0]; },
	            enumerable: true,
	            configurable: true
	        });
	        return InstantiationError;
	    }(WrappedError));
	    /**
	     * Thrown when an object other then {\@link Provider} (or `Type`) is passed to {\@link Injector}
	     * creation.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/YatCFbPAMCL0JSSQ4mvH?p=preview))
	     *
	     * ```typescript
	     * expect(() => Injector.resolveAndCreate(["not a type"])).toThrowError();
	     * ```
	     * \@stable
	     */
	    var InvalidProviderError = (function (_super) {
	        __extends$1(InvalidProviderError, _super);
	        /**
	         * @param {?} provider
	         */
	        function InvalidProviderError(provider) {
	            _super.call(this, "Invalid provider - only instances of Provider and Type are allowed, got: " + provider);
	        }
	        return InvalidProviderError;
	    }(BaseError));
	    /**
	     * Thrown when the class has no annotation information.
	     *
	     * Lack of annotation information prevents the {\@link Injector} from determining which dependencies
	     * need to be injected into the constructor.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/rHnZtlNS7vJOPQ6pcVkm?p=preview))
	     *
	     * ```typescript
	     * class A {
	     *   constructor(b) {}
	     * }
	     *
	     * expect(() => Injector.resolveAndCreate([A])).toThrowError();
	     * ```
	     *
	     * This error is also thrown when the class not marked with {\@link Injectable} has parameter types.
	     *
	     * ```typescript
	     * class B {}
	     *
	     * class A {
	     *   constructor(b:B) {} // no information about the parameter types of A is available at runtime.
	     * }
	     *
	     * expect(() => Injector.resolveAndCreate([A,B])).toThrowError();
	     * ```
	     * \@stable
	     */
	    var NoAnnotationError = (function (_super) {
	        __extends$1(NoAnnotationError, _super);
	        /**
	         * @param {?} typeOrFunc
	         * @param {?} params
	         */
	        function NoAnnotationError(typeOrFunc, params) {
	            _super.call(this, NoAnnotationError._genMessage(typeOrFunc, params));
	        }
	        /**
	         * @param {?} typeOrFunc
	         * @param {?} params
	         * @return {?}
	         */
	        NoAnnotationError._genMessage = function (typeOrFunc, params) {
	            var /** @type {?} */ signature = [];
	            for (var /** @type {?} */ i = 0, /** @type {?} */ ii = params.length; i < ii; i++) {
	                var /** @type {?} */ parameter = params[i];
	                if (!parameter || parameter.length == 0) {
	                    signature.push('?');
	                }
	                else {
	                    signature.push(parameter.map(stringify).join(' '));
	                }
	            }
	            return 'Cannot resolve all parameters for \'' + stringify(typeOrFunc) + '\'(' +
	                signature.join(', ') + '). ' +
	                'Make sure that all the parameters are decorated with Inject or have valid type annotations and that \'' +
	                stringify(typeOrFunc) + '\' is decorated with Injectable.';
	        };
	        return NoAnnotationError;
	    }(BaseError));
	    /**
	     * Thrown when getting an object by index.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/bRs0SX2OTQiJzqvjgl8P?p=preview))
	     *
	     * ```typescript
	     * class A {}
	     *
	     * var injector = Injector.resolveAndCreate([A]);
	     *
	     * expect(() => injector.getAt(100)).toThrowError();
	     * ```
	     * \@stable
	     */
	    var OutOfBoundsError = (function (_super) {
	        __extends$1(OutOfBoundsError, _super);
	        /**
	         * @param {?} index
	         */
	        function OutOfBoundsError(index) {
	            _super.call(this, "Index " + index + " is out-of-bounds.");
	        }
	        return OutOfBoundsError;
	    }(BaseError));
	    /**
	     * Thrown when a multi provider and a regular provider are bound to the same token.
	     *
	     * ### Example
	     *
	     * ```typescript
	     * expect(() => Injector.resolveAndCreate([
	     *   { provide: "Strings", useValue: "string1", multi: true},
	     *   { provide: "Strings", useValue: "string2", multi: false}
	     * ])).toThrowError();
	     * ```
	     */
	    var MixingMultiProvidersWithRegularProvidersError = (function (_super) {
	        __extends$1(MixingMultiProvidersWithRegularProvidersError, _super);
	        /**
	         * @param {?} provider1
	         * @param {?} provider2
	         */
	        function MixingMultiProvidersWithRegularProvidersError(provider1, provider2) {
	            _super.call(this, 'Cannot mix multi providers and regular providers, got: ' + provider1.toString() + ' ' +
	                provider2.toString());
	        }
	        return MixingMultiProvidersWithRegularProvidersError;
	    }(BaseError));

	    /**
	     * A unique object used for retrieving items from the {\@link ReflectiveInjector}.
	     *
	     * Keys have:
	     * - a system-wide unique `id`.
	     * - a `token`.
	     *
	     * `Key` is used internally by {\@link ReflectiveInjector} because its system-wide unique `id` allows
	     * the
	     * injector to store created objects in a more efficient way.
	     *
	     * `Key` should not be created directly. {\@link ReflectiveInjector} creates keys automatically when
	     * resolving
	     * providers.
	     * \@experimental
	     */
	    var ReflectiveKey = (function () {
	        /**
	         * Private
	         * @param {?} token
	         * @param {?} id
	         */
	        function ReflectiveKey(token, id) {
	            this.token = token;
	            this.id = id;
	            if (!token) {
	                throw new Error('Token must be defined!');
	            }
	        }
	        Object.defineProperty(ReflectiveKey.prototype, "displayName", {
	            /**
	             * Returns a stringified token.
	             * @return {?}
	             */
	            get: function () { return stringify(this.token); },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * Retrieves a `Key` for a token.
	         * @param {?} token
	         * @return {?}
	         */
	        ReflectiveKey.get = function (token) {
	            return _globalKeyRegistry.get(resolveForwardRef(token));
	        };
	        Object.defineProperty(ReflectiveKey, "numberOfKeys", {
	            /**
	             * @return {?} the number of keys registered in the system.
	             */
	            get: function () { return _globalKeyRegistry.numberOfKeys; },
	            enumerable: true,
	            configurable: true
	        });
	        return ReflectiveKey;
	    }());
	    /**
	     * \@internal
	     */
	    var KeyRegistry = (function () {
	        function KeyRegistry() {
	            this._allKeys = new Map();
	        }
	        /**
	         * @param {?} token
	         * @return {?}
	         */
	        KeyRegistry.prototype.get = function (token) {
	            if (token instanceof ReflectiveKey)
	                return token;
	            if (this._allKeys.has(token)) {
	                return this._allKeys.get(token);
	            }
	            var /** @type {?} */ newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);
	            this._allKeys.set(token, newKey);
	            return newKey;
	        };
	        Object.defineProperty(KeyRegistry.prototype, "numberOfKeys", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._allKeys.size; },
	            enumerable: true,
	            configurable: true
	        });
	        return KeyRegistry;
	    }());
	    var /** @type {?} */ _globalKeyRegistry = new KeyRegistry();

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * @whatItDoes Represents a type that a Component or other object is instances of.
	     *
	     * @description
	     *
	     * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by
	     * the `MyCustomComponent` constructor function.
	     *
	     * @stable
	     */
	    var /** @type {?} */ Type = Function;
	    /**
	     * @param {?} v
	     * @return {?}
	     */
	    function isType(v) {
	        return typeof v === 'function';
	    }

	    /**
	     * Attention: This regex has to hold even if the code is minified!
	     */
	    var /** @type {?} */ DELEGATE_CTOR = /^function\s+\S+\(\)\s*{\s*("use strict";)?\s*(return\s+)?\S+\.apply\(this,\s*arguments\)/;
	    var ReflectionCapabilities = (function () {
	        /**
	         * @param {?=} reflect
	         */
	        function ReflectionCapabilities(reflect) {
	            this._reflect = reflect || global$1.Reflect;
	        }
	        /**
	         * @return {?}
	         */
	        ReflectionCapabilities.prototype.isReflectionEnabled = function () { return true; };
	        /**
	         * @param {?} t
	         * @return {?}
	         */
	        ReflectionCapabilities.prototype.factory = function (t) { return function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i - 0] = arguments[_i];
	            }
	            return new (t.bind.apply(t, [void 0].concat(args)))();
	        }; };
	        /**
	         * \@internal
	         * @param {?} paramTypes
	         * @param {?} paramAnnotations
	         * @return {?}
	         */
	        ReflectionCapabilities.prototype._zipTypesAndAnnotations = function (paramTypes, paramAnnotations) {
	            var /** @type {?} */ result;
	            if (typeof paramTypes === 'undefined') {
	                result = new Array(paramAnnotations.length);
	            }
	            else {
	                result = new Array(paramTypes.length);
	            }
	            for (var /** @type {?} */ i = 0; i < result.length; i++) {
	                // TS outputs Object for parameters without types, while Traceur omits
	                // the annotations. For now we preserve the Traceur behavior to aid
	                // migration, but this can be revisited.
	                if (typeof paramTypes === 'undefined') {
	                    result[i] = [];
	                }
	                else if (paramTypes[i] != Object) {
	                    result[i] = [paramTypes[i]];
	                }
	                else {
	                    result[i] = [];
	                }
	                if (paramAnnotations && isPresent(paramAnnotations[i])) {
	                    result[i] = result[i].concat(paramAnnotations[i]);
	                }
	            }
	            return result;
	        };
	        /**
	         * @param {?} type
	         * @param {?} parentCtor
	         * @return {?}
	         */
	        ReflectionCapabilities.prototype._ownParameters = function (type, parentCtor) {
	            // If we have no decorators, we only have function.length as metadata.
	            // In that case, to detect whether a child class declared an own constructor or not,
	            // we need to look inside of that constructor to check whether it is
	            // just calling the parent.
	            // This also helps to work around for https://github.com/Microsoft/TypeScript/issues/12439
	            // that sets 'design:paramtypes' to []
	            // if a class inherits from another class but has no ctor declared itself.
	            if (DELEGATE_CTOR.exec(type.toString())) {
	                return null;
	            }
	            // Prefer the direct API.
	            if (((type)).parameters && ((type)).parameters !== parentCtor.parameters) {
	                return ((type)).parameters;
	            }
	            // API of tsickle for lowering decorators to properties on the class.
	            var /** @type {?} */ tsickleCtorParams = ((type)).ctorParameters;
	            if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {
	                // Newer tsickle uses a function closure
	                // Retain the non-function case for compatibility with older tsickle
	                var /** @type {?} */ ctorParameters = typeof tsickleCtorParams === 'function' ? tsickleCtorParams() : tsickleCtorParams;
	                var /** @type {?} */ paramTypes = ctorParameters.map(function (ctorParam) { return ctorParam && ctorParam.type; });
	                var /** @type {?} */ paramAnnotations = ctorParameters.map(function (ctorParam) {
	                    return ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators);
	                });
	                return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
	            }
	            // API for metadata created by invoking the decorators.
	            if (isPresent(this._reflect) && isPresent(this._reflect.getOwnMetadata)) {
	                var /** @type {?} */ paramAnnotations = this._reflect.getOwnMetadata('parameters', type);
	                var /** @type {?} */ paramTypes = this._reflect.getOwnMetadata('design:paramtypes', type);
	                if (paramTypes || paramAnnotations) {
	                    return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
	                }
	            }
	            // If a class has no decorators, at least create metadata
	            // based on function.length.
	            // Note: We know that this is a real constructor as we checked
	            // the content of the constructor above.
	            return new Array(((type.length))).fill(undefined);
	        };
	        /**
	         * @param {?} type
	         * @return {?}
	         */
	        ReflectionCapabilities.prototype.parameters = function (type) {
	            // Note: only report metadata if we have at least one class decorator
	            // to stay in sync with the static reflector.
	            if (!isType(type)) {
	                return [];
	            }
	            var /** @type {?} */ parentCtor = getParentCtor(type);
	            var /** @type {?} */ parameters = this._ownParameters(type, parentCtor);
	            if (!parameters && parentCtor !== Object) {
	                parameters = this.parameters(parentCtor);
	            }
	            return parameters || [];
	        };
	        /**
	         * @param {?} typeOrFunc
	         * @param {?} parentCtor
	         * @return {?}
	         */
	        ReflectionCapabilities.prototype._ownAnnotations = function (typeOrFunc, parentCtor) {
	            // Prefer the direct API.
	            if (((typeOrFunc)).annotations && ((typeOrFunc)).annotations !== parentCtor.annotations) {
	                var /** @type {?} */ annotations = ((typeOrFunc)).annotations;
	                if (typeof annotations === 'function' && annotations.annotations) {
	                    annotations = annotations.annotations;
	                }
	                return annotations;
	            }
	            // API of tsickle for lowering decorators to properties on the class.
	            if (((typeOrFunc)).decorators && ((typeOrFunc)).decorators !== parentCtor.decorators) {
	                return convertTsickleDecoratorIntoMetadata(((typeOrFunc)).decorators);
	            }
	            // API for metadata created by invoking the decorators.
	            if (this._reflect && this._reflect.getOwnMetadata) {
	                return this._reflect.getOwnMetadata('annotations', typeOrFunc);
	            }
	        };
	        /**
	         * @param {?} typeOrFunc
	         * @return {?}
	         */
	        ReflectionCapabilities.prototype.annotations = function (typeOrFunc) {
	            if (!isType(typeOrFunc)) {
	                return [];
	            }
	            var /** @type {?} */ parentCtor = getParentCtor(typeOrFunc);
	            var /** @type {?} */ ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];
	            var /** @type {?} */ parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];
	            return parentAnnotations.concat(ownAnnotations);
	        };
	        /**
	         * @param {?} typeOrFunc
	         * @param {?} parentCtor
	         * @return {?}
	         */
	        ReflectionCapabilities.prototype._ownPropMetadata = function (typeOrFunc, parentCtor) {
	            // Prefer the direct API.
	            if (((typeOrFunc)).propMetadata &&
	                ((typeOrFunc)).propMetadata !== parentCtor.propMetadata) {
	                var /** @type {?} */ propMetadata = ((typeOrFunc)).propMetadata;
	                if (typeof propMetadata === 'function' && propMetadata.propMetadata) {
	                    propMetadata = propMetadata.propMetadata;
	                }
	                return propMetadata;
	            }
	            // API of tsickle for lowering decorators to properties on the class.
	            if (((typeOrFunc)).propDecorators &&
	                ((typeOrFunc)).propDecorators !== parentCtor.propDecorators) {
	                var /** @type {?} */ propDecorators_1 = ((typeOrFunc)).propDecorators;
	                var /** @type {?} */ propMetadata_1 = ({});
	                Object.keys(propDecorators_1).forEach(function (prop) {
	                    propMetadata_1[prop] = convertTsickleDecoratorIntoMetadata(propDecorators_1[prop]);
	                });
	                return propMetadata_1;
	            }
	            // API for metadata created by invoking the decorators.
	            if (this._reflect && this._reflect.getOwnMetadata) {
	                return this._reflect.getOwnMetadata('propMetadata', typeOrFunc);
	            }
	        };
	        /**
	         * @param {?} typeOrFunc
	         * @return {?}
	         */
	        ReflectionCapabilities.prototype.propMetadata = function (typeOrFunc) {
	            if (!isType(typeOrFunc)) {
	                return {};
	            }
	            var /** @type {?} */ parentCtor = getParentCtor(typeOrFunc);
	            var /** @type {?} */ propMetadata = {};
	            if (parentCtor !== Object) {
	                var /** @type {?} */ parentPropMetadata_1 = this.propMetadata(parentCtor);
	                Object.keys(parentPropMetadata_1).forEach(function (propName) {
	                    propMetadata[propName] = parentPropMetadata_1[propName];
	                });
	            }
	            var /** @type {?} */ ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);
	            if (ownPropMetadata) {
	                Object.keys(ownPropMetadata).forEach(function (propName) {
	                    var /** @type {?} */ decorators = [];
	                    if (propMetadata.hasOwnProperty(propName)) {
	                        decorators.push.apply(decorators, propMetadata[propName]);
	                    }
	                    decorators.push.apply(decorators, ownPropMetadata[propName]);
	                    propMetadata[propName] = decorators;
	                });
	            }
	            return propMetadata;
	        };
	        /**
	         * @param {?} type
	         * @param {?} lcProperty
	         * @return {?}
	         */
	        ReflectionCapabilities.prototype.hasLifecycleHook = function (type, lcProperty) {
	            return type instanceof Type && lcProperty in type.prototype;
	        };
	        /**
	         * @param {?} name
	         * @return {?}
	         */
	        ReflectionCapabilities.prototype.getter = function (name) { return ((new Function('o', 'return o.' + name + ';'))); };
	        /**
	         * @param {?} name
	         * @return {?}
	         */
	        ReflectionCapabilities.prototype.setter = function (name) {
	            return ((new Function('o', 'v', 'return o.' + name + ' = v;')));
	        };
	        /**
	         * @param {?} name
	         * @return {?}
	         */
	        ReflectionCapabilities.prototype.method = function (name) {
	            var /** @type {?} */ functionBody = "if (!o." + name + ") throw new Error('\"" + name + "\" is undefined');\n        return o." + name + ".apply(o, args);";
	            return ((new Function('o', 'args', functionBody)));
	        };
	        /**
	         * @param {?} type
	         * @return {?}
	         */
	        ReflectionCapabilities.prototype.importUri = function (type) {
	            // StaticSymbol
	            if (typeof type === 'object' && type['filePath']) {
	                return type['filePath'];
	            }
	            // Runtime type
	            return "./" + stringify(type);
	        };
	        /**
	         * @param {?} name
	         * @param {?} moduleUrl
	         * @param {?} runtime
	         * @return {?}
	         */
	        ReflectionCapabilities.prototype.resolveIdentifier = function (name, moduleUrl, runtime) { return runtime; };
	        /**
	         * @param {?} enumIdentifier
	         * @param {?} name
	         * @return {?}
	         */
	        ReflectionCapabilities.prototype.resolveEnum = function (enumIdentifier, name) { return enumIdentifier[name]; };
	        return ReflectionCapabilities;
	    }());
	    /**
	     * @param {?} decoratorInvocations
	     * @return {?}
	     */
	    function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
	        if (!decoratorInvocations) {
	            return [];
	        }
	        return decoratorInvocations.map(function (decoratorInvocation) {
	            var /** @type {?} */ decoratorType = decoratorInvocation.type;
	            var /** @type {?} */ annotationCls = decoratorType.annotationCls;
	            var /** @type {?} */ annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];
	            return new (annotationCls.bind.apply(annotationCls, [void 0].concat(annotationArgs)))();
	        });
	    }
	    /**
	     * @param {?} ctor
	     * @return {?}
	     */
	    function getParentCtor(ctor) {
	        var /** @type {?} */ parentProto = Object.getPrototypeOf(ctor.prototype);
	        var /** @type {?} */ parentCtor = parentProto ? parentProto.constructor : null;
	        // Note: We always use `Object` as the null value
	        // to simplify checking later on.
	        return parentCtor || Object;
	    }

	    /**
	     * Provides read-only access to reflection data about symbols. Used internally by Angular
	     * to power dependency injection and compilation.
	     * @abstract
	     */
	    var ReflectorReader = (function () {
	        function ReflectorReader() {
	        }
	        /**
	         * @abstract
	         * @param {?} typeOrFunc
	         * @return {?}
	         */
	        ReflectorReader.prototype.parameters = function (typeOrFunc) { };
	        /**
	         * @abstract
	         * @param {?} typeOrFunc
	         * @return {?}
	         */
	        ReflectorReader.prototype.annotations = function (typeOrFunc) { };
	        /**
	         * @abstract
	         * @param {?} typeOrFunc
	         * @return {?}
	         */
	        ReflectorReader.prototype.propMetadata = function (typeOrFunc) { };
	        /**
	         * @abstract
	         * @param {?} typeOrFunc
	         * @return {?}
	         */
	        ReflectorReader.prototype.importUri = function (typeOrFunc) { };
	        /**
	         * @abstract
	         * @param {?} name
	         * @param {?} moduleUrl
	         * @param {?} runtime
	         * @return {?}
	         */
	        ReflectorReader.prototype.resolveIdentifier = function (name, moduleUrl, runtime) { };
	        /**
	         * @abstract
	         * @param {?} identifier
	         * @param {?} name
	         * @return {?}
	         */
	        ReflectorReader.prototype.resolveEnum = function (identifier, name) { };
	        return ReflectorReader;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$2 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Provides access to reflection data about symbols. Used internally by Angular
	     * to power dependency injection and compilation.
	     */
	    var Reflector = (function (_super) {
	        __extends$2(Reflector, _super);
	        /**
	         * @param {?} reflectionCapabilities
	         */
	        function Reflector(reflectionCapabilities) {
	            _super.call(this);
	            this.reflectionCapabilities = reflectionCapabilities;
	        }
	        /**
	         * @param {?} caps
	         * @return {?}
	         */
	        Reflector.prototype.updateCapabilities = function (caps) { this.reflectionCapabilities = caps; };
	        /**
	         * @param {?} type
	         * @return {?}
	         */
	        Reflector.prototype.factory = function (type) { return this.reflectionCapabilities.factory(type); };
	        /**
	         * @param {?} typeOrFunc
	         * @return {?}
	         */
	        Reflector.prototype.parameters = function (typeOrFunc) {
	            return this.reflectionCapabilities.parameters(typeOrFunc);
	        };
	        /**
	         * @param {?} typeOrFunc
	         * @return {?}
	         */
	        Reflector.prototype.annotations = function (typeOrFunc) {
	            return this.reflectionCapabilities.annotations(typeOrFunc);
	        };
	        /**
	         * @param {?} typeOrFunc
	         * @return {?}
	         */
	        Reflector.prototype.propMetadata = function (typeOrFunc) {
	            return this.reflectionCapabilities.propMetadata(typeOrFunc);
	        };
	        /**
	         * @param {?} type
	         * @param {?} lcProperty
	         * @return {?}
	         */
	        Reflector.prototype.hasLifecycleHook = function (type, lcProperty) {
	            return this.reflectionCapabilities.hasLifecycleHook(type, lcProperty);
	        };
	        /**
	         * @param {?} name
	         * @return {?}
	         */
	        Reflector.prototype.getter = function (name) { return this.reflectionCapabilities.getter(name); };
	        /**
	         * @param {?} name
	         * @return {?}
	         */
	        Reflector.prototype.setter = function (name) { return this.reflectionCapabilities.setter(name); };
	        /**
	         * @param {?} name
	         * @return {?}
	         */
	        Reflector.prototype.method = function (name) { return this.reflectionCapabilities.method(name); };
	        /**
	         * @param {?} type
	         * @return {?}
	         */
	        Reflector.prototype.importUri = function (type) { return this.reflectionCapabilities.importUri(type); };
	        /**
	         * @param {?} name
	         * @param {?} moduleUrl
	         * @param {?} runtime
	         * @return {?}
	         */
	        Reflector.prototype.resolveIdentifier = function (name, moduleUrl, runtime) {
	            return this.reflectionCapabilities.resolveIdentifier(name, moduleUrl, runtime);
	        };
	        /**
	         * @param {?} identifier
	         * @param {?} name
	         * @return {?}
	         */
	        Reflector.prototype.resolveEnum = function (identifier, name) {
	            return this.reflectionCapabilities.resolveEnum(identifier, name);
	        };
	        return Reflector;
	    }(ReflectorReader));

	    /**
	     * The {@link Reflector} used internally in Angular to access metadata
	     * about symbols.
	     */
	    var /** @type {?} */ reflector = new Reflector(new ReflectionCapabilities());

	    /**
	     * `Dependency` is used by the framework to extend DI.
	     * This is internal to Angular and should not be used directly.
	     */
	    var ReflectiveDependency = (function () {
	        /**
	         * @param {?} key
	         * @param {?} optional
	         * @param {?} lowerBoundVisibility
	         * @param {?} upperBoundVisibility
	         * @param {?} properties
	         */
	        function ReflectiveDependency(key, optional, lowerBoundVisibility, upperBoundVisibility, properties) {
	            this.key = key;
	            this.optional = optional;
	            this.lowerBoundVisibility = lowerBoundVisibility;
	            this.upperBoundVisibility = upperBoundVisibility;
	            this.properties = properties;
	        }
	        /**
	         * @param {?} key
	         * @return {?}
	         */
	        ReflectiveDependency.fromKey = function (key) {
	            return new ReflectiveDependency(key, false, null, null, []);
	        };
	        return ReflectiveDependency;
	    }());
	    var /** @type {?} */ _EMPTY_LIST = [];
	    var ResolvedReflectiveProvider_ = (function () {
	        /**
	         * @param {?} key
	         * @param {?} resolvedFactories
	         * @param {?} multiProvider
	         */
	        function ResolvedReflectiveProvider_(key, resolvedFactories, multiProvider) {
	            this.key = key;
	            this.resolvedFactories = resolvedFactories;
	            this.multiProvider = multiProvider;
	        }
	        Object.defineProperty(ResolvedReflectiveProvider_.prototype, "resolvedFactory", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.resolvedFactories[0]; },
	            enumerable: true,
	            configurable: true
	        });
	        return ResolvedReflectiveProvider_;
	    }());
	    /**
	     * An internal resolved representation of a factory function created by resolving {\@link
	     * Provider}.
	     * \@experimental
	     */
	    var ResolvedReflectiveFactory = (function () {
	        /**
	         * @param {?} factory
	         * @param {?} dependencies
	         */
	        function ResolvedReflectiveFactory(factory, dependencies) {
	            this.factory = factory;
	            this.dependencies = dependencies;
	        }
	        return ResolvedReflectiveFactory;
	    }());
	    /**
	     * Resolve a single provider.
	     * @param {?} provider
	     * @return {?}
	     */
	    function resolveReflectiveFactory(provider) {
	        var /** @type {?} */ factoryFn;
	        var /** @type {?} */ resolvedDeps;
	        if (provider.useClass) {
	            var /** @type {?} */ useClass = resolveForwardRef(provider.useClass);
	            factoryFn = reflector.factory(useClass);
	            resolvedDeps = _dependenciesFor(useClass);
	        }
	        else if (provider.useExisting) {
	            factoryFn = function (aliasInstance) { return aliasInstance; };
	            resolvedDeps = [ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))];
	        }
	        else if (provider.useFactory) {
	            factoryFn = provider.useFactory;
	            resolvedDeps = constructDependencies(provider.useFactory, provider.deps);
	        }
	        else {
	            factoryFn = function () { return provider.useValue; };
	            resolvedDeps = _EMPTY_LIST;
	        }
	        return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);
	    }
	    /**
	     * Converts the {\@link Provider} into {\@link ResolvedProvider}.
	     *
	     * {\@link Injector} internally only uses {\@link ResolvedProvider}, {\@link Provider} contains
	     * convenience provider syntax.
	     * @param {?} provider
	     * @return {?}
	     */
	    function resolveReflectiveProvider(provider) {
	        return new ResolvedReflectiveProvider_(ReflectiveKey.get(provider.provide), [resolveReflectiveFactory(provider)], provider.multi);
	    }
	    /**
	     * Resolve a list of Providers.
	     * @param {?} providers
	     * @return {?}
	     */
	    function resolveReflectiveProviders(providers) {
	        var /** @type {?} */ normalized = _normalizeProviders(providers, []);
	        var /** @type {?} */ resolved = normalized.map(resolveReflectiveProvider);
	        var /** @type {?} */ resolvedProviderMap = mergeResolvedReflectiveProviders(resolved, new Map());
	        return Array.from(resolvedProviderMap.values());
	    }
	    /**
	     * Merges a list of ResolvedProviders into a list where
	     * each key is contained exactly once and multi providers
	     * have been merged.
	     * @param {?} providers
	     * @param {?} normalizedProvidersMap
	     * @return {?}
	     */
	    function mergeResolvedReflectiveProviders(providers, normalizedProvidersMap) {
	        for (var /** @type {?} */ i = 0; i < providers.length; i++) {
	            var /** @type {?} */ provider = providers[i];
	            var /** @type {?} */ existing = normalizedProvidersMap.get(provider.key.id);
	            if (existing) {
	                if (provider.multiProvider !== existing.multiProvider) {
	                    throw new MixingMultiProvidersWithRegularProvidersError(existing, provider);
	                }
	                if (provider.multiProvider) {
	                    for (var /** @type {?} */ j = 0; j < provider.resolvedFactories.length; j++) {
	                        existing.resolvedFactories.push(provider.resolvedFactories[j]);
	                    }
	                }
	                else {
	                    normalizedProvidersMap.set(provider.key.id, provider);
	                }
	            }
	            else {
	                var /** @type {?} */ resolvedProvider = void 0;
	                if (provider.multiProvider) {
	                    resolvedProvider = new ResolvedReflectiveProvider_(provider.key, provider.resolvedFactories.slice(), provider.multiProvider);
	                }
	                else {
	                    resolvedProvider = provider;
	                }
	                normalizedProvidersMap.set(provider.key.id, resolvedProvider);
	            }
	        }
	        return normalizedProvidersMap;
	    }
	    /**
	     * @param {?} providers
	     * @param {?} res
	     * @return {?}
	     */
	    function _normalizeProviders(providers, res) {
	        providers.forEach(function (b) {
	            if (b instanceof Type) {
	                res.push({ provide: b, useClass: b });
	            }
	            else if (b && typeof b == 'object' && ((b)).provide !== undefined) {
	                res.push(/** @type {?} */ (b));
	            }
	            else if (b instanceof Array) {
	                _normalizeProviders(b, res);
	            }
	            else {
	                throw new InvalidProviderError(b);
	            }
	        });
	        return res;
	    }
	    /**
	     * @param {?} typeOrFunc
	     * @param {?} dependencies
	     * @return {?}
	     */
	    function constructDependencies(typeOrFunc, dependencies) {
	        if (!dependencies) {
	            return _dependenciesFor(typeOrFunc);
	        }
	        else {
	            var /** @type {?} */ params_1 = dependencies.map(function (t) { return [t]; });
	            return dependencies.map(function (t) { return _extractToken(typeOrFunc, t, params_1); });
	        }
	    }
	    /**
	     * @param {?} typeOrFunc
	     * @return {?}
	     */
	    function _dependenciesFor(typeOrFunc) {
	        var /** @type {?} */ params = reflector.parameters(typeOrFunc);
	        if (!params)
	            return [];
	        if (params.some(function (p) { return p == null; })) {
	            throw new NoAnnotationError(typeOrFunc, params);
	        }
	        return params.map(function (p) { return _extractToken(typeOrFunc, p, params); });
	    }
	    /**
	     * @param {?} typeOrFunc
	     * @param {?} metadata
	     * @param {?} params
	     * @return {?}
	     */
	    function _extractToken(typeOrFunc, metadata, params) {
	        var /** @type {?} */ depProps = [];
	        var /** @type {?} */ token = null;
	        var /** @type {?} */ optional = false;
	        if (!Array.isArray(metadata)) {
	            if (metadata instanceof Inject) {
	                return _createDependency(metadata.token, optional, null, null, depProps);
	            }
	            else {
	                return _createDependency(metadata, optional, null, null, depProps);
	            }
	        }
	        var /** @type {?} */ lowerBoundVisibility = null;
	        var /** @type {?} */ upperBoundVisibility = null;
	        for (var /** @type {?} */ i = 0; i < metadata.length; ++i) {
	            var /** @type {?} */ paramMetadata = metadata[i];
	            if (paramMetadata instanceof Type) {
	                token = paramMetadata;
	            }
	            else if (paramMetadata instanceof Inject) {
	                token = paramMetadata.token;
	            }
	            else if (paramMetadata instanceof Optional) {
	                optional = true;
	            }
	            else if (paramMetadata instanceof Self) {
	                upperBoundVisibility = paramMetadata;
	            }
	            else if (paramMetadata instanceof Host) {
	                upperBoundVisibility = paramMetadata;
	            }
	            else if (paramMetadata instanceof SkipSelf) {
	                lowerBoundVisibility = paramMetadata;
	            }
	        }
	        token = resolveForwardRef(token);
	        if (token != null) {
	            return _createDependency(token, optional, lowerBoundVisibility, upperBoundVisibility, depProps);
	        }
	        else {
	            throw new NoAnnotationError(typeOrFunc, params);
	        }
	    }
	    /**
	     * @param {?} token
	     * @param {?} optional
	     * @param {?} lowerBoundVisibility
	     * @param {?} upperBoundVisibility
	     * @param {?} depProps
	     * @return {?}
	     */
	    function _createDependency(token, optional, lowerBoundVisibility, upperBoundVisibility, depProps) {
	        return new ReflectiveDependency(ReflectiveKey.get(token), optional, lowerBoundVisibility, upperBoundVisibility, depProps);
	    }

	    // Threshold for the dynamic version
	    var /** @type {?} */ _MAX_CONSTRUCTION_COUNTER = 10;
	    var /** @type {?} */ UNDEFINED = new Object();
	    var ReflectiveProtoInjectorInlineStrategy = (function () {
	        /**
	         * @param {?} protoEI
	         * @param {?} providers
	         */
	        function ReflectiveProtoInjectorInlineStrategy(protoEI, providers) {
	            this.provider0 = null;
	            this.provider1 = null;
	            this.provider2 = null;
	            this.provider3 = null;
	            this.provider4 = null;
	            this.provider5 = null;
	            this.provider6 = null;
	            this.provider7 = null;
	            this.provider8 = null;
	            this.provider9 = null;
	            this.keyId0 = null;
	            this.keyId1 = null;
	            this.keyId2 = null;
	            this.keyId3 = null;
	            this.keyId4 = null;
	            this.keyId5 = null;
	            this.keyId6 = null;
	            this.keyId7 = null;
	            this.keyId8 = null;
	            this.keyId9 = null;
	            var length = providers.length;
	            if (length > 0) {
	                this.provider0 = providers[0];
	                this.keyId0 = providers[0].key.id;
	            }
	            if (length > 1) {
	                this.provider1 = providers[1];
	                this.keyId1 = providers[1].key.id;
	            }
	            if (length > 2) {
	                this.provider2 = providers[2];
	                this.keyId2 = providers[2].key.id;
	            }
	            if (length > 3) {
	                this.provider3 = providers[3];
	                this.keyId3 = providers[3].key.id;
	            }
	            if (length > 4) {
	                this.provider4 = providers[4];
	                this.keyId4 = providers[4].key.id;
	            }
	            if (length > 5) {
	                this.provider5 = providers[5];
	                this.keyId5 = providers[5].key.id;
	            }
	            if (length > 6) {
	                this.provider6 = providers[6];
	                this.keyId6 = providers[6].key.id;
	            }
	            if (length > 7) {
	                this.provider7 = providers[7];
	                this.keyId7 = providers[7].key.id;
	            }
	            if (length > 8) {
	                this.provider8 = providers[8];
	                this.keyId8 = providers[8].key.id;
	            }
	            if (length > 9) {
	                this.provider9 = providers[9];
	                this.keyId9 = providers[9].key.id;
	            }
	        }
	        /**
	         * @param {?} index
	         * @return {?}
	         */
	        ReflectiveProtoInjectorInlineStrategy.prototype.getProviderAtIndex = function (index) {
	            if (index == 0)
	                return this.provider0;
	            if (index == 1)
	                return this.provider1;
	            if (index == 2)
	                return this.provider2;
	            if (index == 3)
	                return this.provider3;
	            if (index == 4)
	                return this.provider4;
	            if (index == 5)
	                return this.provider5;
	            if (index == 6)
	                return this.provider6;
	            if (index == 7)
	                return this.provider7;
	            if (index == 8)
	                return this.provider8;
	            if (index == 9)
	                return this.provider9;
	            throw new OutOfBoundsError(index);
	        };
	        /**
	         * @param {?} injector
	         * @return {?}
	         */
	        ReflectiveProtoInjectorInlineStrategy.prototype.createInjectorStrategy = function (injector) {
	            return new ReflectiveInjectorInlineStrategy(injector, this);
	        };
	        return ReflectiveProtoInjectorInlineStrategy;
	    }());
	    var ReflectiveProtoInjectorDynamicStrategy = (function () {
	        /**
	         * @param {?} protoInj
	         * @param {?} providers
	         */
	        function ReflectiveProtoInjectorDynamicStrategy(protoInj, providers) {
	            this.providers = providers;
	            var len = providers.length;
	            this.keyIds = new Array(len);
	            for (var i = 0; i < len; i++) {
	                this.keyIds[i] = providers[i].key.id;
	            }
	        }
	        /**
	         * @param {?} index
	         * @return {?}
	         */
	        ReflectiveProtoInjectorDynamicStrategy.prototype.getProviderAtIndex = function (index) {
	            if (index < 0 || index >= this.providers.length) {
	                throw new OutOfBoundsError(index);
	            }
	            return this.providers[index];
	        };
	        /**
	         * @param {?} ei
	         * @return {?}
	         */
	        ReflectiveProtoInjectorDynamicStrategy.prototype.createInjectorStrategy = function (ei) {
	            return new ReflectiveInjectorDynamicStrategy(this, ei);
	        };
	        return ReflectiveProtoInjectorDynamicStrategy;
	    }());
	    var ReflectiveProtoInjector = (function () {
	        /**
	         * @param {?} providers
	         */
	        function ReflectiveProtoInjector(providers) {
	            this.numberOfProviders = providers.length;
	            this._strategy = providers.length > _MAX_CONSTRUCTION_COUNTER ?
	                new ReflectiveProtoInjectorDynamicStrategy(this, providers) :
	                new ReflectiveProtoInjectorInlineStrategy(this, providers);
	        }
	        /**
	         * @param {?} providers
	         * @return {?}
	         */
	        ReflectiveProtoInjector.fromResolvedProviders = function (providers) {
	            return new ReflectiveProtoInjector(providers);
	        };
	        /**
	         * @param {?} index
	         * @return {?}
	         */
	        ReflectiveProtoInjector.prototype.getProviderAtIndex = function (index) {
	            return this._strategy.getProviderAtIndex(index);
	        };
	        return ReflectiveProtoInjector;
	    }());
	    var ReflectiveInjectorInlineStrategy = (function () {
	        /**
	         * @param {?} injector
	         * @param {?} protoStrategy
	         */
	        function ReflectiveInjectorInlineStrategy(injector, protoStrategy) {
	            this.injector = injector;
	            this.protoStrategy = protoStrategy;
	            this.obj0 = UNDEFINED;
	            this.obj1 = UNDEFINED;
	            this.obj2 = UNDEFINED;
	            this.obj3 = UNDEFINED;
	            this.obj4 = UNDEFINED;
	            this.obj5 = UNDEFINED;
	            this.obj6 = UNDEFINED;
	            this.obj7 = UNDEFINED;
	            this.obj8 = UNDEFINED;
	            this.obj9 = UNDEFINED;
	        }
	        /**
	         * @return {?}
	         */
	        ReflectiveInjectorInlineStrategy.prototype.resetConstructionCounter = function () { this.injector._constructionCounter = 0; };
	        /**
	         * @param {?} provider
	         * @return {?}
	         */
	        ReflectiveInjectorInlineStrategy.prototype.instantiateProvider = function (provider) {
	            return this.injector._new(provider);
	        };
	        /**
	         * @param {?} keyId
	         * @return {?}
	         */
	        ReflectiveInjectorInlineStrategy.prototype.getObjByKeyId = function (keyId) {
	            var /** @type {?} */ p = this.protoStrategy;
	            var /** @type {?} */ inj = this.injector;
	            if (p.keyId0 === keyId) {
	                if (this.obj0 === UNDEFINED) {
	                    this.obj0 = inj._new(p.provider0);
	                }
	                return this.obj0;
	            }
	            if (p.keyId1 === keyId) {
	                if (this.obj1 === UNDEFINED) {
	                    this.obj1 = inj._new(p.provider1);
	                }
	                return this.obj1;
	            }
	            if (p.keyId2 === keyId) {
	                if (this.obj2 === UNDEFINED) {
	                    this.obj2 = inj._new(p.provider2);
	                }
	                return this.obj2;
	            }
	            if (p.keyId3 === keyId) {
	                if (this.obj3 === UNDEFINED) {
	                    this.obj3 = inj._new(p.provider3);
	                }
	                return this.obj3;
	            }
	            if (p.keyId4 === keyId) {
	                if (this.obj4 === UNDEFINED) {
	                    this.obj4 = inj._new(p.provider4);
	                }
	                return this.obj4;
	            }
	            if (p.keyId5 === keyId) {
	                if (this.obj5 === UNDEFINED) {
	                    this.obj5 = inj._new(p.provider5);
	                }
	                return this.obj5;
	            }
	            if (p.keyId6 === keyId) {
	                if (this.obj6 === UNDEFINED) {
	                    this.obj6 = inj._new(p.provider6);
	                }
	                return this.obj6;
	            }
	            if (p.keyId7 === keyId) {
	                if (this.obj7 === UNDEFINED) {
	                    this.obj7 = inj._new(p.provider7);
	                }
	                return this.obj7;
	            }
	            if (p.keyId8 === keyId) {
	                if (this.obj8 === UNDEFINED) {
	                    this.obj8 = inj._new(p.provider8);
	                }
	                return this.obj8;
	            }
	            if (p.keyId9 === keyId) {
	                if (this.obj9 === UNDEFINED) {
	                    this.obj9 = inj._new(p.provider9);
	                }
	                return this.obj9;
	            }
	            return UNDEFINED;
	        };
	        /**
	         * @param {?} index
	         * @return {?}
	         */
	        ReflectiveInjectorInlineStrategy.prototype.getObjAtIndex = function (index) {
	            if (index == 0)
	                return this.obj0;
	            if (index == 1)
	                return this.obj1;
	            if (index == 2)
	                return this.obj2;
	            if (index == 3)
	                return this.obj3;
	            if (index == 4)
	                return this.obj4;
	            if (index == 5)
	                return this.obj5;
	            if (index == 6)
	                return this.obj6;
	            if (index == 7)
	                return this.obj7;
	            if (index == 8)
	                return this.obj8;
	            if (index == 9)
	                return this.obj9;
	            throw new OutOfBoundsError(index);
	        };
	        /**
	         * @return {?}
	         */
	        ReflectiveInjectorInlineStrategy.prototype.getMaxNumberOfObjects = function () { return _MAX_CONSTRUCTION_COUNTER; };
	        return ReflectiveInjectorInlineStrategy;
	    }());
	    var ReflectiveInjectorDynamicStrategy = (function () {
	        /**
	         * @param {?} protoStrategy
	         * @param {?} injector
	         */
	        function ReflectiveInjectorDynamicStrategy(protoStrategy, injector) {
	            this.protoStrategy = protoStrategy;
	            this.injector = injector;
	            this.objs = new Array(protoStrategy.providers.length).fill(UNDEFINED);
	        }
	        /**
	         * @return {?}
	         */
	        ReflectiveInjectorDynamicStrategy.prototype.resetConstructionCounter = function () { this.injector._constructionCounter = 0; };
	        /**
	         * @param {?} provider
	         * @return {?}
	         */
	        ReflectiveInjectorDynamicStrategy.prototype.instantiateProvider = function (provider) {
	            return this.injector._new(provider);
	        };
	        /**
	         * @param {?} keyId
	         * @return {?}
	         */
	        ReflectiveInjectorDynamicStrategy.prototype.getObjByKeyId = function (keyId) {
	            var /** @type {?} */ p = this.protoStrategy;
	            for (var /** @type {?} */ i = 0; i < p.keyIds.length; i++) {
	                if (p.keyIds[i] === keyId) {
	                    if (this.objs[i] === UNDEFINED) {
	                        this.objs[i] = this.injector._new(p.providers[i]);
	                    }
	                    return this.objs[i];
	                }
	            }
	            return UNDEFINED;
	        };
	        /**
	         * @param {?} index
	         * @return {?}
	         */
	        ReflectiveInjectorDynamicStrategy.prototype.getObjAtIndex = function (index) {
	            if (index < 0 || index >= this.objs.length) {
	                throw new OutOfBoundsError(index);
	            }
	            return this.objs[index];
	        };
	        /**
	         * @return {?}
	         */
	        ReflectiveInjectorDynamicStrategy.prototype.getMaxNumberOfObjects = function () { return this.objs.length; };
	        return ReflectiveInjectorDynamicStrategy;
	    }());
	    /**
	     * A ReflectiveDependency injection container used for instantiating objects and resolving
	     * dependencies.
	     *
	     * An `Injector` is a replacement for a `new` operator, which can automatically resolve the
	     * constructor dependencies.
	     *
	     * In typical use, application code asks for the dependencies in the constructor and they are
	     * resolved by the `Injector`.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/jzjec0?p=preview))
	     *
	     * The following example creates an `Injector` configured to create `Engine` and `Car`.
	     *
	     * ```typescript
	     * \@Injectable()
	     * class Engine {
	     * }
	     *
	     * \@Injectable()
	     * class Car {
	     *   constructor(public engine:Engine) {}
	     * }
	     *
	     * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
	     * var car = injector.get(Car);
	     * expect(car instanceof Car).toBe(true);
	     * expect(car.engine instanceof Engine).toBe(true);
	     * ```
	     *
	     * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`
	     * resolve all of the object's dependencies automatically.
	     *
	     * \@stable
	     * @abstract
	     */
	    var ReflectiveInjector = (function () {
	        function ReflectiveInjector() {
	        }
	        /**
	         * Turns an array of provider definitions into an array of resolved providers.
	         *
	         * A resolution is a process of flattening multiple nested arrays and converting individual
	         * providers into an array of {\@link ResolvedReflectiveProvider}s.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/AiXTHi?p=preview))
	         *
	         * ```typescript
	         * \@Injectable()
	         * class Engine {
	         * }
	         *
	         * \@Injectable()
	         * class Car {
	         *   constructor(public engine:Engine) {}
	         * }
	         *
	         * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);
	         *
	         * expect(providers.length).toEqual(2);
	         *
	         * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);
	         * expect(providers[0].key.displayName).toBe("Car");
	         * expect(providers[0].dependencies.length).toEqual(1);
	         * expect(providers[0].factory).toBeDefined();
	         *
	         * expect(providers[1].key.displayName).toBe("Engine");
	         * });
	         * ```
	         *
	         * See {\@link ReflectiveInjector#fromResolvedProviders} for more info.
	         * @param {?} providers
	         * @return {?}
	         */
	        ReflectiveInjector.resolve = function (providers) {
	            return resolveReflectiveProviders(providers);
	        };
	        /**
	         * Resolves an array of providers and creates an injector from those providers.
	         *
	         * The passed-in providers can be an array of `Type`, {\@link Provider},
	         * or a recursive array of more providers.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/ePOccA?p=preview))
	         *
	         * ```typescript
	         * \@Injectable()
	         * class Engine {
	         * }
	         *
	         * \@Injectable()
	         * class Car {
	         *   constructor(public engine:Engine) {}
	         * }
	         *
	         * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
	         * expect(injector.get(Car) instanceof Car).toBe(true);
	         * ```
	         *
	         * This function is slower than the corresponding `fromResolvedProviders`
	         * because it needs to resolve the passed-in providers first.
	         * See {\@link Injector#resolve} and {\@link Injector#fromResolvedProviders}.
	         * @param {?} providers
	         * @param {?=} parent
	         * @return {?}
	         */
	        ReflectiveInjector.resolveAndCreate = function (providers, parent) {
	            if (parent === void 0) { parent = null; }
	            var /** @type {?} */ ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
	            return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);
	        };
	        /**
	         * Creates an injector from previously resolved providers.
	         *
	         * This API is the recommended way to construct injectors in performance-sensitive parts.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/KrSMci?p=preview))
	         *
	         * ```typescript
	         * \@Injectable()
	         * class Engine {
	         * }
	         *
	         * \@Injectable()
	         * class Car {
	         *   constructor(public engine:Engine) {}
	         * }
	         *
	         * var providers = ReflectiveInjector.resolve([Car, Engine]);
	         * var injector = ReflectiveInjector.fromResolvedProviders(providers);
	         * expect(injector.get(Car) instanceof Car).toBe(true);
	         * ```
	         * \@experimental
	         * @param {?} providers
	         * @param {?=} parent
	         * @return {?}
	         */
	        ReflectiveInjector.fromResolvedProviders = function (providers, parent) {
	            if (parent === void 0) { parent = null; }
	            return new ReflectiveInjector_(ReflectiveProtoInjector.fromResolvedProviders(providers), parent);
	        };
	        Object.defineProperty(ReflectiveInjector.prototype, "parent", {
	            /**
	             * Parent of this injector.
	             *
	             * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
	             * -->
	             *
	             * ### Example ([live demo](http://plnkr.co/edit/eosMGo?p=preview))
	             *
	             * ```typescript
	             * var parent = ReflectiveInjector.resolveAndCreate([]);
	             * var child = parent.resolveAndCreateChild([]);
	             * expect(child.parent).toBe(parent);
	             * ```
	             * @return {?}
	             */
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * Resolves an array of providers and creates a child injector from those providers.
	         *
	         * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
	         * -->
	         *
	         * The passed-in providers can be an array of `Type`, {\@link Provider},
	         * or a recursive array of more providers.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/opB3T4?p=preview))
	         *
	         * ```typescript
	         * class ParentProvider {}
	         * class ChildProvider {}
	         *
	         * var parent = ReflectiveInjector.resolveAndCreate([ParentProvider]);
	         * var child = parent.resolveAndCreateChild([ChildProvider]);
	         *
	         * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);
	         * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);
	         * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));
	         * ```
	         *
	         * This function is slower than the corresponding `createChildFromResolved`
	         * because it needs to resolve the passed-in providers first.
	         * See {\@link Injector#resolve} and {\@link Injector#createChildFromResolved}.
	         * @param {?} providers
	         * @return {?}
	         */
	        ReflectiveInjector.prototype.resolveAndCreateChild = function (providers) { return unimplemented(); };
	        /**
	         * Creates a child injector from previously resolved providers.
	         *
	         * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.
	         * -->
	         *
	         * This API is the recommended way to construct injectors in performance-sensitive parts.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/VhyfjN?p=preview))
	         *
	         * ```typescript
	         * class ParentProvider {}
	         * class ChildProvider {}
	         *
	         * var parentProviders = ReflectiveInjector.resolve([ParentProvider]);
	         * var childProviders = ReflectiveInjector.resolve([ChildProvider]);
	         *
	         * var parent = ReflectiveInjector.fromResolvedProviders(parentProviders);
	         * var child = parent.createChildFromResolved(childProviders);
	         *
	         * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);
	         * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);
	         * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));
	         * ```
	         * @param {?} providers
	         * @return {?}
	         */
	        ReflectiveInjector.prototype.createChildFromResolved = function (providers) {
	            return unimplemented();
	        };
	        /**
	         * Resolves a provider and instantiates an object in the context of the injector.
	         *
	         * The created object does not get cached by the injector.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/yvVXoB?p=preview))
	         *
	         * ```typescript
	         * \@Injectable()
	         * class Engine {
	         * }
	         *
	         * \@Injectable()
	         * class Car {
	         *   constructor(public engine:Engine) {}
	         * }
	         *
	         * var injector = ReflectiveInjector.resolveAndCreate([Engine]);
	         *
	         * var car = injector.resolveAndInstantiate(Car);
	         * expect(car.engine).toBe(injector.get(Engine));
	         * expect(car).not.toBe(injector.resolveAndInstantiate(Car));
	         * ```
	         * @param {?} provider
	         * @return {?}
	         */
	        ReflectiveInjector.prototype.resolveAndInstantiate = function (provider) { return unimplemented(); };
	        /**
	         * Instantiates an object using a resolved provider in the context of the injector.
	         *
	         * The created object does not get cached by the injector.
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/ptCImQ?p=preview))
	         *
	         * ```typescript
	         * \@Injectable()
	         * class Engine {
	         * }
	         *
	         * \@Injectable()
	         * class Car {
	         *   constructor(public engine:Engine) {}
	         * }
	         *
	         * var injector = ReflectiveInjector.resolveAndCreate([Engine]);
	         * var carProvider = ReflectiveInjector.resolve([Car])[0];
	         * var car = injector.instantiateResolved(carProvider);
	         * expect(car.engine).toBe(injector.get(Engine));
	         * expect(car).not.toBe(injector.instantiateResolved(carProvider));
	         * ```
	         * @param {?} provider
	         * @return {?}
	         */
	        ReflectiveInjector.prototype.instantiateResolved = function (provider) { return unimplemented(); };
	        /**
	         * @abstract
	         * @param {?} token
	         * @param {?=} notFoundValue
	         * @return {?}
	         */
	        ReflectiveInjector.prototype.get = function (token, notFoundValue) { };
	        return ReflectiveInjector;
	    }());
	    var ReflectiveInjector_ = (function () {
	        /**
	         * Private
	         * @param {?} _proto
	         * @param {?=} _parent
	         */
	        function ReflectiveInjector_(_proto /* ProtoInjector */, _parent) {
	            if (_parent === void 0) { _parent = null; }
	            /** @internal */
	            this._constructionCounter = 0;
	            this._proto = _proto;
	            this._parent = _parent;
	            this._strategy = _proto._strategy.createInjectorStrategy(this);
	        }
	        /**
	         * @param {?} token
	         * @param {?=} notFoundValue
	         * @return {?}
	         */
	        ReflectiveInjector_.prototype.get = function (token, notFoundValue) {
	            if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }
	            return this._getByKey(ReflectiveKey.get(token), null, null, notFoundValue);
	        };
	        /**
	         * @param {?} index
	         * @return {?}
	         */
	        ReflectiveInjector_.prototype.getAt = function (index) { return this._strategy.getObjAtIndex(index); };
	        Object.defineProperty(ReflectiveInjector_.prototype, "parent", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._parent; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ReflectiveInjector_.prototype, "internalStrategy", {
	            /**
	             * \@internal
	             * Internal. Do not use.
	             * We return `any` not to export the InjectorStrategy type.
	             * @return {?}
	             */
	            get: function () { return this._strategy; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} providers
	         * @return {?}
	         */
	        ReflectiveInjector_.prototype.resolveAndCreateChild = function (providers) {
	            var /** @type {?} */ ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
	            return this.createChildFromResolved(ResolvedReflectiveProviders);
	        };
	        /**
	         * @param {?} providers
	         * @return {?}
	         */
	        ReflectiveInjector_.prototype.createChildFromResolved = function (providers) {
	            var /** @type {?} */ proto = new ReflectiveProtoInjector(providers);
	            var /** @type {?} */ inj = new ReflectiveInjector_(proto);
	            inj._parent = this;
	            return inj;
	        };
	        /**
	         * @param {?} provider
	         * @return {?}
	         */
	        ReflectiveInjector_.prototype.resolveAndInstantiate = function (provider) {
	            return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);
	        };
	        /**
	         * @param {?} provider
	         * @return {?}
	         */
	        ReflectiveInjector_.prototype.instantiateResolved = function (provider) {
	            return this._instantiateProvider(provider);
	        };
	        /**
	         * \@internal
	         * @param {?} provider
	         * @return {?}
	         */
	        ReflectiveInjector_.prototype._new = function (provider) {
	            if (this._constructionCounter++ > this._strategy.getMaxNumberOfObjects()) {
	                throw new CyclicDependencyError(this, provider.key);
	            }
	            return this._instantiateProvider(provider);
	        };
	        /**
	         * @param {?} provider
	         * @return {?}
	         */
	        ReflectiveInjector_.prototype._instantiateProvider = function (provider) {
	            if (provider.multiProvider) {
	                var /** @type {?} */ res = new Array(provider.resolvedFactories.length);
	                for (var /** @type {?} */ i = 0; i < provider.resolvedFactories.length; ++i) {
	                    res[i] = this._instantiate(provider, provider.resolvedFactories[i]);
	                }
	                return res;
	            }
	            else {
	                return this._instantiate(provider, provider.resolvedFactories[0]);
	            }
	        };
	        /**
	         * @param {?} provider
	         * @param {?} ResolvedReflectiveFactory
	         * @return {?}
	         */
	        ReflectiveInjector_.prototype._instantiate = function (provider, ResolvedReflectiveFactory) {
	            var /** @type {?} */ factory = ResolvedReflectiveFactory.factory;
	            var /** @type {?} */ deps = ResolvedReflectiveFactory.dependencies;
	            var /** @type {?} */ length = deps.length;
	            var /** @type {?} */ d0;
	            var /** @type {?} */ d1;
	            var /** @type {?} */ d2;
	            var /** @type {?} */ d3;
	            var /** @type {?} */ d4;
	            var /** @type {?} */ d5;
	            var /** @type {?} */ d6;
	            var /** @type {?} */ d7;
	            var /** @type {?} */ d8;
	            var /** @type {?} */ d9;
	            var /** @type {?} */ d10;
	            var /** @type {?} */ d11;
	            var /** @type {?} */ d12;
	            var /** @type {?} */ d13;
	            var /** @type {?} */ d14;
	            var /** @type {?} */ d15;
	            var /** @type {?} */ d16;
	            var /** @type {?} */ d17;
	            var /** @type {?} */ d18;
	            var /** @type {?} */ d19;
	            try {
	                d0 = length > 0 ? this._getByReflectiveDependency(provider, deps[0]) : null;
	                d1 = length > 1 ? this._getByReflectiveDependency(provider, deps[1]) : null;
	                d2 = length > 2 ? this._getByReflectiveDependency(provider, deps[2]) : null;
	                d3 = length > 3 ? this._getByReflectiveDependency(provider, deps[3]) : null;
	                d4 = length > 4 ? this._getByReflectiveDependency(provider, deps[4]) : null;
	                d5 = length > 5 ? this._getByReflectiveDependency(provider, deps[5]) : null;
	                d6 = length > 6 ? this._getByReflectiveDependency(provider, deps[6]) : null;
	                d7 = length > 7 ? this._getByReflectiveDependency(provider, deps[7]) : null;
	                d8 = length > 8 ? this._getByReflectiveDependency(provider, deps[8]) : null;
	                d9 = length > 9 ? this._getByReflectiveDependency(provider, deps[9]) : null;
	                d10 = length > 10 ? this._getByReflectiveDependency(provider, deps[10]) : null;
	                d11 = length > 11 ? this._getByReflectiveDependency(provider, deps[11]) : null;
	                d12 = length > 12 ? this._getByReflectiveDependency(provider, deps[12]) : null;
	                d13 = length > 13 ? this._getByReflectiveDependency(provider, deps[13]) : null;
	                d14 = length > 14 ? this._getByReflectiveDependency(provider, deps[14]) : null;
	                d15 = length > 15 ? this._getByReflectiveDependency(provider, deps[15]) : null;
	                d16 = length > 16 ? this._getByReflectiveDependency(provider, deps[16]) : null;
	                d17 = length > 17 ? this._getByReflectiveDependency(provider, deps[17]) : null;
	                d18 = length > 18 ? this._getByReflectiveDependency(provider, deps[18]) : null;
	                d19 = length > 19 ? this._getByReflectiveDependency(provider, deps[19]) : null;
	            }
	            catch (e) {
	                if (e instanceof AbstractProviderError || e instanceof InstantiationError) {
	                    e.addKey(this, provider.key);
	                }
	                throw e;
	            }
	            var /** @type {?} */ obj;
	            try {
	                switch (length) {
	                    case 0:
	                        obj = factory();
	                        break;
	                    case 1:
	                        obj = factory(d0);
	                        break;
	                    case 2:
	                        obj = factory(d0, d1);
	                        break;
	                    case 3:
	                        obj = factory(d0, d1, d2);
	                        break;
	                    case 4:
	                        obj = factory(d0, d1, d2, d3);
	                        break;
	                    case 5:
	                        obj = factory(d0, d1, d2, d3, d4);
	                        break;
	                    case 6:
	                        obj = factory(d0, d1, d2, d3, d4, d5);
	                        break;
	                    case 7:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6);
	                        break;
	                    case 8:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7);
	                        break;
	                    case 9:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8);
	                        break;
	                    case 10:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9);
	                        break;
	                    case 11:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10);
	                        break;
	                    case 12:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11);
	                        break;
	                    case 13:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12);
	                        break;
	                    case 14:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13);
	                        break;
	                    case 15:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14);
	                        break;
	                    case 16:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15);
	                        break;
	                    case 17:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16);
	                        break;
	                    case 18:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17);
	                        break;
	                    case 19:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18);
	                        break;
	                    case 20:
	                        obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18, d19);
	                        break;
	                    default:
	                        throw new Error("Cannot instantiate '" + provider.key.displayName + "' because it has more than 20 dependencies");
	                }
	            }
	            catch (e) {
	                throw new InstantiationError(this, e, e.stack, provider.key);
	            }
	            return obj;
	        };
	        /**
	         * @param {?} provider
	         * @param {?} dep
	         * @return {?}
	         */
	        ReflectiveInjector_.prototype._getByReflectiveDependency = function (provider, dep) {
	            return this._getByKey(dep.key, dep.lowerBoundVisibility, dep.upperBoundVisibility, dep.optional ? null : THROW_IF_NOT_FOUND);
	        };
	        /**
	         * @param {?} key
	         * @param {?} lowerBoundVisibility
	         * @param {?} upperBoundVisibility
	         * @param {?} notFoundValue
	         * @return {?}
	         */
	        ReflectiveInjector_.prototype._getByKey = function (key, lowerBoundVisibility, upperBoundVisibility, notFoundValue) {
	            if (key === INJECTOR_KEY) {
	                return this;
	            }
	            if (upperBoundVisibility instanceof Self) {
	                return this._getByKeySelf(key, notFoundValue);
	            }
	            else {
	                return this._getByKeyDefault(key, notFoundValue, lowerBoundVisibility);
	            }
	        };
	        /**
	         * \@internal
	         * @param {?} key
	         * @param {?} notFoundValue
	         * @return {?}
	         */
	        ReflectiveInjector_.prototype._throwOrNull = function (key, notFoundValue) {
	            if (notFoundValue !== THROW_IF_NOT_FOUND) {
	                return notFoundValue;
	            }
	            else {
	                throw new NoProviderError(this, key);
	            }
	        };
	        /**
	         * \@internal
	         * @param {?} key
	         * @param {?} notFoundValue
	         * @return {?}
	         */
	        ReflectiveInjector_.prototype._getByKeySelf = function (key, notFoundValue) {
	            var /** @type {?} */ obj = this._strategy.getObjByKeyId(key.id);
	            return (obj !== UNDEFINED) ? obj : this._throwOrNull(key, notFoundValue);
	        };
	        /**
	         * \@internal
	         * @param {?} key
	         * @param {?} notFoundValue
	         * @param {?} lowerBoundVisibility
	         * @return {?}
	         */
	        ReflectiveInjector_.prototype._getByKeyDefault = function (key, notFoundValue, lowerBoundVisibility) {
	            var /** @type {?} */ inj;
	            if (lowerBoundVisibility instanceof SkipSelf) {
	                inj = this._parent;
	            }
	            else {
	                inj = this;
	            }
	            while (inj instanceof ReflectiveInjector_) {
	                var /** @type {?} */ inj_ = (inj);
	                var /** @type {?} */ obj = inj_._strategy.getObjByKeyId(key.id);
	                if (obj !== UNDEFINED)
	                    return obj;
	                inj = inj_._parent;
	            }
	            if (inj !== null) {
	                return inj.get(key.token, notFoundValue);
	            }
	            else {
	                return this._throwOrNull(key, notFoundValue);
	            }
	        };
	        Object.defineProperty(ReflectiveInjector_.prototype, "displayName", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                var /** @type {?} */ providers = _mapProviders(this, function (b) { return ' "' + b.key.displayName + '" '; })
	                    .join(', ');
	                return "ReflectiveInjector(providers: [" + providers + "])";
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        ReflectiveInjector_.prototype.toString = function () { return this.displayName; };
	        return ReflectiveInjector_;
	    }());
	    var /** @type {?} */ INJECTOR_KEY = ReflectiveKey.get(Injector);
	    /**
	     * @param {?} injector
	     * @param {?} fn
	     * @return {?}
	     */
	    function _mapProviders(injector, fn) {
	        var /** @type {?} */ res = new Array(injector._proto.numberOfProviders);
	        for (var /** @type {?} */ i = 0; i < injector._proto.numberOfProviders; ++i) {
	            res[i] = fn(injector._proto.getProviderAtIndex(i));
	        }
	        return res;
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * \@whatItDoes Provides a hook for centralized exception handling.
	     *
	     * \@description
	     *
	     * The default implementation of `ErrorHandler` prints error messages to the `console`. To
	     * intercept error handling, write a custom exception handler that replaces this default as
	     * appropriate for your app.
	     *
	     * ### Example
	     *
	     * ```
	     * class MyErrorHandler implements ErrorHandler {
	     *   handleError(error) {
	     *     // do something with the exception
	     *   }
	     * }
	     *
	     * \@NgModule({
	     *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]
	     * })
	     * class MyModule {}
	     * ```
	     *
	     * \@stable
	     */
	    var ErrorHandler = (function () {
	        /**
	         * @param {?=} rethrowError
	         */
	        function ErrorHandler(rethrowError) {
	            if (rethrowError === void 0) { rethrowError = true; }
	            /**
	             * @internal
	             */
	            this._console = console;
	            this.rethrowError = rethrowError;
	        }
	        /**
	         * @param {?} error
	         * @return {?}
	         */
	        ErrorHandler.prototype.handleError = function (error) {
	            var /** @type {?} */ originalError = this._findOriginalError(error);
	            var /** @type {?} */ originalStack = this._findOriginalStack(error);
	            var /** @type {?} */ context = this._findContext(error);
	            this._console.error("EXCEPTION: " + this._extractMessage(error));
	            if (originalError) {
	                this._console.error("ORIGINAL EXCEPTION: " + this._extractMessage(originalError));
	            }
	            if (originalStack) {
	                this._console.error('ORIGINAL STACKTRACE:');
	                this._console.error(originalStack);
	            }
	            if (context) {
	                this._console.error('ERROR CONTEXT:');
	                this._console.error(context);
	            }
	            // We rethrow exceptions, so operations like 'bootstrap' will result in an error
	            // when an error happens. If we do not rethrow, bootstrap will always succeed.
	            if (this.rethrowError)
	                throw error;
	        };
	        /**
	         * \@internal
	         * @param {?} error
	         * @return {?}
	         */
	        ErrorHandler.prototype._extractMessage = function (error) {
	            return error instanceof Error ? error.message : error.toString();
	        };
	        /**
	         * \@internal
	         * @param {?} error
	         * @return {?}
	         */
	        ErrorHandler.prototype._findContext = function (error) {
	            if (error) {
	                return error.context ? error.context :
	                    this._findContext(((error)).originalError);
	            }
	            return null;
	        };
	        /**
	         * \@internal
	         * @param {?} error
	         * @return {?}
	         */
	        ErrorHandler.prototype._findOriginalError = function (error) {
	            var /** @type {?} */ e = ((error)).originalError;
	            while (e && ((e)).originalError) {
	                e = ((e)).originalError;
	            }
	            return e;
	        };
	        /**
	         * \@internal
	         * @param {?} error
	         * @return {?}
	         */
	        ErrorHandler.prototype._findOriginalStack = function (error) {
	            if (!(error instanceof Error))
	                return null;
	            var /** @type {?} */ e = error;
	            var /** @type {?} */ stack = e.stack;
	            while (e instanceof Error && ((e)).originalError) {
	                e = ((e)).originalError;
	                if (e instanceof Error && e.stack) {
	                    stack = e.stack;
	                }
	            }
	            return stack;
	        };
	        return ErrorHandler;
	    }());

	    /**
	     * Wraps Javascript Objects
	     */
	    var StringMapWrapper = (function () {
	        function StringMapWrapper() {
	        }
	        /**
	         * @param {?} m1
	         * @param {?} m2
	         * @return {?}
	         */
	        StringMapWrapper.merge = function (m1, m2) {
	            var /** @type {?} */ m = {};
	            for (var _i = 0, _a = Object.keys(m1); _i < _a.length; _i++) {
	                var k = _a[_i];
	                m[k] = m1[k];
	            }
	            for (var _b = 0, _c = Object.keys(m2); _b < _c.length; _b++) {
	                var k = _c[_b];
	                m[k] = m2[k];
	            }
	            return m;
	        };
	        /**
	         * @param {?} m1
	         * @param {?} m2
	         * @return {?}
	         */
	        StringMapWrapper.equals = function (m1, m2) {
	            var /** @type {?} */ k1 = Object.keys(m1);
	            var /** @type {?} */ k2 = Object.keys(m2);
	            if (k1.length != k2.length) {
	                return false;
	            }
	            for (var /** @type {?} */ i = 0; i < k1.length; i++) {
	                var /** @type {?} */ key = k1[i];
	                if (m1[key] !== m2[key]) {
	                    return false;
	                }
	            }
	            return true;
	        };
	        return StringMapWrapper;
	    }());
	    var ListWrapper = (function () {
	        function ListWrapper() {
	        }
	        /**
	         * @param {?} arr
	         * @param {?} condition
	         * @return {?}
	         */
	        ListWrapper.findLast = function (arr, condition) {
	            for (var /** @type {?} */ i = arr.length - 1; i >= 0; i--) {
	                if (condition(arr[i])) {
	                    return arr[i];
	                }
	            }
	            return null;
	        };
	        /**
	         * @param {?} list
	         * @param {?} items
	         * @return {?}
	         */
	        ListWrapper.removeAll = function (list, items) {
	            for (var /** @type {?} */ i = 0; i < items.length; ++i) {
	                var /** @type {?} */ index = list.indexOf(items[i]);
	                if (index > -1) {
	                    list.splice(index, 1);
	                }
	            }
	        };
	        /**
	         * @param {?} list
	         * @param {?} el
	         * @return {?}
	         */
	        ListWrapper.remove = function (list, el) {
	            var /** @type {?} */ index = list.indexOf(el);
	            if (index > -1) {
	                list.splice(index, 1);
	                return true;
	            }
	            return false;
	        };
	        /**
	         * @param {?} a
	         * @param {?} b
	         * @return {?}
	         */
	        ListWrapper.equals = function (a, b) {
	            if (a.length != b.length)
	                return false;
	            for (var /** @type {?} */ i = 0; i < a.length; ++i) {
	                if (a[i] !== b[i])
	                    return false;
	            }
	            return true;
	        };
	        /**
	         * @param {?} list
	         * @return {?}
	         */
	        ListWrapper.flatten = function (list) {
	            return list.reduce(function (flat, item) {
	                var /** @type {?} */ flatItem = Array.isArray(item) ? ListWrapper.flatten(item) : item;
	                return ((flat)).concat(flatItem);
	            }, []);
	        };
	        return ListWrapper;
	    }());
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isListLikeIterable(obj) {
	        if (!isJsObject(obj))
	            return false;
	        return Array.isArray(obj) ||
	            (!(obj instanceof Map) &&
	                getSymbolIterator() in obj); // JS Iterable have a Symbol.iterator prop
	    }
	    /**
	     * @param {?} a
	     * @param {?} b
	     * @param {?} comparator
	     * @return {?}
	     */
	    function areIterablesEqual(a, b, comparator) {
	        var /** @type {?} */ iterator1 = a[getSymbolIterator()]();
	        var /** @type {?} */ iterator2 = b[getSymbolIterator()]();
	        while (true) {
	            var /** @type {?} */ item1 = iterator1.next();
	            var /** @type {?} */ item2 = iterator2.next();
	            if (item1.done && item2.done)
	                return true;
	            if (item1.done || item2.done)
	                return false;
	            if (!comparator(item1.value, item2.value))
	                return false;
	        }
	    }
	    /**
	     * @param {?} obj
	     * @param {?} fn
	     * @return {?}
	     */
	    function iterateListLike(obj, fn) {
	        if (Array.isArray(obj)) {
	            for (var /** @type {?} */ i = 0; i < obj.length; i++) {
	                fn(obj[i]);
	            }
	        }
	        else {
	            var /** @type {?} */ iterator = obj[getSymbolIterator()]();
	            var /** @type {?} */ item = void 0;
	            while (!((item = iterator.next()).done)) {
	                fn(item.value);
	            }
	        }
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     * @param {?} obj
	     * @return {?}
	     */
	    function isPromise(obj) {
	        // allow any Promise/A+ compliant thenable.
	        // It's up to the caller to ensure that obj.then conforms to the spec
	        return !!obj && typeof obj.then === 'function';
	    }

	    /**
	     * A function that will be executed when an application is initialized.
	     * @experimental
	     */
	    var /** @type {?} */ APP_INITIALIZER = new OpaqueToken('Application Initializer');
	    /**
	     * A class that reflects the state of running {\@link APP_INITIALIZER}s.
	     *
	     * \@experimental
	     */
	    var ApplicationInitStatus = (function () {
	        /**
	         * @param {?} appInits
	         */
	        function ApplicationInitStatus(appInits) {
	            var _this = this;
	            this._done = false;
	            var asyncInitPromises = [];
	            if (appInits) {
	                for (var i = 0; i < appInits.length; i++) {
	                    var initResult = appInits[i]();
	                    if (isPromise(initResult)) {
	                        asyncInitPromises.push(initResult);
	                    }
	                }
	            }
	            this._donePromise = Promise.all(asyncInitPromises).then(function () { _this._done = true; });
	            if (asyncInitPromises.length === 0) {
	                this._done = true;
	            }
	        }
	        Object.defineProperty(ApplicationInitStatus.prototype, "done", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._done; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ApplicationInitStatus.prototype, "donePromise", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._donePromise; },
	            enumerable: true,
	            configurable: true
	        });
	        ApplicationInitStatus.decorators = [
	            { type: Injectable },
	        ];
	        /** @nocollapse */
	        ApplicationInitStatus.ctorParameters = function () { return [
	            { type: Array, decorators: [{ type: Inject, args: [APP_INITIALIZER,] }, { type: Optional },] },
	        ]; };
	        return ApplicationInitStatus;
	    }());

	    /**
	     * A DI Token representing a unique string id assigned to the application by Angular and used
	     * primarily for prefixing application attributes and CSS styles when
	     * {@link ViewEncapsulation#Emulated} is being used.
	     *
	     * If you need to avoid randomly generated value to be used as an application id, you can provide
	     * a custom value via a DI provider <!-- TODO: provider --> configuring the root {@link Injector}
	     * using this token.
	     * @experimental
	     */
	    var /** @type {?} */ APP_ID = new OpaqueToken('AppId');
	    /**
	     * @return {?}
	     */
	    function _appIdRandomProviderFactory() {
	        return "" + _randomChar() + _randomChar() + _randomChar();
	    }
	    /**
	     * Providers that will generate a random APP_ID_TOKEN.
	     * @experimental
	     */
	    var /** @type {?} */ APP_ID_RANDOM_PROVIDER = {
	        provide: APP_ID,
	        useFactory: _appIdRandomProviderFactory,
	        deps: /** @type {?} */ ([]),
	    };
	    /**
	     * @return {?}
	     */
	    function _randomChar() {
	        return String.fromCharCode(97 + Math.floor(Math.random() * 25));
	    }
	    /**
	     * A function that will be executed when a platform is initialized.
	     * @experimental
	     */
	    var /** @type {?} */ PLATFORM_INITIALIZER = new OpaqueToken('Platform Initializer');
	    /**
	     * All callbacks provided via this token will be called for every component that is bootstrapped.
	     * Signature of the callback:
	     *
	     * `(componentRef: ComponentRef) => void`.
	     *
	     * @experimental
	     */
	    var /** @type {?} */ APP_BOOTSTRAP_LISTENER = new OpaqueToken('appBootstrapListener');
	    /**
	     * A token which indicates the root directory of the application
	     * @experimental
	     */
	    var /** @type {?} */ PACKAGE_ROOT_URL = new OpaqueToken('Application Packages Root URL');

	    var Console = (function () {
	        function Console() {
	        }
	        /**
	         * @param {?} message
	         * @return {?}
	         */
	        Console.prototype.log = function (message) { print(message); };
	        /**
	         * @param {?} message
	         * @return {?}
	         */
	        Console.prototype.warn = function (message) { warn(message); };
	        Console.decorators = [
	            { type: Injectable },
	        ];
	        /** @nocollapse */
	        Console.ctorParameters = function () { return []; };
	        return Console;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$4 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Indicates that a component is still being loaded in a synchronous compile.
	     *
	     * \@stable
	     */
	    var ComponentStillLoadingError = (function (_super) {
	        __extends$4(ComponentStillLoadingError, _super);
	        /**
	         * @param {?} compType
	         */
	        function ComponentStillLoadingError(compType) {
	            _super.call(this, "Can't compile synchronously as " + stringify(compType) + " is still being loaded!");
	            this.compType = compType;
	        }
	        return ComponentStillLoadingError;
	    }(BaseError));
	    /**
	     * Combination of NgModuleFactory and ComponentFactorys.
	     *
	     * \@experimental
	     */
	    var ModuleWithComponentFactories = (function () {
	        /**
	         * @param {?} ngModuleFactory
	         * @param {?} componentFactories
	         */
	        function ModuleWithComponentFactories(ngModuleFactory, componentFactories) {
	            this.ngModuleFactory = ngModuleFactory;
	            this.componentFactories = componentFactories;
	        }
	        return ModuleWithComponentFactories;
	    }());
	    /**
	     * @return {?}
	     */
	    function _throwError() {
	        throw new Error("Runtime compiler is not loaded");
	    }
	    /**
	     * Low-level service for running the angular compiler during runtime
	     * to create {\@link ComponentFactory}s, which
	     * can later be used to create and render a Component instance.
	     *
	     * Each `\@NgModule` provides an own `Compiler` to its injector,
	     * that will use the directives/pipes of the ng module for compilation
	     * of components.
	     * \@stable
	     */
	    var Compiler = (function () {
	        function Compiler() {
	        }
	        /**
	         * Compiles the given NgModule and all of its components. All templates of the components listed
	         * in `entryComponents`
	         * have to be inlined. Otherwise throws a {\@link ComponentStillLoadingError}.
	         * @param {?} moduleType
	         * @return {?}
	         */
	        Compiler.prototype.compileModuleSync = function (moduleType) { throw _throwError(); };
	        /**
	         * Compiles the given NgModule and all of its components
	         * @param {?} moduleType
	         * @return {?}
	         */
	        Compiler.prototype.compileModuleAsync = function (moduleType) { throw _throwError(); };
	        /**
	         * Same as {\@link compileModuleSync} but also creates ComponentFactories for all components.
	         * @param {?} moduleType
	         * @return {?}
	         */
	        Compiler.prototype.compileModuleAndAllComponentsSync = function (moduleType) {
	            throw _throwError();
	        };
	        /**
	         * Same as {\@link compileModuleAsync} but also creates ComponentFactories for all components.
	         * @param {?} moduleType
	         * @return {?}
	         */
	        Compiler.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {
	            throw _throwError();
	        };
	        /**
	         * Exposes the CSS-style selectors that have been used in `ngContent` directives within
	         * the template of the given component.
	         * This is used by the `upgrade` library to compile the appropriate transclude content
	         * in the Angular 1 wrapper component.
	         * @param {?} component
	         * @return {?}
	         */
	        Compiler.prototype.getNgContentSelectors = function (component) { throw _throwError(); };
	        /**
	         * Clears all caches.
	         * @return {?}
	         */
	        Compiler.prototype.clearCache = function () { };
	        /**
	         * Clears the cache for the given component/ngModule.
	         * @param {?} type
	         * @return {?}
	         */
	        Compiler.prototype.clearCacheFor = function (type) { };
	        Compiler.decorators = [
	            { type: Injectable },
	        ];
	        /** @nocollapse */
	        Compiler.ctorParameters = function () { return []; };
	        return Compiler;
	    }());
	    /**
	     * Token to provide CompilerOptions in the platform injector.
	     *
	     * @experimental
	     */
	    var /** @type {?} */ COMPILER_OPTIONS = new OpaqueToken('compilerOptions');
	    /**
	     * A factory for creating a Compiler
	     *
	     * \@experimental
	     * @abstract
	     */
	    var CompilerFactory = (function () {
	        function CompilerFactory() {
	        }
	        /**
	         * @abstract
	         * @param {?=} options
	         * @return {?}
	         */
	        CompilerFactory.prototype.createCompiler = function (options) { };
	        return CompilerFactory;
	    }());

	    var ElementRef = (function () {
	        /**
	         * @param {?} nativeElement
	         */
	        function ElementRef(nativeElement) {
	            this.nativeElement = nativeElement;
	        }
	        return ElementRef;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$6 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Use by directives and components to emit custom Events.
	     *
	     * ### Examples
	     *
	     * In the following example, `Zippy` alternatively emits `open` and `close` events when its
	     * title gets clicked:
	     *
	     * ```
	     * \@Component({
	     *   selector: 'zippy',
	     *   template: `
	     *   <div class="zippy">
	     *     <div (click)="toggle()">Toggle</div>
	     *     <div [hidden]="!visible">
	     *       <ng-content></ng-content>
	     *     </div>
	     *  </div>`})
	     * export class Zippy {
	     *   visible: boolean = true;
	     *   \@Output() open: EventEmitter<any> = new EventEmitter();
	     *   \@Output() close: EventEmitter<any> = new EventEmitter();
	     *
	     *   toggle() {
	     *     this.visible = !this.visible;
	     *     if (this.visible) {
	     *       this.open.emit(null);
	     *     } else {
	     *       this.close.emit(null);
	     *     }
	     *   }
	     * }
	     * ```
	     *
	     * The events payload can be accessed by the parameter `$event` on the components output event
	     * handler:
	     *
	     * ```
	     * <zippy (open)="onOpen($event)" (close)="onClose($event)"></zippy>
	     * ```
	     *
	     * Uses Rx.Observable but provides an adapter to make it work as specified here:
	     * https://github.com/jhusain/observable-spec
	     *
	     * Once a reference implementation of the spec is available, switch to it.
	     * \@stable
	     */
	    var EventEmitter = (function (_super) {
	        __extends$6(EventEmitter, _super);
	        /**
	         * Creates an instance of [EventEmitter], which depending on [isAsync],
	         * delivers events synchronously or asynchronously.
	         * @param {?=} isAsync
	         */
	        function EventEmitter(isAsync) {
	            if (isAsync === void 0) { isAsync = false; }
	            _super.call(this);
	            this.__isAsync = isAsync;
	        }
	        /**
	         * @param {?=} value
	         * @return {?}
	         */
	        EventEmitter.prototype.emit = function (value) { _super.prototype.next.call(this, value); };
	        /**
	         * @param {?=} generatorOrNext
	         * @param {?=} error
	         * @param {?=} complete
	         * @return {?}
	         */
	        EventEmitter.prototype.subscribe = function (generatorOrNext, error, complete) {
	            var /** @type {?} */ schedulerFn;
	            var /** @type {?} */ errorFn = function (err) { return null; };
	            var /** @type {?} */ completeFn = function () { return null; };
	            if (generatorOrNext && typeof generatorOrNext === 'object') {
	                schedulerFn = this.__isAsync ? function (value) {
	                    setTimeout(function () { return generatorOrNext.next(value); });
	                } : function (value) { generatorOrNext.next(value); };
	                if (generatorOrNext.error) {
	                    errorFn = this.__isAsync ? function (err) { setTimeout(function () { return generatorOrNext.error(err); }); } :
	                        function (err) { generatorOrNext.error(err); };
	                }
	                if (generatorOrNext.complete) {
	                    completeFn = this.__isAsync ? function () { setTimeout(function () { return generatorOrNext.complete(); }); } :
	                        function () { generatorOrNext.complete(); };
	                }
	            }
	            else {
	                schedulerFn = this.__isAsync ? function (value) { setTimeout(function () { return generatorOrNext(value); }); } :
	                    function (value) { generatorOrNext(value); };
	                if (error) {
	                    errorFn =
	                        this.__isAsync ? function (err) { setTimeout(function () { return error(err); }); } : function (err) { error(err); };
	                }
	                if (complete) {
	                    completeFn =
	                        this.__isAsync ? function () { setTimeout(function () { return complete(); }); } : function () { complete(); };
	                }
	            }
	            return _super.prototype.subscribe.call(this, schedulerFn, errorFn, completeFn);
	        };
	        return EventEmitter;
	    }(rxjs_Subject.Subject));

	    /**
	     * An injectable service for executing work inside or outside of the Angular zone.
	     *
	     * The most common use of this service is to optimize performance when starting a work consisting of
	     * one or more asynchronous tasks that don't require UI updates or error handling to be handled by
	     * Angular. Such tasks can be kicked off via {\@link runOutsideAngular} and if needed, these tasks
	     * can reenter the Angular zone via {\@link run}.
	     *
	     * <!-- TODO: add/fix links to:
	     *   - docs explaining zones and the use of zones in Angular and change-detection
	     *   - link to runOutsideAngular/run (throughout this file!)
	     *   -->
	     *
	     * ### Example
	     * ```
	     * import {Component, NgZone} from '\@angular/core';
	     * import {NgIf} from '\@angular/common';
	     *
	     * \@Component({
	     *   selector: 'ng-zone-demo'.
	     *   template: `
	     *     <h2>Demo: NgZone</h2>
	     *
	     *     <p>Progress: {{progress}}%</p>
	     *     <p *ngIf="progress >= 100">Done processing {{label}} of Angular zone!</p>
	     *
	     *     <button (click)="processWithinAngularZone()">Process within Angular zone</button>
	     *     <button (click)="processOutsideOfAngularZone()">Process outside of Angular zone</button>
	     *   `,
	     * })
	     * export class NgZoneDemo {
	     *   progress: number = 0;
	     *   label: string;
	     *
	     *   constructor(private _ngZone: NgZone) {}
	     *
	     *   // Loop inside the Angular zone
	     *   // so the UI DOES refresh after each setTimeout cycle
	     *   processWithinAngularZone() {
	     *     this.label = 'inside';
	     *     this.progress = 0;
	     *     this._increaseProgress(() => console.log('Inside Done!'));
	     *   }
	     *
	     *   // Loop outside of the Angular zone
	     *   // so the UI DOES NOT refresh after each setTimeout cycle
	     *   processOutsideOfAngularZone() {
	     *     this.label = 'outside';
	     *     this.progress = 0;
	     *     this._ngZone.runOutsideAngular(() => {
	     *       this._increaseProgress(() => {
	     *       // reenter the Angular zone and display done
	     *       this._ngZone.run(() => {console.log('Outside Done!') });
	     *     }}));
	     *   }
	     *
	     *   _increaseProgress(doneCallback: () => void) {
	     *     this.progress += 1;
	     *     console.log(`Current progress: ${this.progress}%`);
	     *
	     *     if (this.progress < 100) {
	     *       window.setTimeout(() => this._increaseProgress(doneCallback)), 10)
	     *     } else {
	     *       doneCallback();
	     *     }
	     *   }
	     * }
	     * ```
	     * \@experimental
	     */
	    var NgZone = (function () {
	        /**
	         * @param {?} __0
	         */
	        function NgZone(_a) {
	            var _b = _a.enableLongStackTrace, enableLongStackTrace = _b === void 0 ? false : _b;
	            this._hasPendingMicrotasks = false;
	            this._hasPendingMacrotasks = false;
	            this._isStable = true;
	            this._nesting = 0;
	            this._onUnstable = new EventEmitter(false);
	            this._onMicrotaskEmpty = new EventEmitter(false);
	            this._onStable = new EventEmitter(false);
	            this._onErrorEvents = new EventEmitter(false);
	            if (typeof Zone == 'undefined') {
	                throw new Error('Angular requires Zone.js prolyfill.');
	            }
	            Zone.assertZonePatched();
	            this.outer = this.inner = Zone.current;
	            if (Zone['wtfZoneSpec']) {
	                this.inner = this.inner.fork(Zone['wtfZoneSpec']);
	            }
	            if (enableLongStackTrace && Zone['longStackTraceZoneSpec']) {
	                this.inner = this.inner.fork(Zone['longStackTraceZoneSpec']);
	            }
	            this.forkInnerZoneWithAngularBehavior();
	        }
	        /**
	         * @return {?}
	         */
	        NgZone.isInAngularZone = function () { return Zone.current.get('isAngularZone') === true; };
	        /**
	         * @return {?}
	         */
	        NgZone.assertInAngularZone = function () {
	            if (!NgZone.isInAngularZone()) {
	                throw new Error('Expected to be in Angular Zone, but it is not!');
	            }
	        };
	        /**
	         * @return {?}
	         */
	        NgZone.assertNotInAngularZone = function () {
	            if (NgZone.isInAngularZone()) {
	                throw new Error('Expected to not be in Angular Zone, but it is!');
	            }
	        };
	        /**
	         * Executes the `fn` function synchronously within the Angular zone and returns value returned by
	         * the function.
	         *
	         * Running functions via `run` allows you to reenter Angular zone from a task that was executed
	         * outside of the Angular zone (typically started via {\@link runOutsideAngular}).
	         *
	         * Any future tasks or microtasks scheduled from within this function will continue executing from
	         * within the Angular zone.
	         *
	         * If a synchronous error happens it will be rethrown and not reported via `onError`.
	         * @param {?} fn
	         * @return {?}
	         */
	        NgZone.prototype.run = function (fn) { return this.inner.run(fn); };
	        /**
	         * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not
	         * rethrown.
	         * @param {?} fn
	         * @return {?}
	         */
	        NgZone.prototype.runGuarded = function (fn) { return this.inner.runGuarded(fn); };
	        /**
	         * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by
	         * the function.
	         *
	         * Running functions via `runOutsideAngular` allows you to escape Angular's zone and do work that
	         * doesn't trigger Angular change-detection or is subject to Angular's error handling.
	         *
	         * Any future tasks or microtasks scheduled from within this function will continue executing from
	         * outside of the Angular zone.
	         *
	         * Use {\@link run} to reenter the Angular zone and do work that updates the application model.
	         * @param {?} fn
	         * @return {?}
	         */
	        NgZone.prototype.runOutsideAngular = function (fn) { return this.outer.run(fn); };
	        Object.defineProperty(NgZone.prototype, "onUnstable", {
	            /**
	             * Notifies when code enters Angular Zone. This gets fired first on VM Turn.
	             * @return {?}
	             */
	            get: function () { return this._onUnstable; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgZone.prototype, "onMicrotaskEmpty", {
	            /**
	             * Notifies when there is no more microtasks enqueue in the current VM Turn.
	             * This is a hint for Angular to do change detection, which may enqueue more microtasks.
	             * For this reason this event can fire multiple times per VM Turn.
	             * @return {?}
	             */
	            get: function () { return this._onMicrotaskEmpty; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgZone.prototype, "onStable", {
	            /**
	             * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which
	             * implies we are about to relinquish VM turn.
	             * This event gets called just once.
	             * @return {?}
	             */
	            get: function () { return this._onStable; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgZone.prototype, "onError", {
	            /**
	             * Notify that an error has been delivered.
	             * @return {?}
	             */
	            get: function () { return this._onErrorEvents; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgZone.prototype, "isStable", {
	            /**
	             * Whether there are no outstanding microtasks or macrotasks.
	             * @return {?}
	             */
	            get: function () { return this._isStable; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgZone.prototype, "hasPendingMicrotasks", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._hasPendingMicrotasks; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgZone.prototype, "hasPendingMacrotasks", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._hasPendingMacrotasks; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        NgZone.prototype.checkStable = function () {
	            var _this = this;
	            if (this._nesting == 0 && !this._hasPendingMicrotasks && !this._isStable) {
	                try {
	                    this._nesting++;
	                    this._onMicrotaskEmpty.emit(null);
	                }
	                finally {
	                    this._nesting--;
	                    if (!this._hasPendingMicrotasks) {
	                        try {
	                            this.runOutsideAngular(function () { return _this._onStable.emit(null); });
	                        }
	                        finally {
	                            this._isStable = true;
	                        }
	                    }
	                }
	            }
	        };
	        /**
	         * @return {?}
	         */
	        NgZone.prototype.forkInnerZoneWithAngularBehavior = function () {
	            var _this = this;
	            this.inner = this.inner.fork({
	                name: 'angular',
	                properties: /** @type {?} */ ({ 'isAngularZone': true }),
	                onInvokeTask: function (delegate, current, target, task, applyThis, applyArgs) {
	                    try {
	                        _this.onEnter();
	                        return delegate.invokeTask(target, task, applyThis, applyArgs);
	                    }
	                    finally {
	                        _this.onLeave();
	                    }
	                },
	                onInvoke: function (delegate, current, target, callback, applyThis, applyArgs, source) {
	                    try {
	                        _this.onEnter();
	                        return delegate.invoke(target, callback, applyThis, applyArgs, source);
	                    }
	                    finally {
	                        _this.onLeave();
	                    }
	                },
	                onHasTask: function (delegate, current, target, hasTaskState) {
	                    delegate.hasTask(target, hasTaskState);
	                    if (current === target) {
	                        // We are only interested in hasTask events which originate from our zone
	                        // (A child hasTask event is not interesting to us)
	                        if (hasTaskState.change == 'microTask') {
	                            _this.setHasMicrotask(hasTaskState.microTask);
	                        }
	                        else if (hasTaskState.change == 'macroTask') {
	                            _this.setHasMacrotask(hasTaskState.macroTask);
	                        }
	                    }
	                },
	                onHandleError: function (delegate, current, target, error) {
	                    delegate.handleError(target, error);
	                    _this.triggerError(error);
	                    return false;
	                }
	            });
	        };
	        /**
	         * @return {?}
	         */
	        NgZone.prototype.onEnter = function () {
	            this._nesting++;
	            if (this._isStable) {
	                this._isStable = false;
	                this._onUnstable.emit(null);
	            }
	        };
	        /**
	         * @return {?}
	         */
	        NgZone.prototype.onLeave = function () {
	            this._nesting--;
	            this.checkStable();
	        };
	        /**
	         * @param {?} hasMicrotasks
	         * @return {?}
	         */
	        NgZone.prototype.setHasMicrotask = function (hasMicrotasks) {
	            this._hasPendingMicrotasks = hasMicrotasks;
	            this.checkStable();
	        };
	        /**
	         * @param {?} hasMacrotasks
	         * @return {?}
	         */
	        NgZone.prototype.setHasMacrotask = function (hasMacrotasks) { this._hasPendingMacrotasks = hasMacrotasks; };
	        /**
	         * @param {?} error
	         * @return {?}
	         */
	        NgZone.prototype.triggerError = function (error) { this._onErrorEvents.emit(error); };
	        return NgZone;
	    }());

	    var AnimationQueue = (function () {
	        /**
	         * @param {?} _zone
	         */
	        function AnimationQueue(_zone) {
	            this._zone = _zone;
	            this.entries = [];
	        }
	        /**
	         * @param {?} player
	         * @return {?}
	         */
	        AnimationQueue.prototype.enqueue = function (player) { this.entries.push(player); };
	        /**
	         * @return {?}
	         */
	        AnimationQueue.prototype.flush = function () {
	            var _this = this;
	            // given that each animation player may set aside
	            // microtasks and rely on DOM-based events, this
	            // will cause Angular to run change detection after
	            // each request. This sidesteps the issue. If a user
	            // hooks into an animation via (@anim.start) or (@anim.done)
	            // then those methods will automatically trigger change
	            // detection by wrapping themselves inside of a zone
	            if (this.entries.length) {
	                this._zone.runOutsideAngular(function () {
	                    // this code is wrapped into a single promise such that the
	                    // onStart and onDone player callbacks are triggered outside
	                    // of the digest cycle of animations
	                    Promise.resolve(null).then(function () { return _this._triggerAnimations(); });
	                });
	            }
	        };
	        /**
	         * @return {?}
	         */
	        AnimationQueue.prototype._triggerAnimations = function () {
	            NgZone.assertNotInAngularZone();
	            while (this.entries.length) {
	                var /** @type {?} */ player = this.entries.shift();
	                // in the event that an animation throws an error then we do
	                // not want to re-run animations on any previous animations
	                // if they have already been kicked off beforehand
	                if (!player.hasStarted()) {
	                    player.play();
	                }
	            }
	        };
	        AnimationQueue.decorators = [
	            { type: Injectable },
	        ];
	        /** @nocollapse */
	        AnimationQueue.ctorParameters = function () { return [
	            { type: NgZone, },
	        ]; };
	        return AnimationQueue;
	    }());

	    var DefaultIterableDifferFactory = (function () {
	        function DefaultIterableDifferFactory() {
	        }
	        /**
	         * @param {?} obj
	         * @return {?}
	         */
	        DefaultIterableDifferFactory.prototype.supports = function (obj) { return isListLikeIterable(obj); };
	        /**
	         * @param {?} cdRef
	         * @param {?=} trackByFn
	         * @return {?}
	         */
	        DefaultIterableDifferFactory.prototype.create = function (cdRef, trackByFn) {
	            return new DefaultIterableDiffer(trackByFn);
	        };
	        return DefaultIterableDifferFactory;
	    }());
	    var /** @type {?} */ trackByIdentity = function (index, item) { return item; };
	    /**
	     * \@stable
	     */
	    var DefaultIterableDiffer = (function () {
	        /**
	         * @param {?=} _trackByFn
	         */
	        function DefaultIterableDiffer(_trackByFn) {
	            this._trackByFn = _trackByFn;
	            this._length = null;
	            this._collection = null;
	            this._linkedRecords = null;
	            this._unlinkedRecords = null;
	            this._previousItHead = null;
	            this._itHead = null;
	            this._itTail = null;
	            this._additionsHead = null;
	            this._additionsTail = null;
	            this._movesHead = null;
	            this._movesTail = null;
	            this._removalsHead = null;
	            this._removalsTail = null;
	            this._identityChangesHead = null;
	            this._identityChangesTail = null;
	            this._trackByFn = this._trackByFn || trackByIdentity;
	        }
	        Object.defineProperty(DefaultIterableDiffer.prototype, "collection", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._collection; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DefaultIterableDiffer.prototype, "length", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._length; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype.forEachItem = function (fn) {
	            var /** @type {?} */ record;
	            for (record = this._itHead; record !== null; record = record._next) {
	                fn(record);
	            }
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype.forEachOperation = function (fn) {
	            var /** @type {?} */ nextIt = this._itHead;
	            var /** @type {?} */ nextRemove = this._removalsHead;
	            var /** @type {?} */ addRemoveOffset = 0;
	            var /** @type {?} */ moveOffsets = null;
	            while (nextIt || nextRemove) {
	                // Figure out which is the next record to process
	                // Order: remove, add, move
	                var /** @type {?} */ record = !nextRemove ||
	                    nextIt &&
	                        nextIt.currentIndex < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ?
	                    nextIt :
	                    nextRemove;
	                var /** @type {?} */ adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);
	                var /** @type {?} */ currentIndex = record.currentIndex;
	                // consume the item, and adjust the addRemoveOffset and update moveDistance if necessary
	                if (record === nextRemove) {
	                    addRemoveOffset--;
	                    nextRemove = nextRemove._nextRemoved;
	                }
	                else {
	                    nextIt = nextIt._next;
	                    if (record.previousIndex == null) {
	                        addRemoveOffset++;
	                    }
	                    else {
	                        // INVARIANT:  currentIndex < previousIndex
	                        if (!moveOffsets)
	                            moveOffsets = [];
	                        var /** @type {?} */ localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;
	                        var /** @type {?} */ localCurrentIndex = currentIndex - addRemoveOffset;
	                        if (localMovePreviousIndex != localCurrentIndex) {
	                            for (var /** @type {?} */ i = 0; i < localMovePreviousIndex; i++) {
	                                var /** @type {?} */ offset = i < moveOffsets.length ? moveOffsets[i] : (moveOffsets[i] = 0);
	                                var /** @type {?} */ index = offset + i;
	                                if (localCurrentIndex <= index && index < localMovePreviousIndex) {
	                                    moveOffsets[i] = offset + 1;
	                                }
	                            }
	                            var /** @type {?} */ previousIndex = record.previousIndex;
	                            moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;
	                        }
	                    }
	                }
	                if (adjPreviousIndex !== currentIndex) {
	                    fn(record, adjPreviousIndex, currentIndex);
	                }
	            }
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype.forEachPreviousItem = function (fn) {
	            var /** @type {?} */ record;
	            for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
	                fn(record);
	            }
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype.forEachAddedItem = function (fn) {
	            var /** @type {?} */ record;
	            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	                fn(record);
	            }
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype.forEachMovedItem = function (fn) {
	            var /** @type {?} */ record;
	            for (record = this._movesHead; record !== null; record = record._nextMoved) {
	                fn(record);
	            }
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype.forEachRemovedItem = function (fn) {
	            var /** @type {?} */ record;
	            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
	                fn(record);
	            }
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype.forEachIdentityChange = function (fn) {
	            var /** @type {?} */ record;
	            for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {
	                fn(record);
	            }
	        };
	        /**
	         * @param {?} collection
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype.diff = function (collection) {
	            if (isBlank(collection))
	                collection = [];
	            if (!isListLikeIterable(collection)) {
	                throw new Error("Error trying to diff '" + collection + "'");
	            }
	            if (this.check(collection)) {
	                return this;
	            }
	            else {
	                return null;
	            }
	        };
	        /**
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype.onDestroy = function () { };
	        /**
	         * @param {?} collection
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype.check = function (collection) {
	            var _this = this;
	            this._reset();
	            var /** @type {?} */ record = this._itHead;
	            var /** @type {?} */ mayBeDirty = false;
	            var /** @type {?} */ index;
	            var /** @type {?} */ item;
	            var /** @type {?} */ itemTrackBy;
	            if (Array.isArray(collection)) {
	                var /** @type {?} */ list = collection;
	                this._length = collection.length;
	                for (var /** @type {?} */ index_1 = 0; index_1 < this._length; index_1++) {
	                    item = list[index_1];
	                    itemTrackBy = this._trackByFn(index_1, item);
	                    if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {
	                        record = this._mismatch(record, item, itemTrackBy, index_1);
	                        mayBeDirty = true;
	                    }
	                    else {
	                        if (mayBeDirty) {
	                            // TODO(misko): can we limit this to duplicates only?
	                            record = this._verifyReinsertion(record, item, itemTrackBy, index_1);
	                        }
	                        if (!looseIdentical(record.item, item))
	                            this._addIdentityChange(record, item);
	                    }
	                    record = record._next;
	                }
	            }
	            else {
	                index = 0;
	                iterateListLike(collection, function (item /** TODO #9100 */) {
	                    itemTrackBy = _this._trackByFn(index, item);
	                    if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {
	                        record = _this._mismatch(record, item, itemTrackBy, index);
	                        mayBeDirty = true;
	                    }
	                    else {
	                        if (mayBeDirty) {
	                            // TODO(misko): can we limit this to duplicates only?
	                            record = _this._verifyReinsertion(record, item, itemTrackBy, index);
	                        }
	                        if (!looseIdentical(record.item, item))
	                            _this._addIdentityChange(record, item);
	                    }
	                    record = record._next;
	                    index++;
	                });
	                this._length = index;
	            }
	            this._truncate(record);
	            this._collection = collection;
	            return this.isDirty;
	        };
	        Object.defineProperty(DefaultIterableDiffer.prototype, "isDirty", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return this._additionsHead !== null || this._movesHead !== null ||
	                    this._removalsHead !== null || this._identityChangesHead !== null;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * Reset the state of the change objects to show no changes. This means set previousKey to
	         * currentKey, and clear all of the queues (additions, moves, removals).
	         * Set the previousIndexes of moved and added items to their currentIndexes
	         * Reset the list of additions, moves and removals
	         *
	         * \@internal
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype._reset = function () {
	            if (this.isDirty) {
	                var /** @type {?} */ record = void 0;
	                var /** @type {?} */ nextRecord = void 0;
	                for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
	                    record._nextPrevious = record._next;
	                }
	                for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	                    record.previousIndex = record.currentIndex;
	                }
	                this._additionsHead = this._additionsTail = null;
	                for (record = this._movesHead; record !== null; record = nextRecord) {
	                    record.previousIndex = record.currentIndex;
	                    nextRecord = record._nextMoved;
	                }
	                this._movesHead = this._movesTail = null;
	                this._removalsHead = this._removalsTail = null;
	                this._identityChangesHead = this._identityChangesTail = null;
	            }
	        };
	        /**
	         * This is the core function which handles differences between collections.
	         *
	         * - `record` is the record which we saw at this position last time. If null then it is a new
	         *   item.
	         * - `item` is the current item in the collection
	         * - `index` is the position of the item in the collection
	         *
	         * \@internal
	         * @param {?} record
	         * @param {?} item
	         * @param {?} itemTrackBy
	         * @param {?} index
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype._mismatch = function (record, item, itemTrackBy, index) {
	            // The previous record after which we will append the current one.
	            var /** @type {?} */ previousRecord;
	            if (record === null) {
	                previousRecord = this._itTail;
	            }
	            else {
	                previousRecord = record._prev;
	                // Remove the record from the collection since we know it does not match the item.
	                this._remove(record);
	            }
	            // Attempt to see if we have seen the item before.
	            record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);
	            if (record !== null) {
	                // We have seen this before, we need to move it forward in the collection.
	                // But first we need to check if identity changed, so we can update in view if necessary
	                if (!looseIdentical(record.item, item))
	                    this._addIdentityChange(record, item);
	                this._moveAfter(record, previousRecord, index);
	            }
	            else {
	                // Never seen it, check evicted list.
	                record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy);
	                if (record !== null) {
	                    // It is an item which we have evicted earlier: reinsert it back into the list.
	                    // But first we need to check if identity changed, so we can update in view if necessary
	                    if (!looseIdentical(record.item, item))
	                        this._addIdentityChange(record, item);
	                    this._reinsertAfter(record, previousRecord, index);
	                }
	                else {
	                    // It is a new item: add it.
	                    record =
	                        this._addAfter(new CollectionChangeRecord(item, itemTrackBy), previousRecord, index);
	                }
	            }
	            return record;
	        };
	        /**
	         * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)
	         *
	         * Use case: `[a, a]` => `[b, a, a]`
	         *
	         * If we did not have this check then the insertion of `b` would:
	         *   1) evict first `a`
	         *   2) insert `b` at `0` index.
	         *   3) leave `a` at index `1` as is. <-- this is wrong!
	         *   3) reinsert `a` at index 2. <-- this is wrong!
	         *
	         * The correct behavior is:
	         *   1) evict first `a`
	         *   2) insert `b` at `0` index.
	         *   3) reinsert `a` at index 1.
	         *   3) move `a` at from `1` to `2`.
	         *
	         *
	         * Double check that we have not evicted a duplicate item. We need to check if the item type may
	         * have already been removed:
	         * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted
	         * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a
	         * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'
	         * at the end.
	         *
	         * \@internal
	         * @param {?} record
	         * @param {?} item
	         * @param {?} itemTrackBy
	         * @param {?} index
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype._verifyReinsertion = function (record, item, itemTrackBy, index) {
	            var /** @type {?} */ reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy);
	            if (reinsertRecord !== null) {
	                record = this._reinsertAfter(reinsertRecord, record._prev, index);
	            }
	            else if (record.currentIndex != index) {
	                record.currentIndex = index;
	                this._addToMoves(record, index);
	            }
	            return record;
	        };
	        /**
	         * Get rid of any excess {\@link CollectionChangeRecord}s from the previous collection
	         *
	         * - `record` The first excess {\@link CollectionChangeRecord}.
	         *
	         * \@internal
	         * @param {?} record
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype._truncate = function (record) {
	            // Anything after that needs to be removed;
	            while (record !== null) {
	                var /** @type {?} */ nextRecord = record._next;
	                this._addToRemovals(this._unlink(record));
	                record = nextRecord;
	            }
	            if (this._unlinkedRecords !== null) {
	                this._unlinkedRecords.clear();
	            }
	            if (this._additionsTail !== null) {
	                this._additionsTail._nextAdded = null;
	            }
	            if (this._movesTail !== null) {
	                this._movesTail._nextMoved = null;
	            }
	            if (this._itTail !== null) {
	                this._itTail._next = null;
	            }
	            if (this._removalsTail !== null) {
	                this._removalsTail._nextRemoved = null;
	            }
	            if (this._identityChangesTail !== null) {
	                this._identityChangesTail._nextIdentityChange = null;
	            }
	        };
	        /**
	         * \@internal
	         * @param {?} record
	         * @param {?} prevRecord
	         * @param {?} index
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype._reinsertAfter = function (record, prevRecord, index) {
	            if (this._unlinkedRecords !== null) {
	                this._unlinkedRecords.remove(record);
	            }
	            var /** @type {?} */ prev = record._prevRemoved;
	            var /** @type {?} */ next = record._nextRemoved;
	            if (prev === null) {
	                this._removalsHead = next;
	            }
	            else {
	                prev._nextRemoved = next;
	            }
	            if (next === null) {
	                this._removalsTail = prev;
	            }
	            else {
	                next._prevRemoved = prev;
	            }
	            this._insertAfter(record, prevRecord, index);
	            this._addToMoves(record, index);
	            return record;
	        };
	        /**
	         * \@internal
	         * @param {?} record
	         * @param {?} prevRecord
	         * @param {?} index
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype._moveAfter = function (record, prevRecord, index) {
	            this._unlink(record);
	            this._insertAfter(record, prevRecord, index);
	            this._addToMoves(record, index);
	            return record;
	        };
	        /**
	         * \@internal
	         * @param {?} record
	         * @param {?} prevRecord
	         * @param {?} index
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype._addAfter = function (record, prevRecord, index) {
	            this._insertAfter(record, prevRecord, index);
	            if (this._additionsTail === null) {
	                // todo(vicb)
	                // assert(this._additionsHead === null);
	                this._additionsTail = this._additionsHead = record;
	            }
	            else {
	                // todo(vicb)
	                // assert(_additionsTail._nextAdded === null);
	                // assert(record._nextAdded === null);
	                this._additionsTail = this._additionsTail._nextAdded = record;
	            }
	            return record;
	        };
	        /**
	         * \@internal
	         * @param {?} record
	         * @param {?} prevRecord
	         * @param {?} index
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype._insertAfter = function (record, prevRecord, index) {
	            // todo(vicb)
	            // assert(record != prevRecord);
	            // assert(record._next === null);
	            // assert(record._prev === null);
	            var /** @type {?} */ next = prevRecord === null ? this._itHead : prevRecord._next;
	            // todo(vicb)
	            // assert(next != record);
	            // assert(prevRecord != record);
	            record._next = next;
	            record._prev = prevRecord;
	            if (next === null) {
	                this._itTail = record;
	            }
	            else {
	                next._prev = record;
	            }
	            if (prevRecord === null) {
	                this._itHead = record;
	            }
	            else {
	                prevRecord._next = record;
	            }
	            if (this._linkedRecords === null) {
	                this._linkedRecords = new _DuplicateMap();
	            }
	            this._linkedRecords.put(record);
	            record.currentIndex = index;
	            return record;
	        };
	        /**
	         * \@internal
	         * @param {?} record
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype._remove = function (record) {
	            return this._addToRemovals(this._unlink(record));
	        };
	        /**
	         * \@internal
	         * @param {?} record
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype._unlink = function (record) {
	            if (this._linkedRecords !== null) {
	                this._linkedRecords.remove(record);
	            }
	            var /** @type {?} */ prev = record._prev;
	            var /** @type {?} */ next = record._next;
	            // todo(vicb)
	            // assert((record._prev = null) === null);
	            // assert((record._next = null) === null);
	            if (prev === null) {
	                this._itHead = next;
	            }
	            else {
	                prev._next = next;
	            }
	            if (next === null) {
	                this._itTail = prev;
	            }
	            else {
	                next._prev = prev;
	            }
	            return record;
	        };
	        /**
	         * \@internal
	         * @param {?} record
	         * @param {?} toIndex
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype._addToMoves = function (record, toIndex) {
	            // todo(vicb)
	            // assert(record._nextMoved === null);
	            if (record.previousIndex === toIndex) {
	                return record;
	            }
	            if (this._movesTail === null) {
	                // todo(vicb)
	                // assert(_movesHead === null);
	                this._movesTail = this._movesHead = record;
	            }
	            else {
	                // todo(vicb)
	                // assert(_movesTail._nextMoved === null);
	                this._movesTail = this._movesTail._nextMoved = record;
	            }
	            return record;
	        };
	        /**
	         * \@internal
	         * @param {?} record
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype._addToRemovals = function (record) {
	            if (this._unlinkedRecords === null) {
	                this._unlinkedRecords = new _DuplicateMap();
	            }
	            this._unlinkedRecords.put(record);
	            record.currentIndex = null;
	            record._nextRemoved = null;
	            if (this._removalsTail === null) {
	                // todo(vicb)
	                // assert(_removalsHead === null);
	                this._removalsTail = this._removalsHead = record;
	                record._prevRemoved = null;
	            }
	            else {
	                // todo(vicb)
	                // assert(_removalsTail._nextRemoved === null);
	                // assert(record._nextRemoved === null);
	                record._prevRemoved = this._removalsTail;
	                this._removalsTail = this._removalsTail._nextRemoved = record;
	            }
	            return record;
	        };
	        /**
	         * \@internal
	         * @param {?} record
	         * @param {?} item
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype._addIdentityChange = function (record, item) {
	            record.item = item;
	            if (this._identityChangesTail === null) {
	                this._identityChangesTail = this._identityChangesHead = record;
	            }
	            else {
	                this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
	            }
	            return record;
	        };
	        /**
	         * @return {?}
	         */
	        DefaultIterableDiffer.prototype.toString = function () {
	            var /** @type {?} */ list = [];
	            this.forEachItem(function (record /** TODO #9100 */) { return list.push(record); });
	            var /** @type {?} */ previous = [];
	            this.forEachPreviousItem(function (record /** TODO #9100 */) { return previous.push(record); });
	            var /** @type {?} */ additions = [];
	            this.forEachAddedItem(function (record /** TODO #9100 */) { return additions.push(record); });
	            var /** @type {?} */ moves = [];
	            this.forEachMovedItem(function (record /** TODO #9100 */) { return moves.push(record); });
	            var /** @type {?} */ removals = [];
	            this.forEachRemovedItem(function (record /** TODO #9100 */) { return removals.push(record); });
	            var /** @type {?} */ identityChanges = [];
	            this.forEachIdentityChange(function (record /** TODO #9100 */) { return identityChanges.push(record); });
	            return 'collection: ' + list.join(', ') + '\n' +
	                'previous: ' + previous.join(', ') + '\n' +
	                'additions: ' + additions.join(', ') + '\n' +
	                'moves: ' + moves.join(', ') + '\n' +
	                'removals: ' + removals.join(', ') + '\n' +
	                'identityChanges: ' + identityChanges.join(', ') + '\n';
	        };
	        return DefaultIterableDiffer;
	    }());
	    /**
	     * \@stable
	     */
	    var CollectionChangeRecord = (function () {
	        /**
	         * @param {?} item
	         * @param {?} trackById
	         */
	        function CollectionChangeRecord(item, trackById) {
	            this.item = item;
	            this.trackById = trackById;
	            this.currentIndex = null;
	            this.previousIndex = null;
	            /** @internal */
	            this._nextPrevious = null;
	            /** @internal */
	            this._prev = null;
	            /** @internal */
	            this._next = null;
	            /** @internal */
	            this._prevDup = null;
	            /** @internal */
	            this._nextDup = null;
	            /** @internal */
	            this._prevRemoved = null;
	            /** @internal */
	            this._nextRemoved = null;
	            /** @internal */
	            this._nextAdded = null;
	            /** @internal */
	            this._nextMoved = null;
	            /** @internal */
	            this._nextIdentityChange = null;
	        }
	        /**
	         * @return {?}
	         */
	        CollectionChangeRecord.prototype.toString = function () {
	            return this.previousIndex === this.currentIndex ? stringify(this.item) :
	                stringify(this.item) + '[' +
	                    stringify(this.previousIndex) + '->' + stringify(this.currentIndex) + ']';
	        };
	        return CollectionChangeRecord;
	    }());
	    var _DuplicateItemRecordList = (function () {
	        function _DuplicateItemRecordList() {
	            /** @internal */
	            this._head = null;
	            /** @internal */
	            this._tail = null;
	        }
	        /**
	         * Append the record to the list of duplicates.
	         *
	         * Note: by design all records in the list of duplicates hold the same value in record.item.
	         * @param {?} record
	         * @return {?}
	         */
	        _DuplicateItemRecordList.prototype.add = function (record) {
	            if (this._head === null) {
	                this._head = this._tail = record;
	                record._nextDup = null;
	                record._prevDup = null;
	            }
	            else {
	                // todo(vicb)
	                // assert(record.item ==  _head.item ||
	                //       record.item is num && record.item.isNaN && _head.item is num && _head.item.isNaN);
	                this._tail._nextDup = record;
	                record._prevDup = this._tail;
	                record._nextDup = null;
	                this._tail = record;
	            }
	        };
	        /**
	         * @param {?} trackById
	         * @param {?} afterIndex
	         * @return {?}
	         */
	        _DuplicateItemRecordList.prototype.get = function (trackById, afterIndex) {
	            var /** @type {?} */ record;
	            for (record = this._head; record !== null; record = record._nextDup) {
	                if ((afterIndex === null || afterIndex < record.currentIndex) &&
	                    looseIdentical(record.trackById, trackById)) {
	                    return record;
	                }
	            }
	            return null;
	        };
	        /**
	         * Remove one {\@link CollectionChangeRecord} from the list of duplicates.
	         *
	         * Returns whether the list of duplicates is empty.
	         * @param {?} record
	         * @return {?}
	         */
	        _DuplicateItemRecordList.prototype.remove = function (record) {
	            // todo(vicb)
	            // assert(() {
	            //  // verify that the record being removed is in the list.
	            //  for (CollectionChangeRecord cursor = _head; cursor != null; cursor = cursor._nextDup) {
	            //    if (identical(cursor, record)) return true;
	            //  }
	            //  return false;
	            //});
	            var /** @type {?} */ prev = record._prevDup;
	            var /** @type {?} */ next = record._nextDup;
	            if (prev === null) {
	                this._head = next;
	            }
	            else {
	                prev._nextDup = next;
	            }
	            if (next === null) {
	                this._tail = prev;
	            }
	            else {
	                next._prevDup = prev;
	            }
	            return this._head === null;
	        };
	        return _DuplicateItemRecordList;
	    }());
	    var _DuplicateMap = (function () {
	        function _DuplicateMap() {
	            this.map = new Map();
	        }
	        /**
	         * @param {?} record
	         * @return {?}
	         */
	        _DuplicateMap.prototype.put = function (record) {
	            var /** @type {?} */ key = record.trackById;
	            var /** @type {?} */ duplicates = this.map.get(key);
	            if (!duplicates) {
	                duplicates = new _DuplicateItemRecordList();
	                this.map.set(key, duplicates);
	            }
	            duplicates.add(record);
	        };
	        /**
	         * Retrieve the `value` using key. Because the CollectionChangeRecord value may be one which we
	         * have already iterated over, we use the afterIndex to pretend it is not there.
	         *
	         * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we
	         * have any more `a`s needs to return the last `a` not the first or second.
	         * @param {?} trackById
	         * @param {?=} afterIndex
	         * @return {?}
	         */
	        _DuplicateMap.prototype.get = function (trackById, afterIndex) {
	            if (afterIndex === void 0) { afterIndex = null; }
	            var /** @type {?} */ key = trackById;
	            var /** @type {?} */ recordList = this.map.get(key);
	            return recordList ? recordList.get(trackById, afterIndex) : null;
	        };
	        /**
	         * Removes a {\@link CollectionChangeRecord} from the list of duplicates.
	         *
	         * The list of duplicates also is removed from the map if it gets empty.
	         * @param {?} record
	         * @return {?}
	         */
	        _DuplicateMap.prototype.remove = function (record) {
	            var /** @type {?} */ key = record.trackById;
	            var /** @type {?} */ recordList = this.map.get(key);
	            // Remove the list of duplicates when it gets empty
	            if (recordList.remove(record)) {
	                this.map.delete(key);
	            }
	            return record;
	        };
	        Object.defineProperty(_DuplicateMap.prototype, "isEmpty", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.map.size === 0; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        _DuplicateMap.prototype.clear = function () { this.map.clear(); };
	        /**
	         * @return {?}
	         */
	        _DuplicateMap.prototype.toString = function () { return '_DuplicateMap(' + stringify(this.map) + ')'; };
	        return _DuplicateMap;
	    }());
	    /**
	     * @param {?} item
	     * @param {?} addRemoveOffset
	     * @param {?} moveOffsets
	     * @return {?}
	     */
	    function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
	        var /** @type {?} */ previousIndex = item.previousIndex;
	        if (previousIndex === null)
	            return previousIndex;
	        var /** @type {?} */ moveOffset = 0;
	        if (moveOffsets && previousIndex < moveOffsets.length) {
	            moveOffset = moveOffsets[previousIndex];
	        }
	        return previousIndex + addRemoveOffset + moveOffset;
	    }

	    var DefaultKeyValueDifferFactory = (function () {
	        function DefaultKeyValueDifferFactory() {
	        }
	        /**
	         * @param {?} obj
	         * @return {?}
	         */
	        DefaultKeyValueDifferFactory.prototype.supports = function (obj) { return obj instanceof Map || isJsObject(obj); };
	        /**
	         * @param {?} cdRef
	         * @return {?}
	         */
	        DefaultKeyValueDifferFactory.prototype.create = function (cdRef) { return new DefaultKeyValueDiffer(); };
	        return DefaultKeyValueDifferFactory;
	    }());
	    var DefaultKeyValueDiffer = (function () {
	        function DefaultKeyValueDiffer() {
	            this._records = new Map();
	            this._mapHead = null;
	            this._previousMapHead = null;
	            this._changesHead = null;
	            this._changesTail = null;
	            this._additionsHead = null;
	            this._additionsTail = null;
	            this._removalsHead = null;
	            this._removalsTail = null;
	        }
	        Object.defineProperty(DefaultKeyValueDiffer.prototype, "isDirty", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return this._additionsHead !== null || this._changesHead !== null ||
	                    this._removalsHead !== null;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype.forEachItem = function (fn) {
	            var /** @type {?} */ record;
	            for (record = this._mapHead; record !== null; record = record._next) {
	                fn(record);
	            }
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype.forEachPreviousItem = function (fn) {
	            var /** @type {?} */ record;
	            for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
	                fn(record);
	            }
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype.forEachChangedItem = function (fn) {
	            var /** @type {?} */ record;
	            for (record = this._changesHead; record !== null; record = record._nextChanged) {
	                fn(record);
	            }
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype.forEachAddedItem = function (fn) {
	            var /** @type {?} */ record;
	            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	                fn(record);
	            }
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype.forEachRemovedItem = function (fn) {
	            var /** @type {?} */ record;
	            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
	                fn(record);
	            }
	        };
	        /**
	         * @param {?} map
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype.diff = function (map) {
	            if (!map) {
	                map = new Map();
	            }
	            else if (!(map instanceof Map || isJsObject(map))) {
	                throw new Error("Error trying to diff '" + map + "'");
	            }
	            return this.check(map) ? this : null;
	        };
	        /**
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype.onDestroy = function () { };
	        /**
	         * @param {?} map
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype.check = function (map) {
	            var _this = this;
	            this._reset();
	            var /** @type {?} */ records = this._records;
	            var /** @type {?} */ oldSeqRecord = this._mapHead;
	            var /** @type {?} */ lastOldSeqRecord = null;
	            var /** @type {?} */ lastNewSeqRecord = null;
	            var /** @type {?} */ seqChanged = false;
	            this._forEach(map, function (value, key) {
	                var /** @type {?} */ newSeqRecord;
	                if (oldSeqRecord && key === oldSeqRecord.key) {
	                    newSeqRecord = oldSeqRecord;
	                    _this._maybeAddToChanges(newSeqRecord, value);
	                }
	                else {
	                    seqChanged = true;
	                    if (oldSeqRecord !== null) {
	                        _this._removeFromSeq(lastOldSeqRecord, oldSeqRecord);
	                        _this._addToRemovals(oldSeqRecord);
	                    }
	                    if (records.has(key)) {
	                        newSeqRecord = records.get(key);
	                        _this._maybeAddToChanges(newSeqRecord, value);
	                    }
	                    else {
	                        newSeqRecord = new KeyValueChangeRecord(key);
	                        records.set(key, newSeqRecord);
	                        newSeqRecord.currentValue = value;
	                        _this._addToAdditions(newSeqRecord);
	                    }
	                }
	                if (seqChanged) {
	                    if (_this._isInRemovals(newSeqRecord)) {
	                        _this._removeFromRemovals(newSeqRecord);
	                    }
	                    if (lastNewSeqRecord == null) {
	                        _this._mapHead = newSeqRecord;
	                    }
	                    else {
	                        lastNewSeqRecord._next = newSeqRecord;
	                    }
	                }
	                lastOldSeqRecord = oldSeqRecord;
	                lastNewSeqRecord = newSeqRecord;
	                oldSeqRecord = oldSeqRecord && oldSeqRecord._next;
	            });
	            this._truncate(lastOldSeqRecord, oldSeqRecord);
	            return this.isDirty;
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype._reset = function () {
	            if (this.isDirty) {
	                var /** @type {?} */ record = void 0;
	                // Record the state of the mapping
	                for (record = this._previousMapHead = this._mapHead; record !== null; record = record._next) {
	                    record._nextPrevious = record._next;
	                }
	                for (record = this._changesHead; record !== null; record = record._nextChanged) {
	                    record.previousValue = record.currentValue;
	                }
	                for (record = this._additionsHead; record != null; record = record._nextAdded) {
	                    record.previousValue = record.currentValue;
	                }
	                this._changesHead = this._changesTail = null;
	                this._additionsHead = this._additionsTail = null;
	                this._removalsHead = this._removalsTail = null;
	            }
	        };
	        /**
	         * \@internal
	         * @param {?} lastRecord
	         * @param {?} record
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype._truncate = function (lastRecord, record) {
	            while (record !== null) {
	                if (lastRecord === null) {
	                    this._mapHead = null;
	                }
	                else {
	                    lastRecord._next = null;
	                }
	                var /** @type {?} */ nextRecord = record._next;
	                this._addToRemovals(record);
	                lastRecord = record;
	                record = nextRecord;
	            }
	            for (var /** @type {?} */ rec = this._removalsHead; rec !== null; rec = rec._nextRemoved) {
	                rec.previousValue = rec.currentValue;
	                rec.currentValue = null;
	                this._records.delete(rec.key);
	            }
	        };
	        /**
	         * @param {?} record
	         * @param {?} newValue
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype._maybeAddToChanges = function (record, newValue) {
	            if (!looseIdentical(newValue, record.currentValue)) {
	                record.previousValue = record.currentValue;
	                record.currentValue = newValue;
	                this._addToChanges(record);
	            }
	        };
	        /**
	         * \@internal
	         * @param {?} record
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype._isInRemovals = function (record) {
	            return record === this._removalsHead || record._nextRemoved !== null ||
	                record._prevRemoved !== null;
	        };
	        /**
	         * \@internal
	         * @param {?} record
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype._addToRemovals = function (record) {
	            if (this._removalsHead === null) {
	                this._removalsHead = this._removalsTail = record;
	            }
	            else {
	                this._removalsTail._nextRemoved = record;
	                record._prevRemoved = this._removalsTail;
	                this._removalsTail = record;
	            }
	        };
	        /**
	         * \@internal
	         * @param {?} prev
	         * @param {?} record
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype._removeFromSeq = function (prev, record) {
	            var /** @type {?} */ next = record._next;
	            if (prev === null) {
	                this._mapHead = next;
	            }
	            else {
	                prev._next = next;
	            }
	            record._next = null;
	        };
	        /**
	         * \@internal
	         * @param {?} record
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype._removeFromRemovals = function (record) {
	            var /** @type {?} */ prev = record._prevRemoved;
	            var /** @type {?} */ next = record._nextRemoved;
	            if (prev === null) {
	                this._removalsHead = next;
	            }
	            else {
	                prev._nextRemoved = next;
	            }
	            if (next === null) {
	                this._removalsTail = prev;
	            }
	            else {
	                next._prevRemoved = prev;
	            }
	            record._prevRemoved = record._nextRemoved = null;
	        };
	        /**
	         * \@internal
	         * @param {?} record
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype._addToAdditions = function (record) {
	            if (this._additionsHead === null) {
	                this._additionsHead = this._additionsTail = record;
	            }
	            else {
	                this._additionsTail._nextAdded = record;
	                this._additionsTail = record;
	            }
	        };
	        /**
	         * \@internal
	         * @param {?} record
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype._addToChanges = function (record) {
	            if (this._changesHead === null) {
	                this._changesHead = this._changesTail = record;
	            }
	            else {
	                this._changesTail._nextChanged = record;
	                this._changesTail = record;
	            }
	        };
	        /**
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype.toString = function () {
	            var /** @type {?} */ items = [];
	            var /** @type {?} */ previous = [];
	            var /** @type {?} */ changes = [];
	            var /** @type {?} */ additions = [];
	            var /** @type {?} */ removals = [];
	            var /** @type {?} */ record;
	            for (record = this._mapHead; record !== null; record = record._next) {
	                items.push(stringify(record));
	            }
	            for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
	                previous.push(stringify(record));
	            }
	            for (record = this._changesHead; record !== null; record = record._nextChanged) {
	                changes.push(stringify(record));
	            }
	            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	                additions.push(stringify(record));
	            }
	            for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
	                removals.push(stringify(record));
	            }
	            return 'map: ' + items.join(', ') + '\n' +
	                'previous: ' + previous.join(', ') + '\n' +
	                'additions: ' + additions.join(', ') + '\n' +
	                'changes: ' + changes.join(', ') + '\n' +
	                'removals: ' + removals.join(', ') + '\n';
	        };
	        /**
	         * \@internal
	         * @param {?} obj
	         * @param {?} fn
	         * @return {?}
	         */
	        DefaultKeyValueDiffer.prototype._forEach = function (obj, fn) {
	            if (obj instanceof Map) {
	                obj.forEach(fn);
	            }
	            else {
	                Object.keys(obj).forEach(function (k) { return fn(obj[k], k); });
	            }
	        };
	        return DefaultKeyValueDiffer;
	    }());
	    /**
	     * \@stable
	     */
	    var KeyValueChangeRecord = (function () {
	        /**
	         * @param {?} key
	         */
	        function KeyValueChangeRecord(key) {
	            this.key = key;
	            this.previousValue = null;
	            this.currentValue = null;
	            /** @internal */
	            this._nextPrevious = null;
	            /** @internal */
	            this._next = null;
	            /** @internal */
	            this._nextAdded = null;
	            /** @internal */
	            this._nextRemoved = null;
	            /** @internal */
	            this._prevRemoved = null;
	            /** @internal */
	            this._nextChanged = null;
	        }
	        /**
	         * @return {?}
	         */
	        KeyValueChangeRecord.prototype.toString = function () {
	            return looseIdentical(this.previousValue, this.currentValue) ?
	                stringify(this.key) :
	                (stringify(this.key) + '[' + stringify(this.previousValue) + '->' +
	                    stringify(this.currentValue) + ']');
	        };
	        return KeyValueChangeRecord;
	    }());

	    /**
	     * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.
	     * \@stable
	     */
	    var IterableDiffers = (function () {
	        /**
	         * @param {?} factories
	         */
	        function IterableDiffers(factories) {
	            this.factories = factories;
	        }
	        /**
	         * @param {?} factories
	         * @param {?=} parent
	         * @return {?}
	         */
	        IterableDiffers.create = function (factories, parent) {
	            if (isPresent(parent)) {
	                var /** @type {?} */ copied = parent.factories.slice();
	                factories = factories.concat(copied);
	                return new IterableDiffers(factories);
	            }
	            else {
	                return new IterableDiffers(factories);
	            }
	        };
	        /**
	         * Takes an array of {\@link IterableDifferFactory} and returns a provider used to extend the
	         * inherited {\@link IterableDiffers} instance with the provided factories and return a new
	         * {\@link IterableDiffers} instance.
	         *
	         * The following example shows how to extend an existing list of factories,
	         * which will only be applied to the injector for this component and its children.
	         * This step is all that's required to make a new {\@link IterableDiffer} available.
	         *
	         * ### Example
	         *
	         * ```
	         * \@Component({
	         *   viewProviders: [
	         *     IterableDiffers.extend([new ImmutableListDiffer()])
	         *   ]
	         * })
	         * ```
	         * @param {?} factories
	         * @return {?}
	         */
	        IterableDiffers.extend = function (factories) {
	            return {
	                provide: IterableDiffers,
	                useFactory: function (parent) {
	                    if (!parent) {
	                        // Typically would occur when calling IterableDiffers.extend inside of dependencies passed
	                        // to
	                        // bootstrap(), which would override default pipes instead of extending them.
	                        throw new Error('Cannot extend IterableDiffers without a parent injector');
	                    }
	                    return IterableDiffers.create(factories, parent);
	                },
	                // Dependency technically isn't optional, but we can provide a better error message this way.
	                deps: [[IterableDiffers, new SkipSelf(), new Optional()]]
	            };
	        };
	        /**
	         * @param {?} iterable
	         * @return {?}
	         */
	        IterableDiffers.prototype.find = function (iterable) {
	            var /** @type {?} */ factory = this.factories.find(function (f) { return f.supports(iterable); });
	            if (isPresent(factory)) {
	                return factory;
	            }
	            else {
	                throw new Error("Cannot find a differ supporting object '" + iterable + "' of type '" + getTypeNameForDebugging(iterable) + "'");
	            }
	        };
	        return IterableDiffers;
	    }());

	    /**
	     * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.
	     * \@stable
	     */
	    var KeyValueDiffers = (function () {
	        /**
	         * @param {?} factories
	         */
	        function KeyValueDiffers(factories) {
	            this.factories = factories;
	        }
	        /**
	         * @param {?} factories
	         * @param {?=} parent
	         * @return {?}
	         */
	        KeyValueDiffers.create = function (factories, parent) {
	            if (isPresent(parent)) {
	                var /** @type {?} */ copied = parent.factories.slice();
	                factories = factories.concat(copied);
	                return new KeyValueDiffers(factories);
	            }
	            else {
	                return new KeyValueDiffers(factories);
	            }
	        };
	        /**
	         * Takes an array of {\@link KeyValueDifferFactory} and returns a provider used to extend the
	         * inherited {\@link KeyValueDiffers} instance with the provided factories and return a new
	         * {\@link KeyValueDiffers} instance.
	         *
	         * The following example shows how to extend an existing list of factories,
	         * which will only be applied to the injector for this component and its children.
	         * This step is all that's required to make a new {\@link KeyValueDiffer} available.
	         *
	         * ### Example
	         *
	         * ```
	         * \@Component({
	         *   viewProviders: [
	         *     KeyValueDiffers.extend([new ImmutableMapDiffer()])
	         *   ]
	         * })
	         * ```
	         * @param {?} factories
	         * @return {?}
	         */
	        KeyValueDiffers.extend = function (factories) {
	            return {
	                provide: KeyValueDiffers,
	                useFactory: function (parent) {
	                    if (!parent) {
	                        // Typically would occur when calling KeyValueDiffers.extend inside of dependencies passed
	                        // to
	                        // bootstrap(), which would override default pipes instead of extending them.
	                        throw new Error('Cannot extend KeyValueDiffers without a parent injector');
	                    }
	                    return KeyValueDiffers.create(factories, parent);
	                },
	                // Dependency technically isn't optional, but we can provide a better error message this way.
	                deps: [[KeyValueDiffers, new SkipSelf(), new Optional()]]
	            };
	        };
	        /**
	         * @param {?} kv
	         * @return {?}
	         */
	        KeyValueDiffers.prototype.find = function (kv) {
	            var /** @type {?} */ factory = this.factories.find(function (f) { return f.supports(kv); });
	            if (isPresent(factory)) {
	                return factory;
	            }
	            else {
	                throw new Error("Cannot find a differ supporting object '" + kv + "'");
	            }
	        };
	        return KeyValueDiffers;
	    }());

	    var /** @type {?} */ UNINITIALIZED = {
	        toString: function () { return 'CD_INIT_VALUE'; }
	    };
	    /**
	     * @param {?} a
	     * @param {?} b
	     * @return {?}
	     */
	    function devModeEqual(a, b) {
	        if (isListLikeIterable(a) && isListLikeIterable(b)) {
	            return areIterablesEqual(a, b, devModeEqual);
	        }
	        else if (!isListLikeIterable(a) && !isPrimitive(a) && !isListLikeIterable(b) && !isPrimitive(b)) {
	            return true;
	        }
	        else {
	            return looseIdentical(a, b);
	        }
	    }
	    /**
	     * Indicates that the result of a {\@link Pipe} transformation has changed even though the
	     * reference
	     * has not changed.
	     *
	     * The wrapped value will be unwrapped by change detection, and the unwrapped value will be stored.
	     *
	     * Example:
	     *
	     * ```
	     * if (this._latestValue === this._latestReturnedValue) {
	     *    return this._latestReturnedValue;
	     *  } else {
	     *    this._latestReturnedValue = this._latestValue;
	     *    return WrappedValue.wrap(this._latestValue); // this will force update
	     *  }
	     * ```
	     * \@stable
	     */
	    var WrappedValue = (function () {
	        /**
	         * @param {?} wrapped
	         */
	        function WrappedValue(wrapped) {
	            this.wrapped = wrapped;
	        }
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        WrappedValue.wrap = function (value) { return new WrappedValue(value); };
	        return WrappedValue;
	    }());
	    /**
	     * Helper class for unwrapping WrappedValue s
	     */
	    var ValueUnwrapper = (function () {
	        function ValueUnwrapper() {
	            this.hasWrappedValue = false;
	        }
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        ValueUnwrapper.prototype.unwrap = function (value) {
	            if (value instanceof WrappedValue) {
	                this.hasWrappedValue = true;
	                return value.wrapped;
	            }
	            return value;
	        };
	        /**
	         * @return {?}
	         */
	        ValueUnwrapper.prototype.reset = function () { this.hasWrappedValue = false; };
	        return ValueUnwrapper;
	    }());
	    /**
	     * Represents a basic change from a previous to a new value.
	     * \@stable
	     */
	    var SimpleChange = (function () {
	        /**
	         * @param {?} previousValue
	         * @param {?} currentValue
	         */
	        function SimpleChange(previousValue, currentValue) {
	            this.previousValue = previousValue;
	            this.currentValue = currentValue;
	        }
	        /**
	         * Check whether the new value is the first value assigned.
	         * @return {?}
	         */
	        SimpleChange.prototype.isFirstChange = function () { return this.previousValue === UNINITIALIZED; };
	        return SimpleChange;
	    }());

	    /**
	     * \@stable
	     * @abstract
	     */
	    var ChangeDetectorRef = (function () {
	        function ChangeDetectorRef() {
	        }
	        /**
	         * Marks all {\@link ChangeDetectionStrategy#OnPush} ancestors as to be checked.
	         *
	         * <!-- TODO: Add a link to a chapter on OnPush components -->
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/GC512b?p=preview))
	         *
	         * ```typescript
	         * \@Component({
	         *   selector: 'cmp',
	         *   changeDetection: ChangeDetectionStrategy.OnPush,
	         *   template: `Number of ticks: {{numberOfTicks}}`
	         * })
	         * class Cmp {
	         *   numberOfTicks = 0;
	         *
	         *   constructor(ref: ChangeDetectorRef) {
	         *     setInterval(() => {
	         *       this.numberOfTicks ++
	         *       // the following is required, otherwise the view will not be updated
	         *       this.ref.markForCheck();
	         *     }, 1000);
	         *   }
	         * }
	         *
	         * \@Component({
	         *   selector: 'app',
	         *   changeDetection: ChangeDetectionStrategy.OnPush,
	         *   template: `
	         *     <cmp><cmp>
	         *   `,
	         * })
	         * class App {
	         * }
	         * ```
	         * @abstract
	         * @return {?}
	         */
	        ChangeDetectorRef.prototype.markForCheck = function () { };
	        /**
	         * Detaches the change detector from the change detector tree.
	         *
	         * The detached change detector will not be checked until it is reattached.
	         *
	         * This can also be used in combination with {\@link ChangeDetectorRef#detectChanges} to implement
	         * local change
	         * detection checks.
	         *
	         * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
	         * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
	         *
	         * ### Example
	         *
	         * The following example defines a component with a large list of readonly data.
	         * Imagine the data changes constantly, many times per second. For performance reasons,
	         * we want to check and update the list every five seconds. We can do that by detaching
	         * the component's change detector and doing a local check every five seconds.
	         *
	         * ```typescript
	         * class DataProvider {
	         *   // in a real application the returned data will be different every time
	         *   get data() {
	         *     return [1,2,3,4,5];
	         *   }
	         * }
	         *
	         * \@Component({
	         *   selector: 'giant-list',
	         *   template: `
	         *     <li *ngFor="let d of dataProvider.data">Data {{d}}</lig>
	         *   `,
	         * })
	         * class GiantList {
	         *   constructor(private ref: ChangeDetectorRef, private dataProvider:DataProvider) {
	         *     ref.detach();
	         *     setInterval(() => {
	         *       this.ref.detectChanges();
	         *     }, 5000);
	         *   }
	         * }
	         *
	         * \@Component({
	         *   selector: 'app',
	         *   providers: [DataProvider],
	         *   template: `
	         *     <giant-list><giant-list>
	         *   `,
	         * })
	         * class App {
	         * }
	         * ```
	         * @abstract
	         * @return {?}
	         */
	        ChangeDetectorRef.prototype.detach = function () { };
	        /**
	         * Checks the change detector and its children.
	         *
	         * This can also be used in combination with {\@link ChangeDetectorRef#detach} to implement local
	         * change detection
	         * checks.
	         *
	         * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
	         * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
	         *
	         * ### Example
	         *
	         * The following example defines a component with a large list of readonly data.
	         * Imagine, the data changes constantly, many times per second. For performance reasons,
	         * we want to check and update the list every five seconds.
	         *
	         * We can do that by detaching the component's change detector and doing a local change detection
	         * check
	         * every five seconds.
	         *
	         * See {\@link ChangeDetectorRef#detach} for more information.
	         * @abstract
	         * @return {?}
	         */
	        ChangeDetectorRef.prototype.detectChanges = function () { };
	        /**
	         * Checks the change detector and its children, and throws if any changes are detected.
	         *
	         * This is used in development mode to verify that running change detection doesn't introduce
	         * other changes.
	         * @abstract
	         * @return {?}
	         */
	        ChangeDetectorRef.prototype.checkNoChanges = function () { };
	        /**
	         * Reattach the change detector to the change detector tree.
	         *
	         * This also marks OnPush ancestors as to be checked. This reattached change detector will be
	         * checked during the next change detection run.
	         *
	         * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
	         *
	         * ### Example ([live demo](http://plnkr.co/edit/aUhZha?p=preview))
	         *
	         * The following example creates a component displaying `live` data. The component will detach
	         * its change detector from the main change detector tree when the component's live property
	         * is set to false.
	         *
	         * ```typescript
	         * class DataProvider {
	         *   data = 1;
	         *
	         *   constructor() {
	         *     setInterval(() => {
	         *       this.data = this.data * 2;
	         *     }, 500);
	         *   }
	         * }
	         *
	         * \@Component({
	         *   selector: 'live-data',
	         *   inputs: ['live'],
	         *   template: 'Data: {{dataProvider.data}}'
	         * })
	         * class LiveData {
	         *   constructor(private ref: ChangeDetectorRef, private dataProvider:DataProvider) {}
	         *
	         *   set live(value) {
	         *     if (value)
	         *       this.ref.reattach();
	         *     else
	         *       this.ref.detach();
	         *   }
	         * }
	         *
	         * \@Component({
	         *   selector: 'app',
	         *   providers: [DataProvider],
	         *   template: `
	         *     Live Update: <input type="checkbox" [(ngModel)]="live">
	         *     <live-data [live]="live"><live-data>
	         *   `,
	         * })
	         * class App {
	         *   live = true;
	         * }
	         * ```
	         * @abstract
	         * @return {?}
	         */
	        ChangeDetectorRef.prototype.reattach = function () { };
	        return ChangeDetectorRef;
	    }());

	    /**
	     * Structural diffing for `Object`s and `Map`s.
	     */
	    var /** @type {?} */ keyValDiff = [new DefaultKeyValueDifferFactory()];
	    /**
	     * Structural diffing for `Iterable` types such as `Array`s.
	     */
	    var /** @type {?} */ iterableDiff = [new DefaultIterableDifferFactory()];
	    var /** @type {?} */ defaultIterableDiffers = new IterableDiffers(iterableDiff);
	    var /** @type {?} */ defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);

	    var RenderComponentType = (function () {
	        /**
	         * @param {?} id
	         * @param {?} templateUrl
	         * @param {?} slotCount
	         * @param {?} encapsulation
	         * @param {?} styles
	         * @param {?} animations
	         */
	        function RenderComponentType(id, templateUrl, slotCount, encapsulation, styles, animations) {
	            this.id = id;
	            this.templateUrl = templateUrl;
	            this.slotCount = slotCount;
	            this.encapsulation = encapsulation;
	            this.styles = styles;
	            this.animations = animations;
	        }
	        return RenderComponentType;
	    }());
	    /**
	     * @abstract
	     */
	    var RenderDebugInfo = (function () {
	        function RenderDebugInfo() {
	        }
	        Object.defineProperty(RenderDebugInfo.prototype, "injector", {
	            /**
	             * @return {?}
	             */
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(RenderDebugInfo.prototype, "component", {
	            /**
	             * @return {?}
	             */
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(RenderDebugInfo.prototype, "providerTokens", {
	            /**
	             * @return {?}
	             */
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(RenderDebugInfo.prototype, "references", {
	            /**
	             * @return {?}
	             */
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(RenderDebugInfo.prototype, "context", {
	            /**
	             * @return {?}
	             */
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(RenderDebugInfo.prototype, "source", {
	            /**
	             * @return {?}
	             */
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        return RenderDebugInfo;
	    }());
	    /**
	     * \@experimental
	     * @abstract
	     */
	    var Renderer = (function () {
	        function Renderer() {
	        }
	        /**
	         * @abstract
	         * @param {?} selectorOrNode
	         * @param {?=} debugInfo
	         * @return {?}
	         */
	        Renderer.prototype.selectRootElement = function (selectorOrNode, debugInfo) { };
	        /**
	         * @abstract
	         * @param {?} parentElement
	         * @param {?} name
	         * @param {?=} debugInfo
	         * @return {?}
	         */
	        Renderer.prototype.createElement = function (parentElement, name, debugInfo) { };
	        /**
	         * @abstract
	         * @param {?} hostElement
	         * @return {?}
	         */
	        Renderer.prototype.createViewRoot = function (hostElement) { };
	        /**
	         * @abstract
	         * @param {?} parentElement
	         * @param {?=} debugInfo
	         * @return {?}
	         */
	        Renderer.prototype.createTemplateAnchor = function (parentElement, debugInfo) { };
	        /**
	         * @abstract
	         * @param {?} parentElement
	         * @param {?} value
	         * @param {?=} debugInfo
	         * @return {?}
	         */
	        Renderer.prototype.createText = function (parentElement, value, debugInfo) { };
	        /**
	         * @abstract
	         * @param {?} parentElement
	         * @param {?} nodes
	         * @return {?}
	         */
	        Renderer.prototype.projectNodes = function (parentElement, nodes) { };
	        /**
	         * @abstract
	         * @param {?} node
	         * @param {?} viewRootNodes
	         * @return {?}
	         */
	        Renderer.prototype.attachViewAfter = function (node, viewRootNodes) { };
	        /**
	         * @abstract
	         * @param {?} viewRootNodes
	         * @return {?}
	         */
	        Renderer.prototype.detachView = function (viewRootNodes) { };
	        /**
	         * @abstract
	         * @param {?} hostElement
	         * @param {?} viewAllNodes
	         * @return {?}
	         */
	        Renderer.prototype.destroyView = function (hostElement, viewAllNodes) { };
	        /**
	         * @abstract
	         * @param {?} renderElement
	         * @param {?} name
	         * @param {?} callback
	         * @return {?}
	         */
	        Renderer.prototype.listen = function (renderElement, name, callback) { };
	        /**
	         * @abstract
	         * @param {?} target
	         * @param {?} name
	         * @param {?} callback
	         * @return {?}
	         */
	        Renderer.prototype.listenGlobal = function (target, name, callback) { };
	        /**
	         * @abstract
	         * @param {?} renderElement
	         * @param {?} propertyName
	         * @param {?} propertyValue
	         * @return {?}
	         */
	        Renderer.prototype.setElementProperty = function (renderElement, propertyName, propertyValue) { };
	        /**
	         * @abstract
	         * @param {?} renderElement
	         * @param {?} attributeName
	         * @param {?} attributeValue
	         * @return {?}
	         */
	        Renderer.prototype.setElementAttribute = function (renderElement, attributeName, attributeValue) { };
	        /**
	         * Used only in debug mode to serialize property changes to dom nodes as attributes.
	         * @abstract
	         * @param {?} renderElement
	         * @param {?} propertyName
	         * @param {?} propertyValue
	         * @return {?}
	         */
	        Renderer.prototype.setBindingDebugInfo = function (renderElement, propertyName, propertyValue) { };
	        /**
	         * @abstract
	         * @param {?} renderElement
	         * @param {?} className
	         * @param {?} isAdd
	         * @return {?}
	         */
	        Renderer.prototype.setElementClass = function (renderElement, className, isAdd) { };
	        /**
	         * @abstract
	         * @param {?} renderElement
	         * @param {?} styleName
	         * @param {?} styleValue
	         * @return {?}
	         */
	        Renderer.prototype.setElementStyle = function (renderElement, styleName, styleValue) { };
	        /**
	         * @abstract
	         * @param {?} renderElement
	         * @param {?} methodName
	         * @param {?=} args
	         * @return {?}
	         */
	        Renderer.prototype.invokeElementMethod = function (renderElement, methodName, args) { };
	        /**
	         * @abstract
	         * @param {?} renderNode
	         * @param {?} text
	         * @return {?}
	         */
	        Renderer.prototype.setText = function (renderNode, text) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} startingStyles
	         * @param {?} keyframes
	         * @param {?} duration
	         * @param {?} delay
	         * @param {?} easing
	         * @param {?=} previousPlayers
	         * @return {?}
	         */
	        Renderer.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing, previousPlayers) { };
	        return Renderer;
	    }());
	    /**
	     * Injectable service that provides a low-level interface for modifying the UI.
	     *
	     * Use this service to bypass Angular's templating and make custom UI changes that can't be
	     * expressed declaratively. For example if you need to set a property or an attribute whose name is
	     * not statically known, use {\@link #setElementProperty} or {\@link #setElementAttribute}
	     * respectively.
	     *
	     * If you are implementing a custom renderer, you must implement this interface.
	     *
	     * The default Renderer implementation is `DomRenderer`. Also available is `WebWorkerRenderer`.
	     * \@experimental
	     * @abstract
	     */
	    var RootRenderer = (function () {
	        function RootRenderer() {
	        }
	        /**
	         * @abstract
	         * @param {?} componentType
	         * @return {?}
	         */
	        RootRenderer.prototype.renderComponent = function (componentType) { };
	        return RootRenderer;
	    }());

	    var SecurityContext = {};
	    SecurityContext.NONE = 0;
	    SecurityContext.HTML = 1;
	    SecurityContext.STYLE = 2;
	    SecurityContext.SCRIPT = 3;
	    SecurityContext.URL = 4;
	    SecurityContext.RESOURCE_URL = 5;
	    SecurityContext[SecurityContext.NONE] = "NONE";
	    SecurityContext[SecurityContext.HTML] = "HTML";
	    SecurityContext[SecurityContext.STYLE] = "STYLE";
	    SecurityContext[SecurityContext.SCRIPT] = "SCRIPT";
	    SecurityContext[SecurityContext.URL] = "URL";
	    SecurityContext[SecurityContext.RESOURCE_URL] = "RESOURCE_URL";
	    /**
	     * Sanitizer is used by the views to sanitize potentially dangerous values.
	     *
	     * \@stable
	     * @abstract
	     */
	    var Sanitizer = (function () {
	        function Sanitizer() {
	        }
	        /**
	         * @abstract
	         * @param {?} context
	         * @param {?} value
	         * @return {?}
	         */
	        Sanitizer.prototype.sanitize = function (context, value) { };
	        return Sanitizer;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$7 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * An error thrown if application changes model breaking the top-down data flow.
	     *
	     * This exception is only thrown in dev mode.
	     *
	     * <!-- TODO: Add a link once the dev mode option is configurable -->
	     *
	     * ### Example
	     *
	     * ```typescript
	     * \@Component({
	     *   selector: 'parent',
	     *   template: '<child [prop]="parentProp"></child>',
	     * })
	     * class Parent {
	     *   parentProp = 'init';
	     * }
	     *
	     * \@Directive({selector: 'child', inputs: ['prop']})
	     * class Child {
	     *   constructor(public parent: Parent) {}
	     *
	     *   set prop(v) {
	     *     // this updates the parent property, which is disallowed during change detection
	     *     // this will result in ExpressionChangedAfterItHasBeenCheckedError
	     *     this.parent.parentProp = 'updated';
	     *   }
	     * }
	     * ```
	     * \@stable
	     */
	    var ExpressionChangedAfterItHasBeenCheckedError = (function (_super) {
	        __extends$7(ExpressionChangedAfterItHasBeenCheckedError, _super);
	        /**
	         * @param {?} oldValue
	         * @param {?} currValue
	         */
	        function ExpressionChangedAfterItHasBeenCheckedError(oldValue, currValue) {
	            var msg = "Expression has changed after it was checked. Previous value: '" + oldValue + "'. Current value: '" + currValue + "'.";
	            if (oldValue === UNINITIALIZED) {
	                msg +=
	                    " It seems like the view has been created after its parent and its children have been dirty checked." +
	                        " Has it been created in a change detection hook ?";
	            }
	            _super.call(this, msg);
	        }
	        return ExpressionChangedAfterItHasBeenCheckedError;
	    }(BaseError));
	    /**
	     * Thrown when an exception was raised during view creation, change detection or destruction.
	     *
	     * This error wraps the original exception to attach additional contextual information that can
	     * be useful for debugging.
	     * \@stable
	     */
	    var ViewWrappedError = (function (_super) {
	        __extends$7(ViewWrappedError, _super);
	        /**
	         * @param {?} originalError
	         * @param {?} context
	         */
	        function ViewWrappedError(originalError, context) {
	            _super.call(this, "Error in " + context.source, originalError);
	            this.context = context;
	        }
	        return ViewWrappedError;
	    }(WrappedError));
	    /**
	     * Thrown when a destroyed view is used.
	     *
	     * This error indicates a bug in the framework.
	     *
	     * This is an internal Angular error.
	     * \@stable
	     */
	    var ViewDestroyedError = (function (_super) {
	        __extends$7(ViewDestroyedError, _super);
	        /**
	         * @param {?} details
	         */
	        function ViewDestroyedError(details) {
	            _super.call(this, "Attempt to use a destroyed view: " + details);
	        }
	        return ViewDestroyedError;
	    }(BaseError));

	    var ViewUtils = (function () {
	        /**
	         * @param {?} _renderer
	         * @param {?} sanitizer
	         * @param {?} animationQueue
	         */
	        function ViewUtils(_renderer, sanitizer, animationQueue) {
	            this._renderer = _renderer;
	            this.animationQueue = animationQueue;
	            this.sanitizer = sanitizer;
	        }
	        /**
	         * \@internal
	         * @param {?} renderComponentType
	         * @return {?}
	         */
	        ViewUtils.prototype.renderComponent = function (renderComponentType) {
	            return this._renderer.renderComponent(renderComponentType);
	        };
	        ViewUtils.decorators = [
	            { type: Injectable },
	        ];
	        /** @nocollapse */
	        ViewUtils.ctorParameters = function () { return [
	            { type: RootRenderer, },
	            { type: Sanitizer, },
	            { type: AnimationQueue, },
	        ]; };
	        return ViewUtils;
	    }());
	    var /** @type {?} */ nextRenderComponentTypeId = 0;
	    /**
	     * @param {?} templateUrl
	     * @param {?} slotCount
	     * @param {?} encapsulation
	     * @param {?} styles
	     * @param {?} animations
	     * @return {?}
	     */
	    function createRenderComponentType(templateUrl, slotCount, encapsulation, styles, animations) {
	        return new RenderComponentType("" + nextRenderComponentTypeId++, templateUrl, slotCount, encapsulation, styles, animations);
	    }
	    /**
	     * @param {?} e
	     * @param {?} array
	     * @return {?}
	     */
	    function addToArray(e, array) {
	        array.push(e);
	    }
	    /**
	     * @param {?} valueCount
	     * @param {?} constAndInterp
	     * @return {?}
	     */
	    function interpolate(valueCount, constAndInterp) {
	        var /** @type {?} */ result = '';
	        for (var /** @type {?} */ i = 0; i < valueCount * 2; i = i + 2) {
	            result = result + constAndInterp[i] + _toStringWithNull(constAndInterp[i + 1]);
	        }
	        return result + constAndInterp[valueCount * 2];
	    }
	    /**
	     * @param {?} valueCount
	     * @param {?} c0
	     * @param {?} a1
	     * @param {?} c1
	     * @param {?=} a2
	     * @param {?=} c2
	     * @param {?=} a3
	     * @param {?=} c3
	     * @param {?=} a4
	     * @param {?=} c4
	     * @param {?=} a5
	     * @param {?=} c5
	     * @param {?=} a6
	     * @param {?=} c6
	     * @param {?=} a7
	     * @param {?=} c7
	     * @param {?=} a8
	     * @param {?=} c8
	     * @param {?=} a9
	     * @param {?=} c9
	     * @return {?}
	     */
	    function inlineInterpolate(valueCount, c0, a1, c1, a2, c2, a3, c3, a4, c4, a5, c5, a6, c6, a7, c7, a8, c8, a9, c9) {
	        switch (valueCount) {
	            case 1:
	                return c0 + _toStringWithNull(a1) + c1;
	            case 2:
	                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2;
	            case 3:
	                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                    c3;
	            case 4:
	                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                    c3 + _toStringWithNull(a4) + c4;
	            case 5:
	                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5;
	            case 6:
	                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6;
	            case 7:
	                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
	                    c6 + _toStringWithNull(a7) + c7;
	            case 8:
	                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
	                    c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8;
	            case 9:
	                return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) +
	                    c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) +
	                    c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8 + _toStringWithNull(a9) + c9;
	            default:
	                throw new Error("Does not support more than 9 expressions");
	        }
	    }
	    /**
	     * @param {?} v
	     * @return {?}
	     */
	    function _toStringWithNull(v) {
	        return v != null ? v.toString() : '';
	    }
	    /**
	     * @param {?} throwOnChange
	     * @param {?} oldValue
	     * @param {?} newValue
	     * @return {?}
	     */
	    function checkBinding(throwOnChange, oldValue, newValue) {
	        if (throwOnChange) {
	            if (!devModeEqual(oldValue, newValue)) {
	                throw new ExpressionChangedAfterItHasBeenCheckedError(oldValue, newValue);
	            }
	            return false;
	        }
	        else {
	            return !looseIdentical(oldValue, newValue);
	        }
	    }
	    /**
	     * @param {?} input
	     * @param {?} value
	     * @return {?}
	     */
	    function castByValue(input, value) {
	        return (input);
	    }
	    var /** @type {?} */ EMPTY_ARRAY = [];
	    var /** @type {?} */ EMPTY_MAP = {};
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    function pureProxy1(fn) {
	        var /** @type {?} */ result;
	        var /** @type {?} */ v0 = UNINITIALIZED;
	        return function (p0) {
	            if (!looseIdentical(v0, p0)) {
	                v0 = p0;
	                result = fn(p0);
	            }
	            return result;
	        };
	    }
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    function pureProxy2(fn) {
	        var /** @type {?} */ result;
	        var /** @type {?} */ v0 = UNINITIALIZED;
	        var /** @type {?} */ v1 = UNINITIALIZED;
	        return function (p0, p1) {
	            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1)) {
	                v0 = p0;
	                v1 = p1;
	                result = fn(p0, p1);
	            }
	            return result;
	        };
	    }
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    function pureProxy3(fn) {
	        var /** @type {?} */ result;
	        var /** @type {?} */ v0 = UNINITIALIZED;
	        var /** @type {?} */ v1 = UNINITIALIZED;
	        var /** @type {?} */ v2 = UNINITIALIZED;
	        return function (p0, p1, p2) {
	            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2)) {
	                v0 = p0;
	                v1 = p1;
	                v2 = p2;
	                result = fn(p0, p1, p2);
	            }
	            return result;
	        };
	    }
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    function pureProxy4(fn) {
	        var /** @type {?} */ result;
	        var /** @type {?} */ v0, /** @type {?} */ v1, /** @type {?} */ v2, /** @type {?} */ v3;
	        v0 = v1 = v2 = v3 = UNINITIALIZED;
	        return function (p0, p1, p2, p3) {
	            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
	                !looseIdentical(v3, p3)) {
	                v0 = p0;
	                v1 = p1;
	                v2 = p2;
	                v3 = p3;
	                result = fn(p0, p1, p2, p3);
	            }
	            return result;
	        };
	    }
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    function pureProxy5(fn) {
	        var /** @type {?} */ result;
	        var /** @type {?} */ v0, /** @type {?} */ v1, /** @type {?} */ v2, /** @type {?} */ v3, /** @type {?} */ v4;
	        v0 = v1 = v2 = v3 = v4 = UNINITIALIZED;
	        return function (p0, p1, p2, p3, p4) {
	            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
	                !looseIdentical(v3, p3) || !looseIdentical(v4, p4)) {
	                v0 = p0;
	                v1 = p1;
	                v2 = p2;
	                v3 = p3;
	                v4 = p4;
	                result = fn(p0, p1, p2, p3, p4);
	            }
	            return result;
	        };
	    }
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    function pureProxy6(fn) {
	        var /** @type {?} */ result;
	        var /** @type {?} */ v0, /** @type {?} */ v1, /** @type {?} */ v2, /** @type {?} */ v3, /** @type {?} */ v4, /** @type {?} */ v5;
	        v0 = v1 = v2 = v3 = v4 = v5 = UNINITIALIZED;
	        return function (p0, p1, p2, p3, p4, p5) {
	            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
	                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5)) {
	                v0 = p0;
	                v1 = p1;
	                v2 = p2;
	                v3 = p3;
	                v4 = p4;
	                v5 = p5;
	                result = fn(p0, p1, p2, p3, p4, p5);
	            }
	            return result;
	        };
	    }
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    function pureProxy7(fn) {
	        var /** @type {?} */ result;
	        var /** @type {?} */ v0, /** @type {?} */ v1, /** @type {?} */ v2, /** @type {?} */ v3, /** @type {?} */ v4, /** @type {?} */ v5, /** @type {?} */ v6;
	        v0 = v1 = v2 = v3 = v4 = v5 = v6 = UNINITIALIZED;
	        return function (p0, p1, p2, p3, p4, p5, p6) {
	            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
	                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) ||
	                !looseIdentical(v6, p6)) {
	                v0 = p0;
	                v1 = p1;
	                v2 = p2;
	                v3 = p3;
	                v4 = p4;
	                v5 = p5;
	                v6 = p6;
	                result = fn(p0, p1, p2, p3, p4, p5, p6);
	            }
	            return result;
	        };
	    }
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    function pureProxy8(fn) {
	        var /** @type {?} */ result;
	        var /** @type {?} */ v0, /** @type {?} */ v1, /** @type {?} */ v2, /** @type {?} */ v3, /** @type {?} */ v4, /** @type {?} */ v5, /** @type {?} */ v6, /** @type {?} */ v7;
	        v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = UNINITIALIZED;
	        return function (p0, p1, p2, p3, p4, p5, p6, p7) {
	            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
	                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) ||
	                !looseIdentical(v6, p6) || !looseIdentical(v7, p7)) {
	                v0 = p0;
	                v1 = p1;
	                v2 = p2;
	                v3 = p3;
	                v4 = p4;
	                v5 = p5;
	                v6 = p6;
	                v7 = p7;
	                result = fn(p0, p1, p2, p3, p4, p5, p6, p7);
	            }
	            return result;
	        };
	    }
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    function pureProxy9(fn) {
	        var /** @type {?} */ result;
	        var /** @type {?} */ v0, /** @type {?} */ v1, /** @type {?} */ v2, /** @type {?} */ v3, /** @type {?} */ v4, /** @type {?} */ v5, /** @type {?} */ v6, /** @type {?} */ v7, /** @type {?} */ v8;
	        v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = v8 = UNINITIALIZED;
	        return function (p0, p1, p2, p3, p4, p5, p6, p7, p8) {
	            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
	                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) ||
	                !looseIdentical(v6, p6) || !looseIdentical(v7, p7) || !looseIdentical(v8, p8)) {
	                v0 = p0;
	                v1 = p1;
	                v2 = p2;
	                v3 = p3;
	                v4 = p4;
	                v5 = p5;
	                v6 = p6;
	                v7 = p7;
	                v8 = p8;
	                result = fn(p0, p1, p2, p3, p4, p5, p6, p7, p8);
	            }
	            return result;
	        };
	    }
	    /**
	     * @param {?} fn
	     * @return {?}
	     */
	    function pureProxy10(fn) {
	        var /** @type {?} */ result;
	        var /** @type {?} */ v0, /** @type {?} */ v1, /** @type {?} */ v2, /** @type {?} */ v3, /** @type {?} */ v4, /** @type {?} */ v5, /** @type {?} */ v6, /** @type {?} */ v7, /** @type {?} */ v8, /** @type {?} */ v9;
	        v0 = v1 = v2 = v3 = v4 = v5 = v6 = v7 = v8 = v9 = UNINITIALIZED;
	        return function (p0, p1, p2, p3, p4, p5, p6, p7, p8, p9) {
	            if (!looseIdentical(v0, p0) || !looseIdentical(v1, p1) || !looseIdentical(v2, p2) ||
	                !looseIdentical(v3, p3) || !looseIdentical(v4, p4) || !looseIdentical(v5, p5) ||
	                !looseIdentical(v6, p6) || !looseIdentical(v7, p7) || !looseIdentical(v8, p8) ||
	                !looseIdentical(v9, p9)) {
	                v0 = p0;
	                v1 = p1;
	                v2 = p2;
	                v3 = p3;
	                v4 = p4;
	                v5 = p5;
	                v6 = p6;
	                v7 = p7;
	                v8 = p8;
	                v9 = p9;
	                result = fn(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);
	            }
	            return result;
	        };
	    }
	    /**
	     * @param {?} renderer
	     * @param {?} el
	     * @param {?} changes
	     * @return {?}
	     */
	    function setBindingDebugInfoForChanges(renderer, el, changes) {
	        Object.keys(changes).forEach(function (propName) {
	            setBindingDebugInfo(renderer, el, propName, changes[propName].currentValue);
	        });
	    }
	    /**
	     * @param {?} renderer
	     * @param {?} el
	     * @param {?} propName
	     * @param {?} value
	     * @return {?}
	     */
	    function setBindingDebugInfo(renderer, el, propName, value) {
	        try {
	            renderer.setBindingDebugInfo(el, "ng-reflect-" + camelCaseToDashCase(propName), value ? value.toString() : null);
	        }
	        catch (e) {
	            renderer.setBindingDebugInfo(el, "ng-reflect-" + camelCaseToDashCase(propName), '[ERROR] Exception while trying to serialize the value');
	        }
	    }
	    var /** @type {?} */ CAMEL_CASE_REGEXP = /([A-Z])/g;
	    /**
	     * @param {?} input
	     * @return {?}
	     */
	    function camelCaseToDashCase(input) {
	        return input.replace(CAMEL_CASE_REGEXP, function () {
	            var m = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                m[_i - 0] = arguments[_i];
	            }
	            return '-' + m[1].toLowerCase();
	        });
	    }
	    /**
	     * @param {?} renderer
	     * @param {?} parentElement
	     * @param {?} name
	     * @param {?} attrs
	     * @param {?=} debugInfo
	     * @return {?}
	     */
	    function createRenderElement(renderer, parentElement, name, attrs, debugInfo) {
	        var /** @type {?} */ el = renderer.createElement(parentElement, name, debugInfo);
	        for (var /** @type {?} */ i = 0; i < attrs.length; i += 2) {
	            renderer.setElementAttribute(el, attrs.get(i), attrs.get(i + 1));
	        }
	        return el;
	    }
	    /**
	     * @param {?} renderer
	     * @param {?} elementName
	     * @param {?} attrs
	     * @param {?} rootSelectorOrNode
	     * @param {?=} debugInfo
	     * @return {?}
	     */
	    function selectOrCreateRenderHostElement(renderer, elementName, attrs, rootSelectorOrNode, debugInfo) {
	        var /** @type {?} */ hostElement;
	        if (isPresent(rootSelectorOrNode)) {
	            hostElement = renderer.selectRootElement(rootSelectorOrNode, debugInfo);
	            for (var /** @type {?} */ i = 0; i < attrs.length; i += 2) {
	                renderer.setElementAttribute(hostElement, attrs.get(i), attrs.get(i + 1));
	            }
	            renderer.setElementAttribute(hostElement, 'ng-version', VERSION.full);
	        }
	        else {
	            hostElement = createRenderElement(renderer, null, elementName, attrs, debugInfo);
	        }
	        return hostElement;
	    }
	    /**
	     * @param {?} view
	     * @param {?} element
	     * @param {?} eventNamesAndTargets
	     * @param {?} listener
	     * @return {?}
	     */
	    function subscribeToRenderElement(view, element, eventNamesAndTargets, listener) {
	        var /** @type {?} */ disposables = createEmptyInlineArray(eventNamesAndTargets.length / 2);
	        for (var /** @type {?} */ i = 0; i < eventNamesAndTargets.length; i += 2) {
	            var /** @type {?} */ eventName = eventNamesAndTargets.get(i);
	            var /** @type {?} */ eventTarget = eventNamesAndTargets.get(i + 1);
	            var /** @type {?} */ disposable = void 0;
	            if (eventTarget) {
	                disposable = view.renderer.listenGlobal(eventTarget, eventName, listener.bind(view, eventTarget + ":" + eventName));
	            }
	            else {
	                disposable = view.renderer.listen(element, eventName, listener.bind(view, eventName));
	            }
	            disposables.set(i / 2, disposable);
	        }
	        return disposeInlineArray.bind(null, disposables);
	    }
	    /**
	     * @param {?} disposables
	     * @return {?}
	     */
	    function disposeInlineArray(disposables) {
	        for (var /** @type {?} */ i = 0; i < disposables.length; i++) {
	            disposables.get(i)();
	        }
	    }
	    /**
	     * @return {?}
	     */
	    function noop() { }
	    /**
	     * @param {?} length
	     * @return {?}
	     */
	    function createEmptyInlineArray(length) {
	        var /** @type {?} */ ctor;
	        if (length <= 2) {
	            ctor = InlineArray2;
	        }
	        else if (length <= 4) {
	            ctor = InlineArray4;
	        }
	        else if (length <= 8) {
	            ctor = InlineArray8;
	        }
	        else if (length <= 16) {
	            ctor = InlineArray16;
	        }
	        else {
	            ctor = InlineArrayDynamic;
	        }
	        return new ctor(length);
	    }
	    var InlineArray0 = (function () {
	        function InlineArray0() {
	            this.length = 0;
	        }
	        /**
	         * @param {?} index
	         * @return {?}
	         */
	        InlineArray0.prototype.get = function (index) { return undefined; };
	        /**
	         * @param {?} index
	         * @param {?} value
	         * @return {?}
	         */
	        InlineArray0.prototype.set = function (index, value) { };
	        return InlineArray0;
	    }());
	    var InlineArray2 = (function () {
	        /**
	         * @param {?} length
	         * @param {?=} _v0
	         * @param {?=} _v1
	         */
	        function InlineArray2(length, _v0, _v1) {
	            this.length = length;
	            this._v0 = _v0;
	            this._v1 = _v1;
	        }
	        /**
	         * @param {?} index
	         * @return {?}
	         */
	        InlineArray2.prototype.get = function (index) {
	            switch (index) {
	                case 0:
	                    return this._v0;
	                case 1:
	                    return this._v1;
	                default:
	                    return undefined;
	            }
	        };
	        /**
	         * @param {?} index
	         * @param {?} value
	         * @return {?}
	         */
	        InlineArray2.prototype.set = function (index, value) {
	            switch (index) {
	                case 0:
	                    this._v0 = value;
	                    break;
	                case 1:
	                    this._v1 = value;
	                    break;
	            }
	        };
	        return InlineArray2;
	    }());
	    var InlineArray4 = (function () {
	        /**
	         * @param {?} length
	         * @param {?=} _v0
	         * @param {?=} _v1
	         * @param {?=} _v2
	         * @param {?=} _v3
	         */
	        function InlineArray4(length, _v0, _v1, _v2, _v3) {
	            this.length = length;
	            this._v0 = _v0;
	            this._v1 = _v1;
	            this._v2 = _v2;
	            this._v3 = _v3;
	        }
	        /**
	         * @param {?} index
	         * @return {?}
	         */
	        InlineArray4.prototype.get = function (index) {
	            switch (index) {
	                case 0:
	                    return this._v0;
	                case 1:
	                    return this._v1;
	                case 2:
	                    return this._v2;
	                case 3:
	                    return this._v3;
	                default:
	                    return undefined;
	            }
	        };
	        /**
	         * @param {?} index
	         * @param {?} value
	         * @return {?}
	         */
	        InlineArray4.prototype.set = function (index, value) {
	            switch (index) {
	                case 0:
	                    this._v0 = value;
	                    break;
	                case 1:
	                    this._v1 = value;
	                    break;
	                case 2:
	                    this._v2 = value;
	                    break;
	                case 3:
	                    this._v3 = value;
	                    break;
	            }
	        };
	        return InlineArray4;
	    }());
	    var InlineArray8 = (function () {
	        /**
	         * @param {?} length
	         * @param {?=} _v0
	         * @param {?=} _v1
	         * @param {?=} _v2
	         * @param {?=} _v3
	         * @param {?=} _v4
	         * @param {?=} _v5
	         * @param {?=} _v6
	         * @param {?=} _v7
	         */
	        function InlineArray8(length, _v0, _v1, _v2, _v3, _v4, _v5, _v6, _v7) {
	            this.length = length;
	            this._v0 = _v0;
	            this._v1 = _v1;
	            this._v2 = _v2;
	            this._v3 = _v3;
	            this._v4 = _v4;
	            this._v5 = _v5;
	            this._v6 = _v6;
	            this._v7 = _v7;
	        }
	        /**
	         * @param {?} index
	         * @return {?}
	         */
	        InlineArray8.prototype.get = function (index) {
	            switch (index) {
	                case 0:
	                    return this._v0;
	                case 1:
	                    return this._v1;
	                case 2:
	                    return this._v2;
	                case 3:
	                    return this._v3;
	                case 4:
	                    return this._v4;
	                case 5:
	                    return this._v5;
	                case 6:
	                    return this._v6;
	                case 7:
	                    return this._v7;
	                default:
	                    return undefined;
	            }
	        };
	        /**
	         * @param {?} index
	         * @param {?} value
	         * @return {?}
	         */
	        InlineArray8.prototype.set = function (index, value) {
	            switch (index) {
	                case 0:
	                    this._v0 = value;
	                    break;
	                case 1:
	                    this._v1 = value;
	                    break;
	                case 2:
	                    this._v2 = value;
	                    break;
	                case 3:
	                    this._v3 = value;
	                    break;
	                case 4:
	                    this._v4 = value;
	                    break;
	                case 5:
	                    this._v5 = value;
	                    break;
	                case 6:
	                    this._v6 = value;
	                    break;
	                case 7:
	                    this._v7 = value;
	                    break;
	            }
	        };
	        return InlineArray8;
	    }());
	    var InlineArray16 = (function () {
	        /**
	         * @param {?} length
	         * @param {?=} _v0
	         * @param {?=} _v1
	         * @param {?=} _v2
	         * @param {?=} _v3
	         * @param {?=} _v4
	         * @param {?=} _v5
	         * @param {?=} _v6
	         * @param {?=} _v7
	         * @param {?=} _v8
	         * @param {?=} _v9
	         * @param {?=} _v10
	         * @param {?=} _v11
	         * @param {?=} _v12
	         * @param {?=} _v13
	         * @param {?=} _v14
	         * @param {?=} _v15
	         */
	        function InlineArray16(length, _v0, _v1, _v2, _v3, _v4, _v5, _v6, _v7, _v8, _v9, _v10, _v11, _v12, _v13, _v14, _v15) {
	            this.length = length;
	            this._v0 = _v0;
	            this._v1 = _v1;
	            this._v2 = _v2;
	            this._v3 = _v3;
	            this._v4 = _v4;
	            this._v5 = _v5;
	            this._v6 = _v6;
	            this._v7 = _v7;
	            this._v8 = _v8;
	            this._v9 = _v9;
	            this._v10 = _v10;
	            this._v11 = _v11;
	            this._v12 = _v12;
	            this._v13 = _v13;
	            this._v14 = _v14;
	            this._v15 = _v15;
	        }
	        /**
	         * @param {?} index
	         * @return {?}
	         */
	        InlineArray16.prototype.get = function (index) {
	            switch (index) {
	                case 0:
	                    return this._v0;
	                case 1:
	                    return this._v1;
	                case 2:
	                    return this._v2;
	                case 3:
	                    return this._v3;
	                case 4:
	                    return this._v4;
	                case 5:
	                    return this._v5;
	                case 6:
	                    return this._v6;
	                case 7:
	                    return this._v7;
	                case 8:
	                    return this._v8;
	                case 9:
	                    return this._v9;
	                case 10:
	                    return this._v10;
	                case 11:
	                    return this._v11;
	                case 12:
	                    return this._v12;
	                case 13:
	                    return this._v13;
	                case 14:
	                    return this._v14;
	                case 15:
	                    return this._v15;
	                default:
	                    return undefined;
	            }
	        };
	        /**
	         * @param {?} index
	         * @param {?} value
	         * @return {?}
	         */
	        InlineArray16.prototype.set = function (index, value) {
	            switch (index) {
	                case 0:
	                    this._v0 = value;
	                    break;
	                case 1:
	                    this._v1 = value;
	                    break;
	                case 2:
	                    this._v2 = value;
	                    break;
	                case 3:
	                    this._v3 = value;
	                    break;
	                case 4:
	                    this._v4 = value;
	                    break;
	                case 5:
	                    this._v5 = value;
	                    break;
	                case 6:
	                    this._v6 = value;
	                    break;
	                case 7:
	                    this._v7 = value;
	                    break;
	                case 8:
	                    this._v8 = value;
	                    break;
	                case 9:
	                    this._v9 = value;
	                    break;
	                case 10:
	                    this._v10 = value;
	                    break;
	                case 11:
	                    this._v11 = value;
	                    break;
	                case 12:
	                    this._v12 = value;
	                    break;
	                case 13:
	                    this._v13 = value;
	                    break;
	                case 14:
	                    this._v14 = value;
	                    break;
	                case 15:
	                    this._v15 = value;
	                    break;
	            }
	        };
	        return InlineArray16;
	    }());
	    var InlineArrayDynamic = (function () {
	        /**
	         * @param {?} length
	         * @param {...?} values
	         */
	        function InlineArrayDynamic(length) {
	            var values = [];
	            for (var _i = 1; _i < arguments.length; _i++) {
	                values[_i - 1] = arguments[_i];
	            }
	            this.length = length;
	            this._values = values;
	        }
	        /**
	         * @param {?} index
	         * @return {?}
	         */
	        InlineArrayDynamic.prototype.get = function (index) { return this._values[index]; };
	        /**
	         * @param {?} index
	         * @param {?} value
	         * @return {?}
	         */
	        InlineArrayDynamic.prototype.set = function (index, value) { this._values[index] = value; };
	        return InlineArrayDynamic;
	    }());
	    var /** @type {?} */ EMPTY_INLINE_ARRAY = new InlineArray0();


	    var view_utils = Object.freeze({
	        ViewUtils: ViewUtils,
	        createRenderComponentType: createRenderComponentType,
	        addToArray: addToArray,
	        interpolate: interpolate,
	        inlineInterpolate: inlineInterpolate,
	        checkBinding: checkBinding,
	        castByValue: castByValue,
	        EMPTY_ARRAY: EMPTY_ARRAY,
	        EMPTY_MAP: EMPTY_MAP,
	        pureProxy1: pureProxy1,
	        pureProxy2: pureProxy2,
	        pureProxy3: pureProxy3,
	        pureProxy4: pureProxy4,
	        pureProxy5: pureProxy5,
	        pureProxy6: pureProxy6,
	        pureProxy7: pureProxy7,
	        pureProxy8: pureProxy8,
	        pureProxy9: pureProxy9,
	        pureProxy10: pureProxy10,
	        setBindingDebugInfoForChanges: setBindingDebugInfoForChanges,
	        setBindingDebugInfo: setBindingDebugInfo,
	        createRenderElement: createRenderElement,
	        selectOrCreateRenderHostElement: selectOrCreateRenderHostElement,
	        subscribeToRenderElement: subscribeToRenderElement,
	        noop: noop,
	        InlineArray2: InlineArray2,
	        InlineArray4: InlineArray4,
	        InlineArray8: InlineArray8,
	        InlineArray16: InlineArray16,
	        InlineArrayDynamic: InlineArrayDynamic,
	        EMPTY_INLINE_ARRAY: EMPTY_INLINE_ARRAY
	    });

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$5 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Represents an instance of a Component created via a {\@link ComponentFactory}.
	     *
	     * `ComponentRef` provides access to the Component Instance as well other objects related to this
	     * Component Instance and allows you to destroy the Component Instance via the {\@link #destroy}
	     * method.
	     * \@stable
	     * @abstract
	     */
	    var ComponentRef = (function () {
	        function ComponentRef() {
	        }
	        Object.defineProperty(ComponentRef.prototype, "location", {
	            /**
	             * Location of the Host Element of this Component Instance.
	             * @return {?}
	             */
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ComponentRef.prototype, "injector", {
	            /**
	             * The injector on which the component instance exists.
	             * @return {?}
	             */
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ComponentRef.prototype, "instance", {
	            /**
	             * The instance of the Component.
	             * @return {?}
	             */
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        ;
	        Object.defineProperty(ComponentRef.prototype, "hostView", {
	            /**
	             * The {\@link ViewRef} of the Host View of this Component instance.
	             * @return {?}
	             */
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        ;
	        Object.defineProperty(ComponentRef.prototype, "changeDetectorRef", {
	            /**
	             * The {\@link ChangeDetectorRef} of the Component instance.
	             * @return {?}
	             */
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ComponentRef.prototype, "componentType", {
	            /**
	             * The component type.
	             * @return {?}
	             */
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * Destroys the component instance and all of the data structures associated with it.
	         * @abstract
	         * @return {?}
	         */
	        ComponentRef.prototype.destroy = function () { };
	        /**
	         * Allows to register a callback that will be called when the component is destroyed.
	         * @abstract
	         * @param {?} callback
	         * @return {?}
	         */
	        ComponentRef.prototype.onDestroy = function (callback) { };
	        return ComponentRef;
	    }());
	    var ComponentRef_ = (function (_super) {
	        __extends$5(ComponentRef_, _super);
	        /**
	         * @param {?} _index
	         * @param {?} _parentView
	         * @param {?} _nativeElement
	         * @param {?} _component
	         */
	        function ComponentRef_(_index, _parentView, _nativeElement, _component) {
	            _super.call(this);
	            this._index = _index;
	            this._parentView = _parentView;
	            this._nativeElement = _nativeElement;
	            this._component = _component;
	        }
	        Object.defineProperty(ComponentRef_.prototype, "location", {
	            /**
	             * @return {?}
	             */
	            get: function () { return new ElementRef(this._nativeElement); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ComponentRef_.prototype, "injector", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._parentView.injector(this._index); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ComponentRef_.prototype, "instance", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._component; },
	            enumerable: true,
	            configurable: true
	        });
	        ;
	        Object.defineProperty(ComponentRef_.prototype, "hostView", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._parentView.ref; },
	            enumerable: true,
	            configurable: true
	        });
	        ;
	        Object.defineProperty(ComponentRef_.prototype, "changeDetectorRef", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._parentView.ref; },
	            enumerable: true,
	            configurable: true
	        });
	        ;
	        Object.defineProperty(ComponentRef_.prototype, "componentType", {
	            /**
	             * @return {?}
	             */
	            get: function () { return (this._component.constructor); },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        ComponentRef_.prototype.destroy = function () { this._parentView.detachAndDestroy(); };
	        /**
	         * @param {?} callback
	         * @return {?}
	         */
	        ComponentRef_.prototype.onDestroy = function (callback) { this.hostView.onDestroy(callback); };
	        return ComponentRef_;
	    }(ComponentRef));
	    /**
	     * \@stable
	     */
	    var ComponentFactory = (function () {
	        /**
	         * @param {?} selector
	         * @param {?} _viewClass
	         * @param {?} _componentType
	         */
	        function ComponentFactory(selector, _viewClass, _componentType) {
	            this.selector = selector;
	            this._viewClass = _viewClass;
	            this._componentType = _componentType;
	        }
	        Object.defineProperty(ComponentFactory.prototype, "componentType", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._componentType; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * Creates a new component.
	         * @param {?} injector
	         * @param {?=} projectableNodes
	         * @param {?=} rootSelectorOrNode
	         * @return {?}
	         */
	        ComponentFactory.prototype.create = function (injector, projectableNodes, rootSelectorOrNode) {
	            if (projectableNodes === void 0) { projectableNodes = null; }
	            if (rootSelectorOrNode === void 0) { rootSelectorOrNode = null; }
	            var /** @type {?} */ vu = injector.get(ViewUtils);
	            if (!projectableNodes) {
	                projectableNodes = [];
	            }
	            var /** @type {?} */ hostView = new this._viewClass(vu, null, null, null);
	            return hostView.createHostView(rootSelectorOrNode, injector, projectableNodes);
	        };
	        return ComponentFactory;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$8 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * \@stable
	     */
	    var NoComponentFactoryError = (function (_super) {
	        __extends$8(NoComponentFactoryError, _super);
	        /**
	         * @param {?} component
	         */
	        function NoComponentFactoryError(component) {
	            _super.call(this, "No component factory found for " + stringify(component) + ". Did you add it to @NgModule.entryComponents?");
	            this.component = component;
	        }
	        return NoComponentFactoryError;
	    }(BaseError));
	    var _NullComponentFactoryResolver = (function () {
	        function _NullComponentFactoryResolver() {
	        }
	        /**
	         * @param {?} component
	         * @return {?}
	         */
	        _NullComponentFactoryResolver.prototype.resolveComponentFactory = function (component) {
	            throw new NoComponentFactoryError(component);
	        };
	        return _NullComponentFactoryResolver;
	    }());
	    /**
	     * \@stable
	     * @abstract
	     */
	    var ComponentFactoryResolver = (function () {
	        function ComponentFactoryResolver() {
	        }
	        /**
	         * @abstract
	         * @param {?} component
	         * @return {?}
	         */
	        ComponentFactoryResolver.prototype.resolveComponentFactory = function (component) { };
	        ComponentFactoryResolver.NULL = new _NullComponentFactoryResolver();
	        return ComponentFactoryResolver;
	    }());
	    var CodegenComponentFactoryResolver = (function () {
	        /**
	         * @param {?} factories
	         * @param {?} _parent
	         */
	        function CodegenComponentFactoryResolver(factories, _parent) {
	            this._parent = _parent;
	            this._factories = new Map();
	            for (var i = 0; i < factories.length; i++) {
	                var factory = factories[i];
	                this._factories.set(factory.componentType, factory);
	            }
	        }
	        /**
	         * @param {?} component
	         * @return {?}
	         */
	        CodegenComponentFactoryResolver.prototype.resolveComponentFactory = function (component) {
	            var /** @type {?} */ result = this._factories.get(component);
	            if (!result) {
	                result = this._parent.resolveComponentFactory(component);
	            }
	            return result;
	        };
	        return CodegenComponentFactoryResolver;
	    }());

	    var /** @type {?} */ trace;
	    var /** @type {?} */ events;
	    /**
	     * @return {?}
	     */
	    function detectWTF() {
	        var /** @type {?} */ wtf = ((global$1) /** TODO #9100 */)['wtf'];
	        if (wtf) {
	            trace = wtf['trace'];
	            if (trace) {
	                events = trace['events'];
	                return true;
	            }
	        }
	        return false;
	    }
	    /**
	     * @param {?} signature
	     * @param {?=} flags
	     * @return {?}
	     */
	    function createScope(signature, flags) {
	        if (flags === void 0) { flags = null; }
	        return events.createScope(signature, flags);
	    }
	    /**
	     * @param {?} scope
	     * @param {?=} returnValue
	     * @return {?}
	     */
	    function leave(scope, returnValue) {
	        trace.leaveScope(scope, returnValue);
	        return returnValue;
	    }
	    /**
	     * @param {?} rangeType
	     * @param {?} action
	     * @return {?}
	     */
	    function startTimeRange(rangeType, action) {
	        return trace.beginTimeRange(rangeType, action);
	    }
	    /**
	     * @param {?} range
	     * @return {?}
	     */
	    function endTimeRange(range) {
	        trace.endTimeRange(range);
	    }

	    /**
	     * True if WTF is enabled.
	     */
	    var /** @type {?} */ wtfEnabled = detectWTF();
	    /**
	     * @param {?=} arg0
	     * @param {?=} arg1
	     * @return {?}
	     */
	    function noopScope(arg0, arg1) {
	        return null;
	    }
	    /**
	     * Create trace scope.
	     *
	     * Scopes must be strictly nested and are analogous to stack frames, but
	     * do not have to follow the stack frames. Instead it is recommended that they follow logical
	     * nesting. You may want to use
	     * [Event
	     * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)
	     * as they are defined in WTF.
	     *
	     * Used to mark scope entry. The return value is used to leave the scope.
	     *
	     *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');
	     *
	     *     someMethod() {
	     *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI
	     *        // DO SOME WORK HERE
	     *        return wtfLeave(s, 123); // Return value 123
	     *     }
	     *
	     * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can
	     * negatively impact the performance of your application. For this reason we recommend that
	     * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and
	     * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to
	     * exception, will produce incorrect trace, but presence of exception signifies logic error which
	     * needs to be fixed before the app should be profiled. Add try-finally only when you expect that
	     * an exception is expected during normal execution while profiling.
	     *
	     * @experimental
	     */
	    var /** @type {?} */ wtfCreateScope = wtfEnabled ? createScope : function (signature, flags) { return noopScope; };
	    /**
	     * Used to mark end of Scope.
	     *
	     * - `scope` to end.
	     * - `returnValue` (optional) to be passed to the WTF.
	     *
	     * Returns the `returnValue for easy chaining.
	     * @experimental
	     */
	    var /** @type {?} */ wtfLeave = wtfEnabled ? leave : function (s, r) { return r; };
	    /**
	     * Used to mark Async start. Async are similar to scope but they don't have to be strictly nested.
	     * The return value is used in the call to [endAsync]. Async ranges only work if WTF has been
	     * enabled.
	     *
	     *     someMethod() {
	     *        var s = wtfStartTimeRange('HTTP:GET', 'some.url');
	     *        var future = new Future.delay(5).then((_) {
	     *          wtfEndTimeRange(s);
	     *        });
	     *     }
	     * @experimental
	     */
	    var /** @type {?} */ wtfStartTimeRange = wtfEnabled ? startTimeRange : function (rangeType, action) { return null; };
	    /**
	     * Ends a async time range operation.
	     * [range] is the return value from [wtfStartTimeRange] Async ranges only work if WTF has been
	     * enabled.
	     * @experimental
	     */
	    var /** @type {?} */ wtfEndTimeRange = wtfEnabled ? endTimeRange : function (r) { return null; };

	    /**
	     * The Testability service provides testing hooks that can be accessed from
	     * the browser and by services such as Protractor. Each bootstrapped Angular
	     * application on the page will have an instance of Testability.
	     * \@experimental
	     */
	    var Testability = (function () {
	        /**
	         * @param {?} _ngZone
	         */
	        function Testability(_ngZone) {
	            this._ngZone = _ngZone;
	            /** @internal */
	            this._pendingCount = 0;
	            /** @internal */
	            this._isZoneStable = true;
	            /**
	             * Whether any work was done since the last 'whenStable' callback. This is
	             * useful to detect if this could have potentially destabilized another
	             * component while it is stabilizing.
	             * @internal
	             */
	            this._didWork = false;
	            /** @internal */
	            this._callbacks = [];
	            this._watchAngularEvents();
	        }
	        /**
	         * \@internal
	         * @return {?}
	         */
	        Testability.prototype._watchAngularEvents = function () {
	            var _this = this;
	            this._ngZone.onUnstable.subscribe({
	                next: function () {
	                    _this._didWork = true;
	                    _this._isZoneStable = false;
	                }
	            });
	            this._ngZone.runOutsideAngular(function () {
	                _this._ngZone.onStable.subscribe({
	                    next: function () {
	                        NgZone.assertNotInAngularZone();
	                        scheduleMicroTask(function () {
	                            _this._isZoneStable = true;
	                            _this._runCallbacksIfReady();
	                        });
	                    }
	                });
	            });
	        };
	        /**
	         * @return {?}
	         */
	        Testability.prototype.increasePendingRequestCount = function () {
	            this._pendingCount += 1;
	            this._didWork = true;
	            return this._pendingCount;
	        };
	        /**
	         * @return {?}
	         */
	        Testability.prototype.decreasePendingRequestCount = function () {
	            this._pendingCount -= 1;
	            if (this._pendingCount < 0) {
	                throw new Error('pending async requests below zero');
	            }
	            this._runCallbacksIfReady();
	            return this._pendingCount;
	        };
	        /**
	         * @return {?}
	         */
	        Testability.prototype.isStable = function () {
	            return this._isZoneStable && this._pendingCount == 0 && !this._ngZone.hasPendingMacrotasks;
	        };
	        /**
	         * \@internal
	         * @return {?}
	         */
	        Testability.prototype._runCallbacksIfReady = function () {
	            var _this = this;
	            if (this.isStable()) {
	                // Schedules the call backs in a new frame so that it is always async.
	                scheduleMicroTask(function () {
	                    while (_this._callbacks.length !== 0) {
	                        (_this._callbacks.pop())(_this._didWork);
	                    }
	                    _this._didWork = false;
	                });
	            }
	            else {
	                // Not Ready
	                this._didWork = true;
	            }
	        };
	        /**
	         * @param {?} callback
	         * @return {?}
	         */
	        Testability.prototype.whenStable = function (callback) {
	            this._callbacks.push(callback);
	            this._runCallbacksIfReady();
	        };
	        /**
	         * @return {?}
	         */
	        Testability.prototype.getPendingRequestCount = function () { return this._pendingCount; };
	        /**
	         * @deprecated use findProviders
	         * @param {?} using
	         * @param {?} provider
	         * @param {?} exactMatch
	         * @return {?}
	         */
	        Testability.prototype.findBindings = function (using, provider, exactMatch) {
	            // TODO(juliemr): implement.
	            return [];
	        };
	        /**
	         * @param {?} using
	         * @param {?} provider
	         * @param {?} exactMatch
	         * @return {?}
	         */
	        Testability.prototype.findProviders = function (using, provider, exactMatch) {
	            // TODO(juliemr): implement.
	            return [];
	        };
	        Testability.decorators = [
	            { type: Injectable },
	        ];
	        /** @nocollapse */
	        Testability.ctorParameters = function () { return [
	            { type: NgZone, },
	        ]; };
	        return Testability;
	    }());
	    /**
	     * A global registry of {\@link Testability} instances for specific elements.
	     * \@experimental
	     */
	    var TestabilityRegistry = (function () {
	        function TestabilityRegistry() {
	            /** @internal */
	            this._applications = new Map();
	            _testabilityGetter.addToWindow(this);
	        }
	        /**
	         * @param {?} token
	         * @param {?} testability
	         * @return {?}
	         */
	        TestabilityRegistry.prototype.registerApplication = function (token, testability) {
	            this._applications.set(token, testability);
	        };
	        /**
	         * @param {?} elem
	         * @return {?}
	         */
	        TestabilityRegistry.prototype.getTestability = function (elem) { return this._applications.get(elem); };
	        /**
	         * @return {?}
	         */
	        TestabilityRegistry.prototype.getAllTestabilities = function () { return Array.from(this._applications.values()); };
	        /**
	         * @return {?}
	         */
	        TestabilityRegistry.prototype.getAllRootElements = function () { return Array.from(this._applications.keys()); };
	        /**
	         * @param {?} elem
	         * @param {?=} findInAncestors
	         * @return {?}
	         */
	        TestabilityRegistry.prototype.findTestabilityInTree = function (elem, findInAncestors) {
	            if (findInAncestors === void 0) { findInAncestors = true; }
	            return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);
	        };
	        TestabilityRegistry.decorators = [
	            { type: Injectable },
	        ];
	        /** @nocollapse */
	        TestabilityRegistry.ctorParameters = function () { return []; };
	        return TestabilityRegistry;
	    }());
	    var _NoopGetTestability = (function () {
	        function _NoopGetTestability() {
	        }
	        /**
	         * @param {?} registry
	         * @return {?}
	         */
	        _NoopGetTestability.prototype.addToWindow = function (registry) { };
	        /**
	         * @param {?} registry
	         * @param {?} elem
	         * @param {?} findInAncestors
	         * @return {?}
	         */
	        _NoopGetTestability.prototype.findTestabilityInTree = function (registry, elem, findInAncestors) {
	            return null;
	        };
	        return _NoopGetTestability;
	    }());
	    /**
	     * Set the {\@link GetTestability} implementation used by the Angular testing framework.
	     * \@experimental
	     * @param {?} getter
	     * @return {?}
	     */
	    function setTestabilityGetter(getter) {
	        _testabilityGetter = getter;
	    }
	    var /** @type {?} */ _testabilityGetter = new _NoopGetTestability();

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$3 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ _devMode = true;
	    var /** @type {?} */ _runModeLocked = false;
	    var /** @type {?} */ _platform;
	    /**
	     * Disable Angular's development mode, which turns off assertions and other
	     * checks within the framework.
	     *
	     * One important assertion this disables verifies that a change detection pass
	     * does not result in additional changes to any bindings (also known as
	     * unidirectional data flow).
	     *
	     * \@stable
	     * @return {?}
	     */
	    function enableProdMode() {
	        if (_runModeLocked) {
	            throw new Error('Cannot enable prod mode after platform setup.');
	        }
	        _devMode = false;
	    }
	    /**
	     * Returns whether Angular is in development mode. After called once,
	     * the value is locked and won't change any more.
	     *
	     * By default, this is true, unless a user calls `enableProdMode` before calling this.
	     *
	     * \@experimental APIs related to application bootstrap are currently under review.
	     * @return {?}
	     */
	    function isDevMode() {
	        _runModeLocked = true;
	        return _devMode;
	    }
	    /**
	     * A token for third-party components that can register themselves with NgProbe.
	     *
	     * \@experimental
	     */
	    var NgProbeToken = (function () {
	        /**
	         * @param {?} name
	         * @param {?} token
	         */
	        function NgProbeToken(name, token) {
	            this.name = name;
	            this.token = token;
	        }
	        return NgProbeToken;
	    }());
	    /**
	     * Creates a platform.
	     * Platforms have to be eagerly created via this function.
	     *
	     * \@experimental APIs related to application bootstrap are currently under review.
	     * @param {?} injector
	     * @return {?}
	     */
	    function createPlatform(injector) {
	        if (_platform && !_platform.destroyed) {
	            throw new Error('There can be only one platform. Destroy the previous one to create a new one.');
	        }
	        _platform = injector.get(PlatformRef);
	        var /** @type {?} */ inits = (injector.get(PLATFORM_INITIALIZER, null));
	        if (inits)
	            inits.forEach(function (init) { return init(); });
	        return _platform;
	    }
	    /**
	     * Creates a factory for a platform
	     *
	     * \@experimental APIs related to application bootstrap are currently under review.
	     * @param {?} parentPlatformFactory
	     * @param {?} name
	     * @param {?=} providers
	     * @return {?}
	     */
	    function createPlatformFactory(parentPlatformFactory, name, providers) {
	        if (providers === void 0) { providers = []; }
	        var /** @type {?} */ marker = new OpaqueToken("Platform: " + name);
	        return function (extraProviders) {
	            if (extraProviders === void 0) { extraProviders = []; }
	            if (!getPlatform()) {
	                if (parentPlatformFactory) {
	                    parentPlatformFactory(providers.concat(extraProviders).concat({ provide: marker, useValue: true }));
	                }
	                else {
	                    createPlatform(ReflectiveInjector.resolveAndCreate(providers.concat(extraProviders).concat({ provide: marker, useValue: true })));
	                }
	            }
	            return assertPlatform(marker);
	        };
	    }
	    /**
	     * Checks that there currently is a platform
	     * which contains the given token as a provider.
	     *
	     * \@experimental APIs related to application bootstrap are currently under review.
	     * @param {?} requiredToken
	     * @return {?}
	     */
	    function assertPlatform(requiredToken) {
	        var /** @type {?} */ platform = getPlatform();
	        if (!platform) {
	            throw new Error('No platform exists!');
	        }
	        if (!platform.injector.get(requiredToken, null)) {
	            throw new Error('A platform with a different configuration has been created. Please destroy it first.');
	        }
	        return platform;
	    }
	    /**
	     * Destroy the existing platform.
	     *
	     * \@experimental APIs related to application bootstrap are currently under review.
	     * @return {?}
	     */
	    function destroyPlatform() {
	        if (_platform && !_platform.destroyed) {
	            _platform.destroy();
	        }
	    }
	    /**
	     * Returns the current platform.
	     *
	     * \@experimental APIs related to application bootstrap are currently under review.
	     * @return {?}
	     */
	    function getPlatform() {
	        return _platform && !_platform.destroyed ? _platform : null;
	    }
	    /**
	     * The Angular platform is the entry point for Angular on a web page. Each page
	     * has exactly one platform, and services (such as reflection) which are common
	     * to every Angular application running on the page are bound in its scope.
	     *
	     * A page's platform is initialized implicitly when {\@link bootstrap}() is called, or
	     * explicitly by calling {\@link createPlatform}().
	     *
	     * \@stable
	     * @abstract
	     */
	    var PlatformRef = (function () {
	        function PlatformRef() {
	        }
	        /**
	         * Creates an instance of an `\@NgModule` for the given platform
	         * for offline compilation.
	         *
	         * ## Simple Example
	         *
	         * ```typescript
	         * my_module.ts:
	         *
	         * \@NgModule({
	         *   imports: [BrowserModule]
	         * })
	         * class MyModule {}
	         *
	         * main.ts:
	         * import {MyModuleNgFactory} from './my_module.ngfactory';
	         * import {platformBrowser} from '\@angular/platform-browser';
	         *
	         * let moduleRef = platformBrowser().bootstrapModuleFactory(MyModuleNgFactory);
	         * ```
	         *
	         * \@experimental APIs related to application bootstrap are currently under review.
	         * @param {?} moduleFactory
	         * @return {?}
	         */
	        PlatformRef.prototype.bootstrapModuleFactory = function (moduleFactory) {
	            throw unimplemented();
	        };
	        /**
	         * Creates an instance of an `\@NgModule` for a given platform using the given runtime compiler.
	         *
	         * ## Simple Example
	         *
	         * ```typescript
	         * \@NgModule({
	         *   imports: [BrowserModule]
	         * })
	         * class MyModule {}
	         *
	         * let moduleRef = platformBrowser().bootstrapModule(MyModule);
	         * ```
	         * \@stable
	         * @param {?} moduleType
	         * @param {?=} compilerOptions
	         * @return {?}
	         */
	        PlatformRef.prototype.bootstrapModule = function (moduleType, compilerOptions) {
	            if (compilerOptions === void 0) { compilerOptions = []; }
	            throw unimplemented();
	        };
	        /**
	         * Register a listener to be called when the platform is disposed.
	         * @abstract
	         * @param {?} callback
	         * @return {?}
	         */
	        PlatformRef.prototype.onDestroy = function (callback) { };
	        Object.defineProperty(PlatformRef.prototype, "injector", {
	            /**
	             * Retrieve the platform {\@link Injector}, which is the parent injector for
	             * every Angular application on the page and provides singleton providers.
	             * @return {?}
	             */
	            get: function () { throw unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        ;
	        /**
	         * Destroy the Angular platform and all Angular applications on the page.
	         * @abstract
	         * @return {?}
	         */
	        PlatformRef.prototype.destroy = function () { };
	        Object.defineProperty(PlatformRef.prototype, "destroyed", {
	            /**
	             * @return {?}
	             */
	            get: function () { throw unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        return PlatformRef;
	    }());
	    /**
	     * @param {?} errorHandler
	     * @param {?} callback
	     * @return {?}
	     */
	    function _callAndReportToErrorHandler(errorHandler, callback) {
	        try {
	            var /** @type {?} */ result = callback();
	            if (isPromise(result)) {
	                return result.catch(function (e) {
	                    errorHandler.handleError(e);
	                    // rethrow as the exception handler might not do it
	                    throw e;
	                });
	            }
	            return result;
	        }
	        catch (e) {
	            errorHandler.handleError(e);
	            // rethrow as the exception handler might not do it
	            throw e;
	        }
	    }
	    var PlatformRef_ = (function (_super) {
	        __extends$3(PlatformRef_, _super);
	        /**
	         * @param {?} _injector
	         */
	        function PlatformRef_(_injector) {
	            _super.call(this);
	            this._injector = _injector;
	            this._modules = [];
	            this._destroyListeners = [];
	            this._destroyed = false;
	        }
	        /**
	         * @param {?} callback
	         * @return {?}
	         */
	        PlatformRef_.prototype.onDestroy = function (callback) { this._destroyListeners.push(callback); };
	        Object.defineProperty(PlatformRef_.prototype, "injector", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._injector; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(PlatformRef_.prototype, "destroyed", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._destroyed; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        PlatformRef_.prototype.destroy = function () {
	            if (this._destroyed) {
	                throw new Error('The platform has already been destroyed!');
	            }
	            this._modules.slice().forEach(function (module) { return module.destroy(); });
	            this._destroyListeners.forEach(function (listener) { return listener(); });
	            this._destroyed = true;
	        };
	        /**
	         * @param {?} moduleFactory
	         * @return {?}
	         */
	        PlatformRef_.prototype.bootstrapModuleFactory = function (moduleFactory) {
	            return this._bootstrapModuleFactoryWithZone(moduleFactory, null);
	        };
	        /**
	         * @param {?} moduleFactory
	         * @param {?} ngZone
	         * @return {?}
	         */
	        PlatformRef_.prototype._bootstrapModuleFactoryWithZone = function (moduleFactory, ngZone) {
	            var _this = this;
	            // Note: We need to create the NgZone _before_ we instantiate the module,
	            // as instantiating the module creates some providers eagerly.
	            // So we create a mini parent injector that just contains the new NgZone and
	            // pass that as parent to the NgModuleFactory.
	            if (!ngZone)
	                ngZone = new NgZone({ enableLongStackTrace: isDevMode() });
	            // Attention: Don't use ApplicationRef.run here,
	            // as we want to be sure that all possible constructor calls are inside `ngZone.run`!
	            return ngZone.run(function () {
	                var /** @type {?} */ ngZoneInjector = ReflectiveInjector.resolveAndCreate([{ provide: NgZone, useValue: ngZone }], _this.injector);
	                var /** @type {?} */ moduleRef = (moduleFactory.create(ngZoneInjector));
	                var /** @type {?} */ exceptionHandler = moduleRef.injector.get(ErrorHandler, null);
	                if (!exceptionHandler) {
	                    throw new Error('No ErrorHandler. Is platform module (BrowserModule) included?');
	                }
	                moduleRef.onDestroy(function () { return ListWrapper.remove(_this._modules, moduleRef); });
	                ngZone.onError.subscribe({ next: function (error) { exceptionHandler.handleError(error); } });
	                return _callAndReportToErrorHandler(exceptionHandler, function () {
	                    var /** @type {?} */ initStatus = moduleRef.injector.get(ApplicationInitStatus);
	                    return initStatus.donePromise.then(function () {
	                        _this._moduleDoBootstrap(moduleRef);
	                        return moduleRef;
	                    });
	                });
	            });
	        };
	        /**
	         * @param {?} moduleType
	         * @param {?=} compilerOptions
	         * @return {?}
	         */
	        PlatformRef_.prototype.bootstrapModule = function (moduleType, compilerOptions) {
	            if (compilerOptions === void 0) { compilerOptions = []; }
	            return this._bootstrapModuleWithZone(moduleType, compilerOptions, null);
	        };
	        /**
	         * @param {?} moduleType
	         * @param {?=} compilerOptions
	         * @param {?} ngZone
	         * @param {?=} componentFactoryCallback
	         * @return {?}
	         */
	        PlatformRef_.prototype._bootstrapModuleWithZone = function (moduleType, compilerOptions, ngZone, componentFactoryCallback) {
	            var _this = this;
	            if (compilerOptions === void 0) { compilerOptions = []; }
	            var /** @type {?} */ compilerFactory = this.injector.get(CompilerFactory);
	            var /** @type {?} */ compiler = compilerFactory.createCompiler(Array.isArray(compilerOptions) ? compilerOptions : [compilerOptions]);
	            // ugly internal api hack: generate host component factories for all declared components and
	            // pass the factories into the callback - this is used by UpdateAdapter to get hold of all
	            // factories.
	            if (componentFactoryCallback) {
	                return compiler.compileModuleAndAllComponentsAsync(moduleType)
	                    .then(function (_a) {
	                    var ngModuleFactory = _a.ngModuleFactory, componentFactories = _a.componentFactories;
	                    componentFactoryCallback(componentFactories);
	                    return _this._bootstrapModuleFactoryWithZone(ngModuleFactory, ngZone);
	                });
	            }
	            return compiler.compileModuleAsync(moduleType)
	                .then(function (moduleFactory) { return _this._bootstrapModuleFactoryWithZone(moduleFactory, ngZone); });
	        };
	        /**
	         * @param {?} moduleRef
	         * @return {?}
	         */
	        PlatformRef_.prototype._moduleDoBootstrap = function (moduleRef) {
	            var /** @type {?} */ appRef = moduleRef.injector.get(ApplicationRef);
	            if (moduleRef.bootstrapFactories.length > 0) {
	                moduleRef.bootstrapFactories.forEach(function (compFactory) { return appRef.bootstrap(compFactory); });
	            }
	            else if (moduleRef.instance.ngDoBootstrap) {
	                moduleRef.instance.ngDoBootstrap(appRef);
	            }
	            else {
	                throw new Error(("The module " + stringify(moduleRef.instance.constructor) + " was bootstrapped, but it does not declare \"@NgModule.bootstrap\" components nor a \"ngDoBootstrap\" method. ") +
	                    "Please define one of these.");
	            }
	        };
	        PlatformRef_.decorators = [
	            { type: Injectable },
	        ];
	        /** @nocollapse */
	        PlatformRef_.ctorParameters = function () { return [
	            { type: Injector, },
	        ]; };
	        return PlatformRef_;
	    }(PlatformRef));
	    /**
	     * A reference to an Angular application running on a page.
	     *
	     * For more about Angular applications, see the documentation for {\@link bootstrap}.
	     *
	     * \@stable
	     * @abstract
	     */
	    var ApplicationRef = (function () {
	        function ApplicationRef() {
	        }
	        /**
	         * Bootstrap a new component at the root level of the application.
	         *
	         * ### Bootstrap process
	         *
	         * When bootstrapping a new root component into an application, Angular mounts the
	         * specified application component onto DOM elements identified by the [componentType]'s
	         * selector and kicks off automatic change detection to finish initializing the component.
	         *
	         * ### Example
	         * {\@example core/ts/platform/platform.ts region='longform'}
	         * @abstract
	         * @param {?} componentFactory
	         * @return {?}
	         */
	        ApplicationRef.prototype.bootstrap = function (componentFactory) { };
	        /**
	         * Invoke this method to explicitly process change detection and its side-effects.
	         *
	         * In development mode, `tick()` also performs a second change detection cycle to ensure that no
	         * further changes are detected. If additional changes are picked up during this second cycle,
	         * bindings in the app have side-effects that cannot be resolved in a single change detection
	         * pass.
	         * In this case, Angular throws an error, since an Angular application can only have one change
	         * detection pass during which all change detection must complete.
	         * @abstract
	         * @return {?}
	         */
	        ApplicationRef.prototype.tick = function () { };
	        Object.defineProperty(ApplicationRef.prototype, "componentTypes", {
	            /**
	             * Get a list of component types registered to this application.
	             * This list is populated even before the component is created.
	             * @return {?}
	             */
	            get: function () { return (unimplemented()); },
	            enumerable: true,
	            configurable: true
	        });
	        ;
	        Object.defineProperty(ApplicationRef.prototype, "components", {
	            /**
	             * Get a list of components registered to this application.
	             * @return {?}
	             */
	            get: function () { return (unimplemented()); },
	            enumerable: true,
	            configurable: true
	        });
	        ;
	        /**
	         * Attaches a view so that it will be dirty checked.
	         * The view will be automatically detached when it is destroyed.
	         * This will throw if the view is already attached to a ViewContainer.
	         * @param {?} view
	         * @return {?}
	         */
	        ApplicationRef.prototype.attachView = function (view) { unimplemented(); };
	        /**
	         * Detaches a view from dirty checking again.
	         * @param {?} view
	         * @return {?}
	         */
	        ApplicationRef.prototype.detachView = function (view) { unimplemented(); };
	        Object.defineProperty(ApplicationRef.prototype, "viewCount", {
	            /**
	             * Returns the number of attached views.
	             * @return {?}
	             */
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        return ApplicationRef;
	    }());
	    var ApplicationRef_ = (function (_super) {
	        __extends$3(ApplicationRef_, _super);
	        /**
	         * @param {?} _zone
	         * @param {?} _console
	         * @param {?} _injector
	         * @param {?} _exceptionHandler
	         * @param {?} _componentFactoryResolver
	         * @param {?} _initStatus
	         * @param {?} _testabilityRegistry
	         * @param {?} _testability
	         */
	        function ApplicationRef_(_zone, _console, _injector, _exceptionHandler, _componentFactoryResolver, _initStatus, _testabilityRegistry, _testability) {
	            var _this = this;
	            _super.call(this);
	            this._zone = _zone;
	            this._console = _console;
	            this._injector = _injector;
	            this._exceptionHandler = _exceptionHandler;
	            this._componentFactoryResolver = _componentFactoryResolver;
	            this._initStatus = _initStatus;
	            this._testabilityRegistry = _testabilityRegistry;
	            this._testability = _testability;
	            this._bootstrapListeners = [];
	            this._rootComponents = [];
	            this._rootComponentTypes = [];
	            this._views = [];
	            this._runningTick = false;
	            this._enforceNoNewChanges = false;
	            this._enforceNoNewChanges = isDevMode();
	            this._zone.onMicrotaskEmpty.subscribe({ next: function () { _this._zone.run(function () { _this.tick(); }); } });
	        }
	        /**
	         * @param {?} viewRef
	         * @return {?}
	         */
	        ApplicationRef_.prototype.attachView = function (viewRef) {
	            var /** @type {?} */ view = ((viewRef)).internalView;
	            this._views.push(view);
	            view.attachToAppRef(this);
	        };
	        /**
	         * @param {?} viewRef
	         * @return {?}
	         */
	        ApplicationRef_.prototype.detachView = function (viewRef) {
	            var /** @type {?} */ view = ((viewRef)).internalView;
	            ListWrapper.remove(this._views, view);
	            view.detach();
	        };
	        /**
	         * @param {?} componentOrFactory
	         * @return {?}
	         */
	        ApplicationRef_.prototype.bootstrap = function (componentOrFactory) {
	            var _this = this;
	            if (!this._initStatus.done) {
	                throw new Error('Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.');
	            }
	            var /** @type {?} */ componentFactory;
	            if (componentOrFactory instanceof ComponentFactory) {
	                componentFactory = componentOrFactory;
	            }
	            else {
	                componentFactory = this._componentFactoryResolver.resolveComponentFactory(componentOrFactory);
	            }
	            this._rootComponentTypes.push(componentFactory.componentType);
	            var /** @type {?} */ compRef = componentFactory.create(this._injector, [], componentFactory.selector);
	            compRef.onDestroy(function () { _this._unloadComponent(compRef); });
	            var /** @type {?} */ testability = compRef.injector.get(Testability, null);
	            if (testability) {
	                compRef.injector.get(TestabilityRegistry)
	                    .registerApplication(compRef.location.nativeElement, testability);
	            }
	            this._loadComponent(compRef);
	            if (isDevMode()) {
	                this._console.log("Angular is running in the development mode. Call enableProdMode() to enable the production mode.");
	            }
	            return compRef;
	        };
	        /**
	         * @param {?} componentRef
	         * @return {?}
	         */
	        ApplicationRef_.prototype._loadComponent = function (componentRef) {
	            this.attachView(componentRef.hostView);
	            this.tick();
	            this._rootComponents.push(componentRef);
	            // Get the listeners lazily to prevent DI cycles.
	            var /** @type {?} */ listeners = (this._injector.get(APP_BOOTSTRAP_LISTENER, [])
	                .concat(this._bootstrapListeners));
	            listeners.forEach(function (listener) { return listener(componentRef); });
	        };
	        /**
	         * @param {?} componentRef
	         * @return {?}
	         */
	        ApplicationRef_.prototype._unloadComponent = function (componentRef) {
	            this.detachView(componentRef.hostView);
	            ListWrapper.remove(this._rootComponents, componentRef);
	        };
	        /**
	         * @return {?}
	         */
	        ApplicationRef_.prototype.tick = function () {
	            if (this._runningTick) {
	                throw new Error('ApplicationRef.tick is called recursively');
	            }
	            var /** @type {?} */ scope = ApplicationRef_._tickScope();
	            try {
	                this._runningTick = true;
	                this._views.forEach(function (view) { return view.ref.detectChanges(); });
	                if (this._enforceNoNewChanges) {
	                    this._views.forEach(function (view) { return view.ref.checkNoChanges(); });
	                }
	            }
	            finally {
	                this._runningTick = false;
	                wtfLeave(scope);
	            }
	        };
	        /**
	         * @return {?}
	         */
	        ApplicationRef_.prototype.ngOnDestroy = function () {
	            // TODO(alxhub): Dispose of the NgZone.
	            this._views.slice().forEach(function (view) { return view.destroy(); });
	        };
	        Object.defineProperty(ApplicationRef_.prototype, "viewCount", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._views.length; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ApplicationRef_.prototype, "componentTypes", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._rootComponentTypes; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ApplicationRef_.prototype, "components", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._rootComponents; },
	            enumerable: true,
	            configurable: true
	        });
	        /** @internal */
	        ApplicationRef_._tickScope = wtfCreateScope('ApplicationRef#tick()');
	        ApplicationRef_.decorators = [
	            { type: Injectable },
	        ];
	        /** @nocollapse */
	        ApplicationRef_.ctorParameters = function () { return [
	            { type: NgZone, },
	            { type: Console, },
	            { type: Injector, },
	            { type: ErrorHandler, },
	            { type: ComponentFactoryResolver, },
	            { type: ApplicationInitStatus, },
	            { type: TestabilityRegistry, decorators: [{ type: Optional },] },
	            { type: Testability, decorators: [{ type: Optional },] },
	        ]; };
	        return ApplicationRef_;
	    }(ApplicationRef));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$9 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Represents an instance of an NgModule created via a {\@link NgModuleFactory}.
	     *
	     * `NgModuleRef` provides access to the NgModule Instance as well other objects related to this
	     * NgModule Instance.
	     *
	     * \@stable
	     * @abstract
	     */
	    var NgModuleRef = (function () {
	        function NgModuleRef() {
	        }
	        Object.defineProperty(NgModuleRef.prototype, "injector", {
	            /**
	             * The injector that contains all of the providers of the NgModule.
	             * @return {?}
	             */
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgModuleRef.prototype, "componentFactoryResolver", {
	            /**
	             * The ComponentFactoryResolver to get hold of the ComponentFactories
	             * declared in the `entryComponents` property of the module.
	             * @return {?}
	             */
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgModuleRef.prototype, "instance", {
	            /**
	             * The NgModule instance.
	             * @return {?}
	             */
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * Destroys the module instance and all of the data structures associated with it.
	         * @abstract
	         * @return {?}
	         */
	        NgModuleRef.prototype.destroy = function () { };
	        /**
	         * Allows to register a callback that will be called when the module is destroyed.
	         * @abstract
	         * @param {?} callback
	         * @return {?}
	         */
	        NgModuleRef.prototype.onDestroy = function (callback) { };
	        return NgModuleRef;
	    }());
	    /**
	     * \@experimental
	     */
	    var NgModuleFactory = (function () {
	        /**
	         * @param {?} _injectorClass
	         * @param {?} _moduleType
	         */
	        function NgModuleFactory(_injectorClass, _moduleType) {
	            this._injectorClass = _injectorClass;
	            this._moduleType = _moduleType;
	        }
	        Object.defineProperty(NgModuleFactory.prototype, "moduleType", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._moduleType; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} parentInjector
	         * @return {?}
	         */
	        NgModuleFactory.prototype.create = function (parentInjector) {
	            if (!parentInjector) {
	                parentInjector = Injector.NULL;
	            }
	            var /** @type {?} */ instance = new this._injectorClass(parentInjector);
	            instance.create();
	            return instance;
	        };
	        return NgModuleFactory;
	    }());
	    var /** @type {?} */ _UNDEFINED = new Object();
	    /**
	     * @abstract
	     */
	    var NgModuleInjector = (function (_super) {
	        __extends$9(NgModuleInjector, _super);
	        /**
	         * @param {?} parent
	         * @param {?} factories
	         * @param {?} bootstrapFactories
	         */
	        function NgModuleInjector(parent, factories, bootstrapFactories) {
	            _super.call(this, factories, parent.get(ComponentFactoryResolver, ComponentFactoryResolver.NULL));
	            this.parent = parent;
	            this.bootstrapFactories = bootstrapFactories;
	            this._destroyListeners = [];
	            this._destroyed = false;
	        }
	        /**
	         * @return {?}
	         */
	        NgModuleInjector.prototype.create = function () { this.instance = this.createInternal(); };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        NgModuleInjector.prototype.createInternal = function () { };
	        /**
	         * @param {?} token
	         * @param {?=} notFoundValue
	         * @return {?}
	         */
	        NgModuleInjector.prototype.get = function (token, notFoundValue) {
	            if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }
	            if (token === Injector || token === ComponentFactoryResolver) {
	                return this;
	            }
	            var /** @type {?} */ result = this.getInternal(token, _UNDEFINED);
	            return result === _UNDEFINED ? this.parent.get(token, notFoundValue) : result;
	        };
	        /**
	         * @abstract
	         * @param {?} token
	         * @param {?} notFoundValue
	         * @return {?}
	         */
	        NgModuleInjector.prototype.getInternal = function (token, notFoundValue) { };
	        Object.defineProperty(NgModuleInjector.prototype, "injector", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgModuleInjector.prototype, "componentFactoryResolver", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        NgModuleInjector.prototype.destroy = function () {
	            if (this._destroyed) {
	                throw new Error("The ng module " + stringify(this.instance.constructor) + " has already been destroyed.");
	            }
	            this._destroyed = true;
	            this.destroyInternal();
	            this._destroyListeners.forEach(function (listener) { return listener(); });
	        };
	        /**
	         * @param {?} callback
	         * @return {?}
	         */
	        NgModuleInjector.prototype.onDestroy = function (callback) { this._destroyListeners.push(callback); };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        NgModuleInjector.prototype.destroyInternal = function () { };
	        return NgModuleInjector;
	    }(CodegenComponentFactoryResolver));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * Used to load ng module factories.
	     * \@stable
	     * @abstract
	     */
	    var NgModuleFactoryLoader = (function () {
	        function NgModuleFactoryLoader() {
	        }
	        /**
	         * @abstract
	         * @param {?} path
	         * @return {?}
	         */
	        NgModuleFactoryLoader.prototype.load = function (path) { };
	        return NgModuleFactoryLoader;
	    }());
	    var /** @type {?} */ moduleFactories = new Map();
	    /**
	     * Registers a loaded module. Should only be called from generated NgModuleFactory code.
	     * \@experimental
	     * @param {?} id
	     * @param {?} factory
	     * @return {?}
	     */
	    function registerModuleFactory(id, factory) {
	        var /** @type {?} */ existing = moduleFactories.get(id);
	        if (existing) {
	            throw new Error("Duplicate module registered for " + id + " - " + existing.moduleType.name + " vs " + factory.moduleType.name);
	        }
	        moduleFactories.set(id, factory);
	    }
	    /**
	     * Returns the NgModuleFactory with the given id, if it exists and has been loaded.
	     * Factories for modules that do not specify an `id` cannot be retrieved. Throws if the module
	     * cannot be found.
	     * \@experimental
	     * @param {?} id
	     * @return {?}
	     */
	    function getModuleFactory(id) {
	        var /** @type {?} */ factory = moduleFactories.get(id);
	        if (!factory)
	            throw new Error("No module with ID " + id + " loaded");
	        return factory;
	    }

	    /**
	     * An unmodifiable list of items that Angular keeps up to date when the state
	     * of the application changes.
	     *
	     * The type of object that {\@link Query} and {\@link ViewQueryMetadata} provide.
	     *
	     * Implements an iterable interface, therefore it can be used in both ES6
	     * javascript `for (var i of items)` loops as well as in Angular templates with
	     * `*ngFor="let i of myList"`.
	     *
	     * Changes can be observed by subscribing to the changes `Observable`.
	     *
	     * NOTE: In the future this class will implement an `Observable` interface.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/RX8sJnQYl9FWuSCWme5z?p=preview))
	     * ```typescript
	     * \@Component({...})
	     * class Container {
	     *   \@ViewChildren(Item) items:QueryList<Item>;
	     * }
	     * ```
	     * \@stable
	     */
	    var QueryList = (function () {
	        function QueryList() {
	            this._dirty = true;
	            this._results = [];
	            this._emitter = new EventEmitter();
	        }
	        Object.defineProperty(QueryList.prototype, "changes", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._emitter; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(QueryList.prototype, "length", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._results.length; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(QueryList.prototype, "first", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._results[0]; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(QueryList.prototype, "last", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._results[this.length - 1]; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * See
	         * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
	         * @param {?} fn
	         * @return {?}
	         */
	        QueryList.prototype.map = function (fn) { return this._results.map(fn); };
	        /**
	         * See
	         * [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
	         * @param {?} fn
	         * @return {?}
	         */
	        QueryList.prototype.filter = function (fn) {
	            return this._results.filter(fn);
	        };
	        /**
	         * See
	         * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)
	         * @param {?} fn
	         * @return {?}
	         */
	        QueryList.prototype.find = function (fn) { return this._results.find(fn); };
	        /**
	         * See
	         * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
	         * @param {?} fn
	         * @param {?} init
	         * @return {?}
	         */
	        QueryList.prototype.reduce = function (fn, init) {
	            return this._results.reduce(fn, init);
	        };
	        /**
	         * See
	         * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
	         * @param {?} fn
	         * @return {?}
	         */
	        QueryList.prototype.forEach = function (fn) { this._results.forEach(fn); };
	        /**
	         * See
	         * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)
	         * @param {?} fn
	         * @return {?}
	         */
	        QueryList.prototype.some = function (fn) {
	            return this._results.some(fn);
	        };
	        /**
	         * @return {?}
	         */
	        QueryList.prototype.toArray = function () { return this._results.slice(); };
	        /**
	         * @return {?}
	         */
	        QueryList.prototype[getSymbolIterator()] = function () { return ((this._results))[getSymbolIterator()](); };
	        /**
	         * @return {?}
	         */
	        QueryList.prototype.toString = function () { return this._results.toString(); };
	        /**
	         * @param {?} res
	         * @return {?}
	         */
	        QueryList.prototype.reset = function (res) {
	            this._results = ListWrapper.flatten(res);
	            this._dirty = false;
	        };
	        /**
	         * @return {?}
	         */
	        QueryList.prototype.notifyOnChanges = function () { this._emitter.emit(this); };
	        /**
	         * internal
	         * @return {?}
	         */
	        QueryList.prototype.setDirty = function () { this._dirty = true; };
	        Object.defineProperty(QueryList.prototype, "dirty", {
	            /**
	             * internal
	             * @return {?}
	             */
	            get: function () { return this._dirty; },
	            enumerable: true,
	            configurable: true
	        });
	        return QueryList;
	    }());

	    var /** @type {?} */ _SEPARATOR = '#';
	    var /** @type {?} */ FACTORY_CLASS_SUFFIX = 'NgFactory';
	    /**
	     * Configuration for SystemJsNgModuleLoader.
	     * token.
	     *
	     * \@experimental
	     * @abstract
	     */
	    var SystemJsNgModuleLoaderConfig = (function () {
	        function SystemJsNgModuleLoaderConfig() {
	        }
	        return SystemJsNgModuleLoaderConfig;
	    }());
	    var /** @type {?} */ DEFAULT_CONFIG = {
	        factoryPathPrefix: '',
	        factoryPathSuffix: '.ngfactory',
	    };
	    /**
	     * NgModuleFactoryLoader that uses SystemJS to load NgModuleFactory
	     * \@experimental
	     */
	    var SystemJsNgModuleLoader = (function () {
	        /**
	         * @param {?} _compiler
	         * @param {?=} config
	         */
	        function SystemJsNgModuleLoader(_compiler, config) {
	            this._compiler = _compiler;
	            this._config = config || DEFAULT_CONFIG;
	        }
	        /**
	         * @param {?} path
	         * @return {?}
	         */
	        SystemJsNgModuleLoader.prototype.load = function (path) {
	            var /** @type {?} */ offlineMode = this._compiler instanceof Compiler;
	            return offlineMode ? this.loadFactory(path) : this.loadAndCompile(path);
	        };
	        /**
	         * @param {?} path
	         * @return {?}
	         */
	        SystemJsNgModuleLoader.prototype.loadAndCompile = function (path) {
	            var _this = this;
	            var _a = path.split(_SEPARATOR), module = _a[0], exportName = _a[1];
	            if (exportName === undefined) {
	                exportName = 'default';
	            }
	            return System.import(module)
	                .then(function (module) { return module[exportName]; })
	                .then(function (type) { return checkNotEmpty(type, module, exportName); })
	                .then(function (type) { return _this._compiler.compileModuleAsync(type); });
	        };
	        /**
	         * @param {?} path
	         * @return {?}
	         */
	        SystemJsNgModuleLoader.prototype.loadFactory = function (path) {
	            var _a = path.split(_SEPARATOR), module = _a[0], exportName = _a[1];
	            var /** @type {?} */ factoryClassSuffix = FACTORY_CLASS_SUFFIX;
	            if (exportName === undefined) {
	                exportName = 'default';
	                factoryClassSuffix = '';
	            }
	            return System.import(this._config.factoryPathPrefix + module + this._config.factoryPathSuffix)
	                .then(function (module) { return module[exportName + factoryClassSuffix]; })
	                .then(function (factory) { return checkNotEmpty(factory, module, exportName); });
	        };
	        SystemJsNgModuleLoader.decorators = [
	            { type: Injectable },
	        ];
	        /** @nocollapse */
	        SystemJsNgModuleLoader.ctorParameters = function () { return [
	            { type: Compiler, },
	            { type: SystemJsNgModuleLoaderConfig, decorators: [{ type: Optional },] },
	        ]; };
	        return SystemJsNgModuleLoader;
	    }());
	    /**
	     * @param {?} value
	     * @param {?} modulePath
	     * @param {?} exportName
	     * @return {?}
	     */
	    function checkNotEmpty(value, modulePath, exportName) {
	        if (!value) {
	            throw new Error("Cannot find '" + exportName + "' in '" + modulePath + "'");
	        }
	        return value;
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$10 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Represents an Embedded Template that can be used to instantiate Embedded Views.
	     *
	     * You can access a `TemplateRef`, in two ways. Via a directive placed on a `<template>` element (or
	     * directive prefixed with `*`) and have the `TemplateRef` for this Embedded View injected into the
	     * constructor of the directive using the `TemplateRef` Token. Alternatively you can query for the
	     * `TemplateRef` from a Component or a Directive via {\@link Query}.
	     *
	     * To instantiate Embedded Views based on a Template, use
	     * {\@link ViewContainerRef#createEmbeddedView}, which will create the View and attach it to the
	     * View Container.
	     * \@stable
	     * @abstract
	     */
	    var TemplateRef = (function () {
	        function TemplateRef() {
	        }
	        Object.defineProperty(TemplateRef.prototype, "elementRef", {
	            /**
	             * @return {?}
	             */
	            get: function () { return null; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @abstract
	         * @param {?} context
	         * @return {?}
	         */
	        TemplateRef.prototype.createEmbeddedView = function (context) { };
	        return TemplateRef;
	    }());
	    var TemplateRef_ = (function (_super) {
	        __extends$10(TemplateRef_, _super);
	        /**
	         * @param {?} _parentView
	         * @param {?} _nodeIndex
	         * @param {?} _nativeElement
	         */
	        function TemplateRef_(_parentView, _nodeIndex, _nativeElement) {
	            _super.call(this);
	            this._parentView = _parentView;
	            this._nodeIndex = _nodeIndex;
	            this._nativeElement = _nativeElement;
	        }
	        /**
	         * @param {?} context
	         * @return {?}
	         */
	        TemplateRef_.prototype.createEmbeddedView = function (context) {
	            var /** @type {?} */ view = this._parentView.createEmbeddedViewInternal(this._nodeIndex);
	            view.create(context || ({}));
	            return view.ref;
	        };
	        Object.defineProperty(TemplateRef_.prototype, "elementRef", {
	            /**
	             * @return {?}
	             */
	            get: function () { return new ElementRef(this._nativeElement); },
	            enumerable: true,
	            configurable: true
	        });
	        return TemplateRef_;
	    }(TemplateRef));

	    /**
	     * Represents a container where one or more Views can be attached.
	     *
	     * The container can contain two kinds of Views. Host Views, created by instantiating a
	     * {\@link Component} via {\@link #createComponent}, and Embedded Views, created by instantiating an
	     * {\@link TemplateRef Embedded Template} via {\@link #createEmbeddedView}.
	     *
	     * The location of the View Container within the containing View is specified by the Anchor
	     * `element`. Each View Container can have only one Anchor Element and each Anchor Element can only
	     * have a single View Container.
	     *
	     * Root elements of Views attached to this container become siblings of the Anchor Element in
	     * the Rendered View.
	     *
	     * To access a `ViewContainerRef` of an Element, you can either place a {\@link Directive} injected
	     * with `ViewContainerRef` on the Element, or you obtain it via a {\@link ViewChild} query.
	     * \@stable
	     * @abstract
	     */
	    var ViewContainerRef = (function () {
	        function ViewContainerRef() {
	        }
	        Object.defineProperty(ViewContainerRef.prototype, "element", {
	            /**
	             * Anchor element that specifies the location of this container in the containing View.
	             * <!-- TODO: rename to anchorElement -->
	             * @return {?}
	             */
	            get: function () { return (unimplemented()); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ViewContainerRef.prototype, "injector", {
	            /**
	             * @return {?}
	             */
	            get: function () { return (unimplemented()); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ViewContainerRef.prototype, "parentInjector", {
	            /**
	             * @return {?}
	             */
	            get: function () { return (unimplemented()); },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * Destroys all Views in this container.
	         * @abstract
	         * @return {?}
	         */
	        ViewContainerRef.prototype.clear = function () { };
	        /**
	         * Returns the {\@link ViewRef} for the View located in this container at the specified index.
	         * @abstract
	         * @param {?} index
	         * @return {?}
	         */
	        ViewContainerRef.prototype.get = function (index) { };
	        Object.defineProperty(ViewContainerRef.prototype, "length", {
	            /**
	             * Returns the number of Views currently attached to this container.
	             * @return {?}
	             */
	            get: function () { return (unimplemented()); },
	            enumerable: true,
	            configurable: true
	        });
	        ;
	        /**
	         * Instantiates an Embedded View based on the {\@link TemplateRef `templateRef`} and inserts it
	         * into this container at the specified `index`.
	         *
	         * If `index` is not specified, the new View will be inserted as the last View in the container.
	         *
	         * Returns the {\@link ViewRef} for the newly created View.
	         * @abstract
	         * @param {?} templateRef
	         * @param {?=} context
	         * @param {?=} index
	         * @return {?}
	         */
	        ViewContainerRef.prototype.createEmbeddedView = function (templateRef, context, index) { };
	        /**
	         * Instantiates a single {\@link Component} and inserts its Host View into this container at the
	         * specified `index`.
	         *
	         * The component is instantiated using its {\@link ComponentFactory} which can be
	         * obtained via {\@link ComponentFactoryResolver#resolveComponentFactory}.
	         *
	         * If `index` is not specified, the new View will be inserted as the last View in the container.
	         *
	         * You can optionally specify the {\@link Injector} that will be used as parent for the Component.
	         *
	         * Returns the {\@link ComponentRef} of the Host View created for the newly instantiated Component.
	         * @abstract
	         * @param {?} componentFactory
	         * @param {?=} index
	         * @param {?=} injector
	         * @param {?=} projectableNodes
	         * @return {?}
	         */
	        ViewContainerRef.prototype.createComponent = function (componentFactory, index, injector, projectableNodes) { };
	        /**
	         * Inserts a View identified by a {\@link ViewRef} into the container at the specified `index`.
	         *
	         * If `index` is not specified, the new View will be inserted as the last View in the container.
	         *
	         * Returns the inserted {\@link ViewRef}.
	         * @abstract
	         * @param {?} viewRef
	         * @param {?=} index
	         * @return {?}
	         */
	        ViewContainerRef.prototype.insert = function (viewRef, index) { };
	        /**
	         * Moves a View identified by a {\@link ViewRef} into the container at the specified `index`.
	         *
	         * Returns the inserted {\@link ViewRef}.
	         * @abstract
	         * @param {?} viewRef
	         * @param {?} currentIndex
	         * @return {?}
	         */
	        ViewContainerRef.prototype.move = function (viewRef, currentIndex) { };
	        /**
	         * Returns the index of the View, specified via {\@link ViewRef}, within the current container or
	         * `-1` if this container doesn't contain the View.
	         * @abstract
	         * @param {?} viewRef
	         * @return {?}
	         */
	        ViewContainerRef.prototype.indexOf = function (viewRef) { };
	        /**
	         * Destroys a View attached to this container at the specified `index`.
	         *
	         * If `index` is not specified, the last View in the container will be removed.
	         * @abstract
	         * @param {?=} index
	         * @return {?}
	         */
	        ViewContainerRef.prototype.remove = function (index) { };
	        /**
	         * Use along with {\@link #insert} to move a View within the current container.
	         *
	         * If the `index` param is omitted, the last {\@link ViewRef} is detached.
	         * @abstract
	         * @param {?=} index
	         * @return {?}
	         */
	        ViewContainerRef.prototype.detach = function (index) { };
	        return ViewContainerRef;
	    }());
	    var ViewContainerRef_ = (function () {
	        /**
	         * @param {?} _element
	         */
	        function ViewContainerRef_(_element) {
	            this._element = _element;
	            /** @internal */
	            this._createComponentInContainerScope = wtfCreateScope('ViewContainerRef#createComponent()');
	            /** @internal */
	            this._insertScope = wtfCreateScope('ViewContainerRef#insert()');
	            /** @internal */
	            this._removeScope = wtfCreateScope('ViewContainerRef#remove()');
	            /** @internal */
	            this._detachScope = wtfCreateScope('ViewContainerRef#detach()');
	        }
	        /**
	         * @param {?} index
	         * @return {?}
	         */
	        ViewContainerRef_.prototype.get = function (index) { return this._element.nestedViews[index].ref; };
	        Object.defineProperty(ViewContainerRef_.prototype, "length", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                var /** @type {?} */ views = this._element.nestedViews;
	                return isPresent(views) ? views.length : 0;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ViewContainerRef_.prototype, "element", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._element.elementRef; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ViewContainerRef_.prototype, "injector", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._element.injector; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ViewContainerRef_.prototype, "parentInjector", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._element.parentInjector; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} templateRef
	         * @param {?=} context
	         * @param {?=} index
	         * @return {?}
	         */
	        ViewContainerRef_.prototype.createEmbeddedView = function (templateRef, context, index) {
	            if (context === void 0) { context = null; }
	            if (index === void 0) { index = -1; }
	            var /** @type {?} */ viewRef = templateRef.createEmbeddedView(context);
	            this.insert(viewRef, index);
	            return viewRef;
	        };
	        /**
	         * @param {?} componentFactory
	         * @param {?=} index
	         * @param {?=} injector
	         * @param {?=} projectableNodes
	         * @return {?}
	         */
	        ViewContainerRef_.prototype.createComponent = function (componentFactory, index, injector, projectableNodes) {
	            if (index === void 0) { index = -1; }
	            if (injector === void 0) { injector = null; }
	            if (projectableNodes === void 0) { projectableNodes = null; }
	            var /** @type {?} */ s = this._createComponentInContainerScope();
	            var /** @type {?} */ contextInjector = injector || this._element.parentInjector;
	            var /** @type {?} */ componentRef = componentFactory.create(contextInjector, projectableNodes);
	            this.insert(componentRef.hostView, index);
	            return wtfLeave(s, componentRef);
	        };
	        /**
	         * @param {?} viewRef
	         * @param {?=} index
	         * @return {?}
	         */
	        ViewContainerRef_.prototype.insert = function (viewRef, index) {
	            if (index === void 0) { index = -1; }
	            var /** @type {?} */ s = this._insertScope();
	            if (index == -1)
	                index = this.length;
	            var /** @type {?} */ viewRef_ = (viewRef);
	            this._element.attachView(viewRef_.internalView, index);
	            return wtfLeave(s, viewRef_);
	        };
	        /**
	         * @param {?} viewRef
	         * @param {?} currentIndex
	         * @return {?}
	         */
	        ViewContainerRef_.prototype.move = function (viewRef, currentIndex) {
	            var /** @type {?} */ s = this._insertScope();
	            if (currentIndex == -1)
	                return;
	            var /** @type {?} */ viewRef_ = (viewRef);
	            this._element.moveView(viewRef_.internalView, currentIndex);
	            return wtfLeave(s, viewRef_);
	        };
	        /**
	         * @param {?} viewRef
	         * @return {?}
	         */
	        ViewContainerRef_.prototype.indexOf = function (viewRef) {
	            return this._element.nestedViews.indexOf(((viewRef)).internalView);
	        };
	        /**
	         * @param {?=} index
	         * @return {?}
	         */
	        ViewContainerRef_.prototype.remove = function (index) {
	            if (index === void 0) { index = -1; }
	            var /** @type {?} */ s = this._removeScope();
	            if (index == -1)
	                index = this.length - 1;
	            var /** @type {?} */ view = this._element.detachView(index);
	            view.destroy();
	            // view is intentionally not returned to the client.
	            wtfLeave(s);
	        };
	        /**
	         * @param {?=} index
	         * @return {?}
	         */
	        ViewContainerRef_.prototype.detach = function (index) {
	            if (index === void 0) { index = -1; }
	            var /** @type {?} */ s = this._detachScope();
	            if (index == -1)
	                index = this.length - 1;
	            var /** @type {?} */ view = this._element.detachView(index);
	            return wtfLeave(s, view.ref);
	        };
	        /**
	         * @return {?}
	         */
	        ViewContainerRef_.prototype.clear = function () {
	            for (var /** @type {?} */ i = this.length - 1; i >= 0; i--) {
	                this.remove(i);
	            }
	        };
	        return ViewContainerRef_;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$11 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * \@stable
	     * @abstract
	     */
	    var ViewRef = (function (_super) {
	        __extends$11(ViewRef, _super);
	        function ViewRef() {
	            _super.apply(this, arguments);
	        }
	        /**
	         * Destroys the view and all of the data structures associated with it.
	         * @abstract
	         * @return {?}
	         */
	        ViewRef.prototype.destroy = function () { };
	        Object.defineProperty(ViewRef.prototype, "destroyed", {
	            /**
	             * @return {?}
	             */
	            get: function () { return (unimplemented()); },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @abstract
	         * @param {?} callback
	         * @return {?}
	         */
	        ViewRef.prototype.onDestroy = function (callback) { };
	        return ViewRef;
	    }(ChangeDetectorRef));
	    /**
	     * Represents an Angular View.
	     *
	     * <!-- TODO: move the next two paragraphs to the dev guide -->
	     * A View is a fundamental building block of the application UI. It is the smallest grouping of
	     * Elements which are created and destroyed together.
	     *
	     * Properties of elements in a View can change, but the structure (number and order) of elements in
	     * a View cannot. Changing the structure of Elements can only be done by inserting, moving or
	     * removing nested Views via a {\@link ViewContainerRef}. Each View can contain many View Containers.
	     * <!-- /TODO -->
	     *
	     * ### Example
	     *
	     * Given this template...
	     *
	     * ```
	     * Count: {{items.length}}
	     * <ul>
	     *   <li *ngFor="let  item of items">{{item}}</li>
	     * </ul>
	     * ```
	     *
	     * We have two {\@link TemplateRef}s:
	     *
	     * Outer {\@link TemplateRef}:
	     * ```
	     * Count: {{items.length}}
	     * <ul>
	     *   <template ngFor let-item [ngForOf]="items"></template>
	     * </ul>
	     * ```
	     *
	     * Inner {\@link TemplateRef}:
	     * ```
	     *   <li>{{item}}</li>
	     * ```
	     *
	     * Notice that the original template is broken down into two separate {\@link TemplateRef}s.
	     *
	     * The outer/inner {\@link TemplateRef}s are then assembled into views like so:
	     *
	     * ```
	     * <!-- ViewRef: outer-0 -->
	     * Count: 2
	     * <ul>
	     *   <template view-container-ref></template>
	     *   <!-- ViewRef: inner-1 --><li>first</li><!-- /ViewRef: inner-1 -->
	     *   <!-- ViewRef: inner-2 --><li>second</li><!-- /ViewRef: inner-2 -->
	     * </ul>
	     * <!-- /ViewRef: outer-0 -->
	     * ```
	     * \@experimental
	     * @abstract
	     */
	    var EmbeddedViewRef = (function (_super) {
	        __extends$11(EmbeddedViewRef, _super);
	        function EmbeddedViewRef() {
	            _super.apply(this, arguments);
	        }
	        Object.defineProperty(EmbeddedViewRef.prototype, "context", {
	            /**
	             * @return {?}
	             */
	            get: function () { return unimplemented(); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(EmbeddedViewRef.prototype, "rootNodes", {
	            /**
	             * @return {?}
	             */
	            get: function () { return (unimplemented()); },
	            enumerable: true,
	            configurable: true
	        });
	        ;
	        return EmbeddedViewRef;
	    }(ViewRef));
	    var ViewRef_ = (function () {
	        /**
	         * @param {?} _view
	         * @param {?} animationQueue
	         */
	        function ViewRef_(_view, animationQueue) {
	            this._view = _view;
	            this.animationQueue = animationQueue;
	            this._view = _view;
	            this._originalMode = this._view.cdMode;
	        }
	        Object.defineProperty(ViewRef_.prototype, "internalView", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._view; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ViewRef_.prototype, "rootNodes", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._view.flatRootNodes; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ViewRef_.prototype, "context", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._view.context; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ViewRef_.prototype, "destroyed", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._view.destroyed; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        ViewRef_.prototype.markForCheck = function () { this._view.markPathToRootAsCheckOnce(); };
	        /**
	         * @return {?}
	         */
	        ViewRef_.prototype.detach = function () { this._view.cdMode = ChangeDetectorStatus.Detached; };
	        /**
	         * @return {?}
	         */
	        ViewRef_.prototype.detectChanges = function () {
	            this._view.detectChanges(false);
	            this.animationQueue.flush();
	        };
	        /**
	         * @return {?}
	         */
	        ViewRef_.prototype.checkNoChanges = function () { this._view.detectChanges(true); };
	        /**
	         * @return {?}
	         */
	        ViewRef_.prototype.reattach = function () {
	            this._view.cdMode = this._originalMode;
	            this.markForCheck();
	        };
	        /**
	         * @param {?} callback
	         * @return {?}
	         */
	        ViewRef_.prototype.onDestroy = function (callback) {
	            if (!this._view.disposables) {
	                this._view.disposables = [];
	            }
	            this._view.disposables.push(callback);
	        };
	        /**
	         * @return {?}
	         */
	        ViewRef_.prototype.destroy = function () { this._view.detachAndDestroy(); };
	        return ViewRef_;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$12 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var EventListener = (function () {
	        /**
	         * @param {?} name
	         * @param {?} callback
	         */
	        function EventListener(name, callback) {
	            this.name = name;
	            this.callback = callback;
	        }
	        ;
	        return EventListener;
	    }());
	    /**
	     * \@experimental All debugging apis are currently experimental.
	     */
	    var DebugNode = (function () {
	        /**
	         * @param {?} nativeNode
	         * @param {?} parent
	         * @param {?} _debugInfo
	         */
	        function DebugNode(nativeNode, parent, _debugInfo) {
	            this._debugInfo = _debugInfo;
	            this.nativeNode = nativeNode;
	            if (parent && parent instanceof DebugElement) {
	                parent.addChild(this);
	            }
	            else {
	                this.parent = null;
	            }
	            this.listeners = [];
	        }
	        Object.defineProperty(DebugNode.prototype, "injector", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._debugInfo ? this._debugInfo.injector : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugNode.prototype, "componentInstance", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._debugInfo ? this._debugInfo.component : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugNode.prototype, "context", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._debugInfo ? this._debugInfo.context : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugNode.prototype, "references", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return this._debugInfo ? this._debugInfo.references : null;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugNode.prototype, "providerTokens", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._debugInfo ? this._debugInfo.providerTokens : null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugNode.prototype, "source", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._debugInfo ? this._debugInfo.source : null; },
	            enumerable: true,
	            configurable: true
	        });
	        return DebugNode;
	    }());
	    /**
	     * \@experimental All debugging apis are currently experimental.
	     */
	    var DebugElement = (function (_super) {
	        __extends$12(DebugElement, _super);
	        /**
	         * @param {?} nativeNode
	         * @param {?} parent
	         * @param {?} _debugInfo
	         */
	        function DebugElement(nativeNode, parent, _debugInfo) {
	            _super.call(this, nativeNode, parent, _debugInfo);
	            this.properties = {};
	            this.attributes = {};
	            this.classes = {};
	            this.styles = {};
	            this.childNodes = [];
	            this.nativeElement = nativeNode;
	        }
	        /**
	         * @param {?} child
	         * @return {?}
	         */
	        DebugElement.prototype.addChild = function (child) {
	            if (child) {
	                this.childNodes.push(child);
	                child.parent = this;
	            }
	        };
	        /**
	         * @param {?} child
	         * @return {?}
	         */
	        DebugElement.prototype.removeChild = function (child) {
	            var /** @type {?} */ childIndex = this.childNodes.indexOf(child);
	            if (childIndex !== -1) {
	                child.parent = null;
	                this.childNodes.splice(childIndex, 1);
	            }
	        };
	        /**
	         * @param {?} child
	         * @param {?} newChildren
	         * @return {?}
	         */
	        DebugElement.prototype.insertChildrenAfter = function (child, newChildren) {
	            var /** @type {?} */ siblingIndex = this.childNodes.indexOf(child);
	            if (siblingIndex !== -1) {
	                var /** @type {?} */ previousChildren = this.childNodes.slice(0, siblingIndex + 1);
	                var /** @type {?} */ nextChildren = this.childNodes.slice(siblingIndex + 1);
	                this.childNodes = previousChildren.concat(newChildren, nextChildren);
	                for (var /** @type {?} */ i = 0; i < newChildren.length; ++i) {
	                    var /** @type {?} */ newChild = newChildren[i];
	                    if (newChild.parent) {
	                        newChild.parent.removeChild(newChild);
	                    }
	                    newChild.parent = this;
	                }
	            }
	        };
	        /**
	         * @param {?} predicate
	         * @return {?}
	         */
	        DebugElement.prototype.query = function (predicate) {
	            var /** @type {?} */ results = this.queryAll(predicate);
	            return results[0] || null;
	        };
	        /**
	         * @param {?} predicate
	         * @return {?}
	         */
	        DebugElement.prototype.queryAll = function (predicate) {
	            var /** @type {?} */ matches = [];
	            _queryElementChildren(this, predicate, matches);
	            return matches;
	        };
	        /**
	         * @param {?} predicate
	         * @return {?}
	         */
	        DebugElement.prototype.queryAllNodes = function (predicate) {
	            var /** @type {?} */ matches = [];
	            _queryNodeChildren(this, predicate, matches);
	            return matches;
	        };
	        Object.defineProperty(DebugElement.prototype, "children", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return (this.childNodes.filter(function (node) { return node instanceof DebugElement; }));
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} eventName
	         * @param {?} eventObj
	         * @return {?}
	         */
	        DebugElement.prototype.triggerEventHandler = function (eventName, eventObj) {
	            this.listeners.forEach(function (listener) {
	                if (listener.name == eventName) {
	                    listener.callback(eventObj);
	                }
	            });
	        };
	        return DebugElement;
	    }(DebugNode));
	    /**
	     * \@experimental
	     * @param {?} debugEls
	     * @return {?}
	     */
	    function asNativeElements(debugEls) {
	        return debugEls.map(function (el) { return el.nativeElement; });
	    }
	    /**
	     * @param {?} element
	     * @param {?} predicate
	     * @param {?} matches
	     * @return {?}
	     */
	    function _queryElementChildren(element, predicate, matches) {
	        element.childNodes.forEach(function (node) {
	            if (node instanceof DebugElement) {
	                if (predicate(node)) {
	                    matches.push(node);
	                }
	                _queryElementChildren(node, predicate, matches);
	            }
	        });
	    }
	    /**
	     * @param {?} parentNode
	     * @param {?} predicate
	     * @param {?} matches
	     * @return {?}
	     */
	    function _queryNodeChildren(parentNode, predicate, matches) {
	        if (parentNode instanceof DebugElement) {
	            parentNode.childNodes.forEach(function (node) {
	                if (predicate(node)) {
	                    matches.push(node);
	                }
	                if (node instanceof DebugElement) {
	                    _queryNodeChildren(node, predicate, matches);
	                }
	            });
	        }
	    }
	    // Need to keep the nodes in a global Map so that multiple angular apps are supported.
	    var /** @type {?} */ _nativeNodeToDebugNode = new Map();
	    /**
	     * \@experimental
	     * @param {?} nativeNode
	     * @return {?}
	     */
	    function getDebugNode(nativeNode) {
	        return _nativeNodeToDebugNode.get(nativeNode);
	    }
	    /**
	     * @param {?} node
	     * @return {?}
	     */
	    function indexDebugNode(node) {
	        _nativeNodeToDebugNode.set(node.nativeNode, node);
	    }
	    /**
	     * @param {?} node
	     * @return {?}
	     */
	    function removeDebugNodeFromIndex(node) {
	        _nativeNodeToDebugNode.delete(node.nativeNode);
	    }

	    /**
	     * @return {?}
	     */
	    function _reflector() {
	        return reflector;
	    }
	    var /** @type {?} */ _CORE_PLATFORM_PROVIDERS = [
	        PlatformRef_,
	        { provide: PlatformRef, useExisting: PlatformRef_ },
	        { provide: Reflector, useFactory: _reflector, deps: [] },
	        { provide: ReflectorReader, useExisting: Reflector },
	        TestabilityRegistry,
	        Console,
	    ];
	    /**
	     * This platform has to be included in any other platform
	     *
	     * @experimental
	     */
	    var /** @type {?} */ platformCore = createPlatformFactory(null, 'core', _CORE_PLATFORM_PROVIDERS);

	    /**
	     * @experimental i18n support is experimental.
	     */
	    var /** @type {?} */ LOCALE_ID = new OpaqueToken('LocaleId');
	    /**
	     * @experimental i18n support is experimental.
	     */
	    var /** @type {?} */ TRANSLATIONS = new OpaqueToken('Translations');
	    /**
	     * @experimental i18n support is experimental.
	     */
	    var /** @type {?} */ TRANSLATIONS_FORMAT = new OpaqueToken('TranslationsFormat');

	    /**
	     * @return {?}
	     */
	    function _iterableDiffersFactory() {
	        return defaultIterableDiffers;
	    }
	    /**
	     * @return {?}
	     */
	    function _keyValueDiffersFactory() {
	        return defaultKeyValueDiffers;
	    }
	    /**
	     * @param {?=} locale
	     * @return {?}
	     */
	    function _localeFactory(locale) {
	        return locale || 'en-US';
	    }
	    /**
	     * This module includes the providers of \@angular/core that are needed
	     * to bootstrap components via `ApplicationRef`.
	     *
	     * \@experimental
	     */
	    var ApplicationModule = (function () {
	        function ApplicationModule() {
	        }
	        ApplicationModule.decorators = [
	            { type: NgModule, args: [{
	                        providers: [
	                            ApplicationRef_,
	                            { provide: ApplicationRef, useExisting: ApplicationRef_ },
	                            ApplicationInitStatus,
	                            Compiler,
	                            APP_ID_RANDOM_PROVIDER,
	                            ViewUtils,
	                            AnimationQueue,
	                            { provide: IterableDiffers, useFactory: _iterableDiffersFactory },
	                            { provide: KeyValueDiffers, useFactory: _keyValueDiffersFactory },
	                            {
	                                provide: LOCALE_ID,
	                                useFactory: _localeFactory,
	                                deps: [[new Inject(LOCALE_ID), new Optional(), new SkipSelf()]]
	                            },
	                        ]
	                    },] },
	        ];
	        /** @nocollapse */
	        ApplicationModule.ctorParameters = function () { return []; };
	        return ApplicationModule;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var /** @type {?} */ FILL_STYLE_FLAG = 'true'; // TODO (matsko): change to boolean
	    var /** @type {?} */ ANY_STATE = '*';
	    var /** @type {?} */ DEFAULT_STATE = '*';
	    var /** @type {?} */ EMPTY_STATE = 'void';

	    var AnimationGroupPlayer = (function () {
	        /**
	         * @param {?} _players
	         */
	        function AnimationGroupPlayer(_players) {
	            var _this = this;
	            this._players = _players;
	            this._onDoneFns = [];
	            this._onStartFns = [];
	            this._finished = false;
	            this._started = false;
	            this._destroyed = false;
	            this.parentPlayer = null;
	            var count = 0;
	            var total = this._players.length;
	            if (total == 0) {
	                scheduleMicroTask(function () { return _this._onFinish(); });
	            }
	            else {
	                this._players.forEach(function (player) {
	                    player.parentPlayer = _this;
	                    player.onDone(function () {
	                        if (++count >= total) {
	                            _this._onFinish();
	                        }
	                    });
	                });
	            }
	        }
	        /**
	         * @return {?}
	         */
	        AnimationGroupPlayer.prototype._onFinish = function () {
	            if (!this._finished) {
	                this._finished = true;
	                this._onDoneFns.forEach(function (fn) { return fn(); });
	                this._onDoneFns = [];
	            }
	        };
	        /**
	         * @return {?}
	         */
	        AnimationGroupPlayer.prototype.init = function () { this._players.forEach(function (player) { return player.init(); }); };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        AnimationGroupPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        AnimationGroupPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };
	        /**
	         * @return {?}
	         */
	        AnimationGroupPlayer.prototype.hasStarted = function () { return this._started; };
	        /**
	         * @return {?}
	         */
	        AnimationGroupPlayer.prototype.play = function () {
	            if (!isPresent(this.parentPlayer)) {
	                this.init();
	            }
	            if (!this.hasStarted()) {
	                this._onStartFns.forEach(function (fn) { return fn(); });
	                this._onStartFns = [];
	                this._started = true;
	            }
	            this._players.forEach(function (player) { return player.play(); });
	        };
	        /**
	         * @return {?}
	         */
	        AnimationGroupPlayer.prototype.pause = function () { this._players.forEach(function (player) { return player.pause(); }); };
	        /**
	         * @return {?}
	         */
	        AnimationGroupPlayer.prototype.restart = function () { this._players.forEach(function (player) { return player.restart(); }); };
	        /**
	         * @return {?}
	         */
	        AnimationGroupPlayer.prototype.finish = function () {
	            this._onFinish();
	            this._players.forEach(function (player) { return player.finish(); });
	        };
	        /**
	         * @return {?}
	         */
	        AnimationGroupPlayer.prototype.destroy = function () {
	            if (!this._destroyed) {
	                this._onFinish();
	                this._players.forEach(function (player) { return player.destroy(); });
	                this._destroyed = true;
	            }
	        };
	        /**
	         * @return {?}
	         */
	        AnimationGroupPlayer.prototype.reset = function () {
	            this._players.forEach(function (player) { return player.reset(); });
	            this._destroyed = false;
	            this._finished = false;
	            this._started = false;
	        };
	        /**
	         * @param {?} p
	         * @return {?}
	         */
	        AnimationGroupPlayer.prototype.setPosition = function (p) {
	            this._players.forEach(function (player) { player.setPosition(p); });
	        };
	        /**
	         * @return {?}
	         */
	        AnimationGroupPlayer.prototype.getPosition = function () {
	            var /** @type {?} */ min = 0;
	            this._players.forEach(function (player) {
	                var /** @type {?} */ p = player.getPosition();
	                min = Math.min(p, min);
	            });
	            return min;
	        };
	        Object.defineProperty(AnimationGroupPlayer.prototype, "players", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._players; },
	            enumerable: true,
	            configurable: true
	        });
	        return AnimationGroupPlayer;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var AnimationKeyframe = (function () {
	        /**
	         * @param {?} offset
	         * @param {?} styles
	         */
	        function AnimationKeyframe(offset, styles) {
	            this.offset = offset;
	            this.styles = styles;
	        }
	        return AnimationKeyframe;
	    }());

	    /**
	     * \@experimental Animation support is experimental.
	     * @abstract
	     */
	    var AnimationPlayer = (function () {
	        function AnimationPlayer() {
	        }
	        /**
	         * @abstract
	         * @param {?} fn
	         * @return {?}
	         */
	        AnimationPlayer.prototype.onDone = function (fn) { };
	        /**
	         * @abstract
	         * @param {?} fn
	         * @return {?}
	         */
	        AnimationPlayer.prototype.onStart = function (fn) { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        AnimationPlayer.prototype.init = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        AnimationPlayer.prototype.hasStarted = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        AnimationPlayer.prototype.play = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        AnimationPlayer.prototype.pause = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        AnimationPlayer.prototype.restart = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        AnimationPlayer.prototype.finish = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        AnimationPlayer.prototype.destroy = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        AnimationPlayer.prototype.reset = function () { };
	        /**
	         * @abstract
	         * @param {?} p
	         * @return {?}
	         */
	        AnimationPlayer.prototype.setPosition = function (p) { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        AnimationPlayer.prototype.getPosition = function () { };
	        Object.defineProperty(AnimationPlayer.prototype, "parentPlayer", {
	            /**
	             * @return {?}
	             */
	            get: function () { throw new Error('NOT IMPLEMENTED: Base Class'); },
	            /**
	             * @param {?} player
	             * @return {?}
	             */
	            set: function (player) { throw new Error('NOT IMPLEMENTED: Base Class'); },
	            enumerable: true,
	            configurable: true
	        });
	        return AnimationPlayer;
	    }());
	    var NoOpAnimationPlayer = (function () {
	        function NoOpAnimationPlayer() {
	            var _this = this;
	            this._onDoneFns = [];
	            this._onStartFns = [];
	            this._started = false;
	            this.parentPlayer = null;
	            scheduleMicroTask(function () { return _this._onFinish(); });
	        }
	        /**
	         * \@internal
	         * @return {?}
	         */
	        NoOpAnimationPlayer.prototype._onFinish = function () {
	            this._onDoneFns.forEach(function (fn) { return fn(); });
	            this._onDoneFns = [];
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        NoOpAnimationPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        NoOpAnimationPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };
	        /**
	         * @return {?}
	         */
	        NoOpAnimationPlayer.prototype.hasStarted = function () { return this._started; };
	        /**
	         * @return {?}
	         */
	        NoOpAnimationPlayer.prototype.init = function () { };
	        /**
	         * @return {?}
	         */
	        NoOpAnimationPlayer.prototype.play = function () {
	            if (!this.hasStarted()) {
	                this._onStartFns.forEach(function (fn) { return fn(); });
	                this._onStartFns = [];
	            }
	            this._started = true;
	        };
	        /**
	         * @return {?}
	         */
	        NoOpAnimationPlayer.prototype.pause = function () { };
	        /**
	         * @return {?}
	         */
	        NoOpAnimationPlayer.prototype.restart = function () { };
	        /**
	         * @return {?}
	         */
	        NoOpAnimationPlayer.prototype.finish = function () { this._onFinish(); };
	        /**
	         * @return {?}
	         */
	        NoOpAnimationPlayer.prototype.destroy = function () { };
	        /**
	         * @return {?}
	         */
	        NoOpAnimationPlayer.prototype.reset = function () { };
	        /**
	         * @param {?} p
	         * @return {?}
	         */
	        NoOpAnimationPlayer.prototype.setPosition = function (p) { };
	        /**
	         * @return {?}
	         */
	        NoOpAnimationPlayer.prototype.getPosition = function () { return 0; };
	        return NoOpAnimationPlayer;
	    }());

	    var AnimationSequencePlayer = (function () {
	        /**
	         * @param {?} _players
	         */
	        function AnimationSequencePlayer(_players) {
	            var _this = this;
	            this._players = _players;
	            this._currentIndex = 0;
	            this._onDoneFns = [];
	            this._onStartFns = [];
	            this._finished = false;
	            this._started = false;
	            this._destroyed = false;
	            this.parentPlayer = null;
	            this._players.forEach(function (player) { player.parentPlayer = _this; });
	            this._onNext(false);
	        }
	        /**
	         * @param {?} start
	         * @return {?}
	         */
	        AnimationSequencePlayer.prototype._onNext = function (start) {
	            var _this = this;
	            if (this._finished)
	                return;
	            if (this._players.length == 0) {
	                this._activePlayer = new NoOpAnimationPlayer();
	                scheduleMicroTask(function () { return _this._onFinish(); });
	            }
	            else if (this._currentIndex >= this._players.length) {
	                this._activePlayer = new NoOpAnimationPlayer();
	                this._onFinish();
	            }
	            else {
	                var /** @type {?} */ player = this._players[this._currentIndex++];
	                player.onDone(function () { return _this._onNext(true); });
	                this._activePlayer = player;
	                if (start) {
	                    player.play();
	                }
	            }
	        };
	        /**
	         * @return {?}
	         */
	        AnimationSequencePlayer.prototype._onFinish = function () {
	            if (!this._finished) {
	                this._finished = true;
	                this._onDoneFns.forEach(function (fn) { return fn(); });
	                this._onDoneFns = [];
	            }
	        };
	        /**
	         * @return {?}
	         */
	        AnimationSequencePlayer.prototype.init = function () { this._players.forEach(function (player) { return player.init(); }); };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        AnimationSequencePlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        AnimationSequencePlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };
	        /**
	         * @return {?}
	         */
	        AnimationSequencePlayer.prototype.hasStarted = function () { return this._started; };
	        /**
	         * @return {?}
	         */
	        AnimationSequencePlayer.prototype.play = function () {
	            if (!isPresent(this.parentPlayer)) {
	                this.init();
	            }
	            if (!this.hasStarted()) {
	                this._onStartFns.forEach(function (fn) { return fn(); });
	                this._onStartFns = [];
	                this._started = true;
	            }
	            this._activePlayer.play();
	        };
	        /**
	         * @return {?}
	         */
	        AnimationSequencePlayer.prototype.pause = function () { this._activePlayer.pause(); };
	        /**
	         * @return {?}
	         */
	        AnimationSequencePlayer.prototype.restart = function () {
	            this.reset();
	            if (this._players.length > 0) {
	                this._players[0].restart();
	            }
	        };
	        /**
	         * @return {?}
	         */
	        AnimationSequencePlayer.prototype.reset = function () {
	            this._players.forEach(function (player) { return player.reset(); });
	            this._destroyed = false;
	            this._finished = false;
	            this._started = false;
	        };
	        /**
	         * @return {?}
	         */
	        AnimationSequencePlayer.prototype.finish = function () {
	            this._onFinish();
	            this._players.forEach(function (player) { return player.finish(); });
	        };
	        /**
	         * @return {?}
	         */
	        AnimationSequencePlayer.prototype.destroy = function () {
	            if (!this._destroyed) {
	                this._onFinish();
	                this._players.forEach(function (player) { return player.destroy(); });
	                this._destroyed = true;
	                this._activePlayer = new NoOpAnimationPlayer();
	            }
	        };
	        /**
	         * @param {?} p
	         * @return {?}
	         */
	        AnimationSequencePlayer.prototype.setPosition = function (p) { this._players[0].setPosition(p); };
	        /**
	         * @return {?}
	         */
	        AnimationSequencePlayer.prototype.getPosition = function () { return this._players[0].getPosition(); };
	        Object.defineProperty(AnimationSequencePlayer.prototype, "players", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._players; },
	            enumerable: true,
	            configurable: true
	        });
	        return AnimationSequencePlayer;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$13 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * @experimental Animation support is experimental.
	     */
	    var /** @type {?} */ AUTO_STYLE = '*';
	    /**
	     * Metadata representing the entry of animations.
	     * Instances of this class are provided via the animation DSL when the {\@link trigger trigger
	     * animation function} is called.
	     *
	     * \@experimental Animation support is experimental.
	     */
	    var AnimationEntryMetadata = (function () {
	        /**
	         * @param {?} name
	         * @param {?} definitions
	         */
	        function AnimationEntryMetadata(name, definitions) {
	            this.name = name;
	            this.definitions = definitions;
	        }
	        return AnimationEntryMetadata;
	    }());
	    /**
	     * \@experimental Animation support is experimental.
	     * @abstract
	     */
	    var AnimationStateMetadata = (function () {
	        function AnimationStateMetadata() {
	        }
	        return AnimationStateMetadata;
	    }());
	    /**
	     * Metadata representing the entry of animations.
	     * Instances of this class are provided via the animation DSL when the {\@link state state animation
	     * function} is called.
	     *
	     * \@experimental Animation support is experimental.
	     */
	    var AnimationStateDeclarationMetadata = (function (_super) {
	        __extends$13(AnimationStateDeclarationMetadata, _super);
	        /**
	         * @param {?} stateNameExpr
	         * @param {?} styles
	         */
	        function AnimationStateDeclarationMetadata(stateNameExpr, styles) {
	            _super.call(this);
	            this.stateNameExpr = stateNameExpr;
	            this.styles = styles;
	        }
	        return AnimationStateDeclarationMetadata;
	    }(AnimationStateMetadata));
	    /**
	     * Metadata representing the entry of animations.
	     * Instances of this class are provided via the animation DSL when the
	     * {\@link transition transition animation function} is called.
	     *
	     * \@experimental Animation support is experimental.
	     */
	    var AnimationStateTransitionMetadata = (function (_super) {
	        __extends$13(AnimationStateTransitionMetadata, _super);
	        /**
	         * @param {?} stateChangeExpr
	         * @param {?} steps
	         */
	        function AnimationStateTransitionMetadata(stateChangeExpr, steps) {
	            _super.call(this);
	            this.stateChangeExpr = stateChangeExpr;
	            this.steps = steps;
	        }
	        return AnimationStateTransitionMetadata;
	    }(AnimationStateMetadata));
	    /**
	     * \@experimental Animation support is experimental.
	     * @abstract
	     */
	    var AnimationMetadata = (function () {
	        function AnimationMetadata() {
	        }
	        return AnimationMetadata;
	    }());
	    /**
	     * Metadata representing the entry of animations.
	     * Instances of this class are provided via the animation DSL when the {\@link keyframes keyframes
	     * animation function} is called.
	     *
	     * \@experimental Animation support is experimental.
	     */
	    var AnimationKeyframesSequenceMetadata = (function (_super) {
	        __extends$13(AnimationKeyframesSequenceMetadata, _super);
	        /**
	         * @param {?} steps
	         */
	        function AnimationKeyframesSequenceMetadata(steps) {
	            _super.call(this);
	            this.steps = steps;
	        }
	        return AnimationKeyframesSequenceMetadata;
	    }(AnimationMetadata));
	    /**
	     * Metadata representing the entry of animations.
	     * Instances of this class are provided via the animation DSL when the {\@link style style animation
	     * function} is called.
	     *
	     * \@experimental Animation support is experimental.
	     */
	    var AnimationStyleMetadata = (function (_super) {
	        __extends$13(AnimationStyleMetadata, _super);
	        /**
	         * @param {?} styles
	         * @param {?=} offset
	         */
	        function AnimationStyleMetadata(styles, offset) {
	            if (offset === void 0) { offset = null; }
	            _super.call(this);
	            this.styles = styles;
	            this.offset = offset;
	        }
	        return AnimationStyleMetadata;
	    }(AnimationMetadata));
	    /**
	     * Metadata representing the entry of animations.
	     * Instances of this class are provided via the animation DSL when the {\@link animate animate
	     * animation function} is called.
	     *
	     * \@experimental Animation support is experimental.
	     */
	    var AnimationAnimateMetadata = (function (_super) {
	        __extends$13(AnimationAnimateMetadata, _super);
	        /**
	         * @param {?} timings
	         * @param {?} styles
	         */
	        function AnimationAnimateMetadata(timings, styles) {
	            _super.call(this);
	            this.timings = timings;
	            this.styles = styles;
	        }
	        return AnimationAnimateMetadata;
	    }(AnimationMetadata));
	    /**
	     * \@experimental Animation support is experimental.
	     * @abstract
	     */
	    var AnimationWithStepsMetadata = (function (_super) {
	        __extends$13(AnimationWithStepsMetadata, _super);
	        function AnimationWithStepsMetadata() {
	            _super.call(this);
	        }
	        Object.defineProperty(AnimationWithStepsMetadata.prototype, "steps", {
	            /**
	             * @return {?}
	             */
	            get: function () { throw new Error('NOT IMPLEMENTED: Base Class'); },
	            enumerable: true,
	            configurable: true
	        });
	        return AnimationWithStepsMetadata;
	    }(AnimationMetadata));
	    /**
	     * Metadata representing the entry of animations.
	     * Instances of this class are provided via the animation DSL when the {\@link sequence sequence
	     * animation function} is called.
	     *
	     * \@experimental Animation support is experimental.
	     */
	    var AnimationSequenceMetadata = (function (_super) {
	        __extends$13(AnimationSequenceMetadata, _super);
	        /**
	         * @param {?} _steps
	         */
	        function AnimationSequenceMetadata(_steps) {
	            _super.call(this);
	            this._steps = _steps;
	        }
	        Object.defineProperty(AnimationSequenceMetadata.prototype, "steps", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._steps; },
	            enumerable: true,
	            configurable: true
	        });
	        return AnimationSequenceMetadata;
	    }(AnimationWithStepsMetadata));
	    /**
	     * Metadata representing the entry of animations.
	     * Instances of this class are provided via the animation DSL when the {\@link group group animation
	     * function} is called.
	     *
	     * \@experimental Animation support is experimental.
	     */
	    var AnimationGroupMetadata = (function (_super) {
	        __extends$13(AnimationGroupMetadata, _super);
	        /**
	         * @param {?} _steps
	         */
	        function AnimationGroupMetadata(_steps) {
	            _super.call(this);
	            this._steps = _steps;
	        }
	        Object.defineProperty(AnimationGroupMetadata.prototype, "steps", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._steps; },
	            enumerable: true,
	            configurable: true
	        });
	        return AnimationGroupMetadata;
	    }(AnimationWithStepsMetadata));
	    /**
	     * `animate` is an animation-specific function that is designed to be used inside of Angular2's
	     * animation
	     * DSL language. If this information is new, please navigate to the
	     * {\@link Component#animations-anchor component animations metadata
	     * page} to gain a better understanding of how animations in Angular2 are used.
	     *
	     * `animate` specifies an animation step that will apply the provided `styles` data for a given
	     * amount of
	     * time based on the provided `timing` expression value. Calls to `animate` are expected to be
	     * used within {\@link sequence an animation sequence}, {\@link group group}, or {\@link transition
	     * transition}.
	     *
	     * ### Usage
	     *
	     * The `animate` function accepts two input parameters: `timing` and `styles`:
	     *
	     * - `timing` is a string based value that can be a combination of a duration with optional
	     * delay and easing values. The format for the expression breaks down to `duration delay easing`
	     * (therefore a value such as `1s 100ms ease-out` will be parse itself into `duration=1000,
	     * delay=100, easing=ease-out`.
	     * If a numeric value is provided then that will be used as the `duration` value in millisecond
	     * form.
	     * - `styles` is the style input data which can either be a call to {\@link style style} or {\@link
	     * keyframes keyframes}.
	     * If left empty then the styles from the destination state will be collected and used (this is
	     * useful when
	     * describing an animation step that will complete an animation by {\@link
	     * transition#the-final-animate-call animating to the final state}).
	     *
	     * ```typescript
	     * // various functions for specifying timing data
	     * animate(500, style(...))
	     * animate("1s", style(...))
	     * animate("100ms 0.5s", style(...))
	     * animate("5s ease", style(...))
	     * animate("5s 10ms cubic-bezier(.17,.67,.88,.1)", style(...))
	     *
	     * // either style() of keyframes() can be used
	     * animate(500, style({ background: "red" }))
	     * animate(500, keyframes([
	     *   style({ background: "blue" })),
	     *   style({ background: "red" }))
	     * ])
	     * ```
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	     *
	     * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
	     *
	     * \@experimental Animation support is experimental.
	     * @param {?} timing
	     * @param {?=} styles
	     * @return {?}
	     */
	    function animate(timing, styles) {
	        if (styles === void 0) { styles = null; }
	        var /** @type {?} */ stylesEntry = styles;
	        if (!isPresent(stylesEntry)) {
	            var /** @type {?} */ EMPTY_STYLE = {};
	            stylesEntry = new AnimationStyleMetadata([EMPTY_STYLE], 1);
	        }
	        return new AnimationAnimateMetadata(timing, stylesEntry);
	    }
	    /**
	     * `group` is an animation-specific function that is designed to be used inside of Angular2's
	     * animation
	     * DSL language. If this information is new, please navigate to the
	     * {\@link Component#animations-anchor component animations metadata
	     * page} to gain a better understanding of how animations in Angular2 are used.
	     *
	     * `group` specifies a list of animation steps that are all run in parallel. Grouped animations
	     * are useful when a series of styles must be animated/closed off
	     * at different statrting/ending times.
	     *
	     * The `group` function can either be used within a {\@link sequence sequence} or a {\@link transition
	     * transition}
	     * and it will only continue to the next instruction once all of the inner animation steps
	     * have completed.
	     *
	     * ### Usage
	     *
	     * The `steps` data that is passed into the `group` animation function can either consist
	     * of {\@link style style} or {\@link animate animate} function calls. Each call to `style()` or
	     * `animate()`
	     * within a group will be executed instantly (use {\@link keyframes keyframes} or a
	     * {\@link animate#usage animate() with a delay value} to offset styles to be applied at a later
	     * time).
	     *
	     * ```typescript
	     * group([
	     *   animate("1s", { background: "black" }))
	     *   animate("2s", { color: "white" }))
	     * ])
	     * ```
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	     *
	     * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
	     *
	     * \@experimental Animation support is experimental.
	     * @param {?} steps
	     * @return {?}
	     */
	    function group(steps) {
	        return new AnimationGroupMetadata(steps);
	    }
	    /**
	     * `sequence` is an animation-specific function that is designed to be used inside of Angular2's
	     * animation
	     * DSL language. If this information is new, please navigate to the
	     * {\@link Component#animations-anchor component animations metadata
	     * page} to gain a better understanding of how animations in Angular2 are used.
	     *
	     * `sequence` Specifies a list of animation steps that are run one by one. (`sequence` is used
	     * by default when an array is passed as animation data into {\@link transition transition}.)
	     *
	     * The `sequence` function can either be used within a {\@link group group} or a {\@link transition
	     * transition}
	     * and it will only continue to the next instruction once each of the inner animation steps
	     * have completed.
	     *
	     * To perform animation styling in parallel with other animation steps then
	     * have a look at the {\@link group group} animation function.
	     *
	     * ### Usage
	     *
	     * The `steps` data that is passed into the `sequence` animation function can either consist
	     * of {\@link style style} or {\@link animate animate} function calls. A call to `style()` will apply
	     * the
	     * provided styling data immediately while a call to `animate()` will apply its styling
	     * data over a given time depending on its timing data.
	     *
	     * ```typescript
	     * sequence([
	     *   style({ opacity: 0 })),
	     *   animate("1s", { opacity: 1 }))
	     * ])
	     * ```
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	     *
	     * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
	     *
	     * \@experimental Animation support is experimental.
	     * @param {?} steps
	     * @return {?}
	     */
	    function sequence(steps) {
	        return new AnimationSequenceMetadata(steps);
	    }
	    /**
	     * `style` is an animation-specific function that is designed to be used inside of Angular2's
	     * animation
	     * DSL language. If this information is new, please navigate to the
	     * {\@link Component#animations-anchor component animations metadata
	     * page} to gain a better understanding of how animations in Angular2 are used.
	     *
	     * `style` declares a key/value object containing CSS properties/styles that can then
	     * be used for {\@link state animation states}, within an {\@link sequence animation sequence}, or as
	     * styling data for both {\@link animate animate} and {\@link keyframes keyframes}.
	     *
	     * ### Usage
	     *
	     * `style` takes in a key/value string map as data and expects one or more CSS property/value
	     * pairs to be defined.
	     *
	     * ```typescript
	     * // string values are used for css properties
	     * style({ background: "red", color: "blue" })
	     *
	     * // numerical (pixel) values are also supported
	     * style({ width: 100, height: 0 })
	     * ```
	     *
	     * #### Auto-styles (using `*`)
	     *
	     * When an asterix (`*`) character is used as a value then it will be detected from the element
	     * being animated
	     * and applied as animation data when the animation starts.
	     *
	     * This feature proves useful for a state depending on layout and/or environment factors; in such
	     * cases
	     * the styles are calculated just before the animation starts.
	     *
	     * ```typescript
	     * // the steps below will animate from 0 to the
	     * // actual height of the element
	     * style({ height: 0 }),
	     * animate("1s", style({ height: "*" }))
	     * ```
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	     *
	     * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
	     *
	     * \@experimental Animation support is experimental.
	     * @param {?} tokens
	     * @return {?}
	     */
	    function style(tokens) {
	        var /** @type {?} */ input;
	        var /** @type {?} */ offset = null;
	        if (typeof tokens === 'string') {
	            input = [(tokens)];
	        }
	        else {
	            if (Array.isArray(tokens)) {
	                input = (tokens);
	            }
	            else {
	                input = [(tokens)];
	            }
	            input.forEach(function (entry) {
	                var /** @type {?} */ entryOffset = ((entry) /** TODO #9100 */)['offset'];
	                if (isPresent(entryOffset)) {
	                    offset = offset == null ? parseFloat(entryOffset) : offset;
	                }
	            });
	        }
	        return new AnimationStyleMetadata(input, offset);
	    }
	    /**
	     * `state` is an animation-specific function that is designed to be used inside of Angular2's
	     * animation
	     * DSL language. If this information is new, please navigate to the
	     * {\@link Component#animations-anchor component animations metadata
	     * page} to gain a better understanding of how animations in Angular2 are used.
	     *
	     * `state` declares an animation state within the given trigger. When a state is
	     * active within a component then its associated styles will persist on
	     * the element that the trigger is attached to (even when the animation ends).
	     *
	     * To animate between states, have a look at the animation {\@link transition transition}
	     * DSL function. To register states to an animation trigger please have a look
	     * at the {\@link trigger trigger} function.
	     *
	     * #### The `void` state
	     *
	     * The `void` state value is a reserved word that angular uses to determine when the element is not
	     * apart
	     * of the application anymore (e.g. when an `ngIf` evaluates to false then the state of the
	     * associated element
	     * is void).
	     *
	     * #### The `*` (default) state
	     *
	     * The `*` state (when styled) is a fallback state that will be used if
	     * the state that is being animated is not declared within the trigger.
	     *
	     * ### Usage
	     *
	     * `state` will declare an animation state with its associated styles
	     * within the given trigger.
	     *
	     * - `stateNameExpr` can be one or more state names separated by commas.
	     * - `styles` refers to the {\@link style styling data} that will be persisted on the element once
	     * the state
	     * has been reached.
	     *
	     * ```typescript
	     * // "void" is a reserved name for a state and is used to represent
	     * // the state in which an element is detached from from the application.
	     * state("void", style({ height: 0 }))
	     *
	     * // user-defined states
	     * state("closed", style({ height: 0 }))
	     * state("open, visible", style({ height: "*" }))
	     * ```
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	     *
	     * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
	     *
	     * \@experimental Animation support is experimental.
	     * @param {?} stateNameExpr
	     * @param {?} styles
	     * @return {?}
	     */
	    function state(stateNameExpr, styles) {
	        return new AnimationStateDeclarationMetadata(stateNameExpr, styles);
	    }
	    /**
	     * `keyframes` is an animation-specific function that is designed to be used inside of Angular2's
	     * animation
	     * DSL language. If this information is new, please navigate to the
	     * {\@link Component#animations-anchor component animations metadata
	     * page} to gain a better understanding of how animations in Angular2 are used.
	     *
	     * `keyframes` specifies a collection of {\@link style style} entries each optionally characterized
	     * by an `offset` value.
	     *
	     * ### Usage
	     *
	     * The `keyframes` animation function is designed to be used alongside the {\@link animate animate}
	     * animation function. Instead of applying animations from where they are
	     * currently to their destination, keyframes can describe how each style entry is applied
	     * and at what point within the animation arc (much like CSS Keyframe Animations do).
	     *
	     * For each `style()` entry an `offset` value can be set. Doing so allows to specifiy at
	     * what percentage of the animate time the styles will be applied.
	     *
	     * ```typescript
	     * // the provided offset values describe when each backgroundColor value is applied.
	     * animate("5s", keyframes([
	     *   style({ backgroundColor: "red", offset: 0 }),
	     *   style({ backgroundColor: "blue", offset: 0.2 }),
	     *   style({ backgroundColor: "orange", offset: 0.3 }),
	     *   style({ backgroundColor: "black", offset: 1 })
	     * ]))
	     * ```
	     *
	     * Alternatively, if there are no `offset` values used within the style entries then the offsets
	     * will
	     * be calculated automatically.
	     *
	     * ```typescript
	     * animate("5s", keyframes([
	     *   style({ backgroundColor: "red" }) // offset = 0
	     *   style({ backgroundColor: "blue" }) // offset = 0.33
	     *   style({ backgroundColor: "orange" }) // offset = 0.66
	     *   style({ backgroundColor: "black" }) // offset = 1
	     * ]))
	     * ```
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	     *
	     * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
	     *
	     * \@experimental Animation support is experimental.
	     * @param {?} steps
	     * @return {?}
	     */
	    function keyframes(steps) {
	        return new AnimationKeyframesSequenceMetadata(steps);
	    }
	    /**
	     * `transition` is an animation-specific function that is designed to be used inside of Angular2's
	     * animation
	     * DSL language. If this information is new, please navigate to the
	     * {\@link Component#animations-anchor component animations metadata
	     * page} to gain a better understanding of how animations in Angular2 are used.
	     *
	     * `transition` declares the {\@link sequence sequence of animation steps} that will be run when the
	     * provided
	     * `stateChangeExpr` value is satisfied. The `stateChangeExpr` consists of a `state1 => state2`
	     * which consists
	     * of two known states (use an asterix (`*`) to refer to a dynamic starting and/or ending state).
	     *
	     * Animation transitions are placed within an {\@link trigger animation trigger}. For an transition
	     * to animate to
	     * a state value and persist its styles then one or more {\@link state animation states} is expected
	     * to be defined.
	     *
	     * ### Usage
	     *
	     * An animation transition is kicked off the `stateChangeExpr` predicate evaluates to true based on
	     * what the
	     * previous state is and what the current state has become. In other words, if a transition is
	     * defined that
	     * matches the old/current state criteria then the associated animation will be triggered.
	     *
	     * ```typescript
	     * // all transition/state changes are defined within an animation trigger
	     * trigger("myAnimationTrigger", [
	     *   // if a state is defined then its styles will be persisted when the
	     *   // animation has fully completed itself
	     *   state("on", style({ background: "green" })),
	     *   state("off", style({ background: "grey" })),
	     *
	     *   // a transition animation that will be kicked off when the state value
	     *   // bound to "myAnimationTrigger" changes from "on" to "off"
	     *   transition("on => off", animate(500)),
	     *
	     *   // it is also possible to do run the same animation for both directions
	     *   transition("on <=> off", animate(500)),
	     *
	     *   // or to define multiple states pairs separated by commas
	     *   transition("on => off, off => void", animate(500)),
	     *
	     *   // this is a catch-all state change for when an element is inserted into
	     *   // the page and the destination state is unknown
	     *   transition("void => *", [
	     *     style({ opacity: 0 }),
	     *     animate(500)
	     *   ]),
	     *
	     *   // this will capture a state change between any states
	     *   transition("* => *", animate("1s 0s")),
	     * ])
	     * ```
	     *
	     * The template associated with this component will make use of the `myAnimationTrigger`
	     * animation trigger by binding to an element within its template code.
	     *
	     * ```html
	     * <!-- somewhere inside of my-component-tpl.html -->
	     * <div [\@myAnimationTrigger]="myStatusExp">...</div>
	     * ```
	     *
	     * #### The final `animate` call
	     *
	     * If the final step within the transition steps is a call to `animate()` that **only**
	     * uses a timing value with **no style data** then it will be automatically used as the final
	     * animation
	     * arc for the element to animate itself to the final state. This involves an automatic mix of
	     * adding/removing CSS styles so that the element will be in the exact state it should be for the
	     * applied state to be presented correctly.
	     *
	     * ```
	     * // start off by hiding the element, but make sure that it animates properly to whatever state
	     * // is currently active for "myAnimationTrigger"
	     * transition("void => *", [
	     *   style({ opacity: 0 }),
	     *   animate(500)
	     * ])
	     * ```
	     *
	     * ### Transition Aliases (`:enter` and `:leave`)
	     *
	     * Given that enter (insertion) and leave (removal) animations are so common,
	     * the `transition` function accepts both `:enter` and `:leave` values which
	     * are aliases for the `void => *` and `* => void` state changes.
	     *
	     * ```
	     * transition(":enter", [
	     *   style({ opacity: 0 }),
	     *   animate(500, style({ opacity: 1 }))
	     * ])
	     * transition(":leave", [
	     *   animate(500, style({ opacity: 0 }))
	     * ])
	     * ```
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	     *
	     * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
	     *
	     * \@experimental Animation support is experimental.
	     * @param {?} stateChangeExpr
	     * @param {?} steps
	     * @return {?}
	     */
	    function transition(stateChangeExpr, steps) {
	        var /** @type {?} */ animationData = Array.isArray(steps) ? new AnimationSequenceMetadata(steps) : steps;
	        return new AnimationStateTransitionMetadata(stateChangeExpr, animationData);
	    }
	    /**
	     * `trigger` is an animation-specific function that is designed to be used inside of Angular2's
	     * animation
	     * DSL language. If this information is new, please navigate to the
	     * {\@link Component#animations-anchor component animations metadata
	     * page} to gain a better understanding of how animations in Angular2 are used.
	     *
	     * `trigger` Creates an animation trigger which will a list of {\@link state state} and {\@link
	     * transition transition}
	     * entries that will be evaluated when the expression bound to the trigger changes.
	     *
	     * Triggers are registered within the component annotation data under the
	     * {\@link Component#animations-anchor animations section}. An animation trigger can
	     * be placed on an element within a template by referencing the name of the
	     * trigger followed by the expression value that the trigger is bound to
	     * (in the form of `[\@triggerName]="expression"`.
	     *
	     * ### Usage
	     *
	     * `trigger` will create an animation trigger reference based on the provided `name` value.
	     * The provided `animation` value is expected to be an array consisting of {\@link state state} and
	     * {\@link transition transition}
	     * declarations.
	     *
	     * ```typescript
	     * \@Component({
	     *   selector: 'my-component',
	     *   templateUrl: 'my-component-tpl.html',
	     *   animations: [
	     *     trigger("myAnimationTrigger", [
	     *       state(...),
	     *       state(...),
	     *       transition(...),
	     *       transition(...)
	     *     ])
	     *   ]
	     * })
	     * class MyComponent {
	     *   myStatusExp = "something";
	     * }
	     * ```
	     *
	     * The template associated with this component will make use of the `myAnimationTrigger`
	     * animation trigger by binding to an element within its template code.
	     *
	     * ```html
	     * <!-- somewhere inside of my-component-tpl.html -->
	     * <div [\@myAnimationTrigger]="myStatusExp">...</div>
	     * ```
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/Kez8XGWBxWue7qP7nNvF?p=preview))
	     *
	     * {\@example core/animation/ts/dsl/animation_example.ts region='Component'}
	     *
	     * \@experimental Animation support is experimental.
	     * @param {?} name
	     * @param {?} animation
	     * @return {?}
	     */
	    function trigger(name, animation) {
	        return new AnimationEntryMetadata(name, animation);
	    }

	    /**
	     * @param {?} previousStyles
	     * @param {?} newStyles
	     * @param {?=} nullValue
	     * @return {?}
	     */
	    function prepareFinalAnimationStyles(previousStyles, newStyles, nullValue) {
	        if (nullValue === void 0) { nullValue = null; }
	        var /** @type {?} */ finalStyles = {};
	        Object.keys(newStyles).forEach(function (prop) {
	            var /** @type {?} */ value = newStyles[prop];
	            finalStyles[prop] = value == AUTO_STYLE ? nullValue : value.toString();
	        });
	        Object.keys(previousStyles).forEach(function (prop) {
	            if (!isPresent(finalStyles[prop])) {
	                finalStyles[prop] = nullValue;
	            }
	        });
	        return finalStyles;
	    }
	    /**
	     * @param {?} collectedStyles
	     * @param {?} finalStateStyles
	     * @param {?} keyframes
	     * @return {?}
	     */
	    function balanceAnimationKeyframes(collectedStyles, finalStateStyles, keyframes) {
	        var /** @type {?} */ limit = keyframes.length - 1;
	        var /** @type {?} */ firstKeyframe = keyframes[0];
	        // phase 1: copy all the styles from the first keyframe into the lookup map
	        var /** @type {?} */ flatenedFirstKeyframeStyles = flattenStyles(firstKeyframe.styles.styles);
	        var /** @type {?} */ extraFirstKeyframeStyles = {};
	        var /** @type {?} */ hasExtraFirstStyles = false;
	        Object.keys(collectedStyles).forEach(function (prop) {
	            var /** @type {?} */ value = (collectedStyles[prop]);
	            // if the style is already defined in the first keyframe then
	            // we do not replace it.
	            if (!flatenedFirstKeyframeStyles[prop]) {
	                flatenedFirstKeyframeStyles[prop] = value;
	                extraFirstKeyframeStyles[prop] = value;
	                hasExtraFirstStyles = true;
	            }
	        });
	        var /** @type {?} */ keyframeCollectedStyles = StringMapWrapper.merge({}, flatenedFirstKeyframeStyles);
	        // phase 2: normalize the final keyframe
	        var /** @type {?} */ finalKeyframe = keyframes[limit];
	        finalKeyframe.styles.styles.unshift(finalStateStyles);
	        var /** @type {?} */ flatenedFinalKeyframeStyles = flattenStyles(finalKeyframe.styles.styles);
	        var /** @type {?} */ extraFinalKeyframeStyles = {};
	        var /** @type {?} */ hasExtraFinalStyles = false;
	        Object.keys(keyframeCollectedStyles).forEach(function (prop) {
	            if (!isPresent(flatenedFinalKeyframeStyles[prop])) {
	                extraFinalKeyframeStyles[prop] = AUTO_STYLE;
	                hasExtraFinalStyles = true;
	            }
	        });
	        if (hasExtraFinalStyles) {
	            finalKeyframe.styles.styles.push(extraFinalKeyframeStyles);
	        }
	        Object.keys(flatenedFinalKeyframeStyles).forEach(function (prop) {
	            if (!isPresent(flatenedFirstKeyframeStyles[prop])) {
	                extraFirstKeyframeStyles[prop] = AUTO_STYLE;
	                hasExtraFirstStyles = true;
	            }
	        });
	        if (hasExtraFirstStyles) {
	            firstKeyframe.styles.styles.push(extraFirstKeyframeStyles);
	        }
	        collectAndResolveStyles(collectedStyles, [finalStateStyles]);
	        return keyframes;
	    }
	    /**
	     * @param {?} styles
	     * @return {?}
	     */
	    function clearStyles(styles) {
	        var /** @type {?} */ finalStyles = {};
	        Object.keys(styles).forEach(function (key) { finalStyles[key] = null; });
	        return finalStyles;
	    }
	    /**
	     * @param {?} collection
	     * @param {?} styles
	     * @return {?}
	     */
	    function collectAndResolveStyles(collection, styles) {
	        return styles.map(function (entry) {
	            var /** @type {?} */ stylesObj = {};
	            Object.keys(entry).forEach(function (prop) {
	                var /** @type {?} */ value = entry[prop];
	                if (value == FILL_STYLE_FLAG) {
	                    value = collection[prop];
	                    if (!isPresent(value)) {
	                        value = AUTO_STYLE;
	                    }
	                }
	                collection[prop] = value;
	                stylesObj[prop] = value;
	            });
	            return stylesObj;
	        });
	    }
	    /**
	     * @param {?} element
	     * @param {?} renderer
	     * @param {?} styles
	     * @return {?}
	     */
	    function renderStyles(element, renderer, styles) {
	        Object.keys(styles).forEach(function (prop) { renderer.setElementStyle(element, prop, styles[prop]); });
	    }
	    /**
	     * @param {?} styles
	     * @return {?}
	     */
	    function flattenStyles(styles) {
	        var /** @type {?} */ finalStyles = {};
	        styles.forEach(function (entry) {
	            Object.keys(entry).forEach(function (prop) { finalStyles[prop] = (entry[prop]); });
	        });
	        return finalStyles;
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var AnimationStyles = (function () {
	        /**
	         * @param {?} styles
	         */
	        function AnimationStyles(styles) {
	            this.styles = styles;
	        }
	        return AnimationStyles;
	    }());

	    /**
	     * An instance of this class is returned as an event parameter when an animation
	     * callback is captured for an animation either during the start or done phase.
	     *
	     * ```typescript
	     * \@Component({
	     *   host: {
	     *     '[\@myAnimationTrigger]': 'someExpression',
	     *     '(\@myAnimationTrigger.start)': 'captureStartEvent($event)',
	     *     '(\@myAnimationTrigger.done)': 'captureDoneEvent($event)',
	     *   },
	     *   animations: [
	     *     trigger("myAnimationTrigger", [
	     *        // ...
	     *     ])
	     *   ]
	     * })
	     * class MyComponent {
	     *   someExpression: any = false;
	     *   captureStartEvent(event: AnimationTransitionEvent) {
	     *     // the toState, fromState and totalTime data is accessible from the event variable
	     *   }
	     *
	     *   captureDoneEvent(event: AnimationTransitionEvent) {
	     *     // the toState, fromState and totalTime data is accessible from the event variable
	     *   }
	     * }
	     * ```
	     *
	     * \@experimental Animation support is experimental.
	     */
	    var AnimationTransitionEvent = (function () {
	        /**
	         * @param {?} __0
	         */
	        function AnimationTransitionEvent(_a) {
	            var fromState = _a.fromState, toState = _a.toState, totalTime = _a.totalTime, phaseName = _a.phaseName;
	            this.fromState = fromState;
	            this.toState = toState;
	            this.totalTime = totalTime;
	            this.phaseName = phaseName;
	        }
	        return AnimationTransitionEvent;
	    }());

	    var AnimationTransition = (function () {
	        /**
	         * @param {?} _player
	         * @param {?} _fromState
	         * @param {?} _toState
	         * @param {?} _totalTime
	         */
	        function AnimationTransition(_player, _fromState, _toState, _totalTime) {
	            this._player = _player;
	            this._fromState = _fromState;
	            this._toState = _toState;
	            this._totalTime = _totalTime;
	        }
	        /**
	         * @param {?} phaseName
	         * @return {?}
	         */
	        AnimationTransition.prototype._createEvent = function (phaseName) {
	            return new AnimationTransitionEvent({
	                fromState: this._fromState,
	                toState: this._toState,
	                totalTime: this._totalTime,
	                phaseName: phaseName
	            });
	        };
	        /**
	         * @param {?} callback
	         * @return {?}
	         */
	        AnimationTransition.prototype.onStart = function (callback) {
	            var _this = this;
	            var /** @type {?} */ fn = (Zone.current.wrap(function () { return callback(_this._createEvent('start')); }, 'player.onStart'));
	            this._player.onStart(fn);
	        };
	        /**
	         * @param {?} callback
	         * @return {?}
	         */
	        AnimationTransition.prototype.onDone = function (callback) {
	            var _this = this;
	            var /** @type {?} */ fn = (Zone.current.wrap(function () { return callback(_this._createEvent('done')); }, 'player.onDone'));
	            this._player.onDone(fn);
	        };
	        return AnimationTransition;
	    }());

	    var DebugDomRootRenderer = (function () {
	        /**
	         * @param {?} _delegate
	         */
	        function DebugDomRootRenderer(_delegate) {
	            this._delegate = _delegate;
	        }
	        /**
	         * @param {?} componentProto
	         * @return {?}
	         */
	        DebugDomRootRenderer.prototype.renderComponent = function (componentProto) {
	            return new DebugDomRenderer(this._delegate.renderComponent(componentProto));
	        };
	        return DebugDomRootRenderer;
	    }());
	    var DebugDomRenderer = (function () {
	        /**
	         * @param {?} _delegate
	         */
	        function DebugDomRenderer(_delegate) {
	            this._delegate = _delegate;
	        }
	        /**
	         * @param {?} selectorOrNode
	         * @param {?=} debugInfo
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.selectRootElement = function (selectorOrNode, debugInfo) {
	            var /** @type {?} */ nativeEl = this._delegate.selectRootElement(selectorOrNode, debugInfo);
	            var /** @type {?} */ debugEl = new DebugElement(nativeEl, null, debugInfo);
	            indexDebugNode(debugEl);
	            return nativeEl;
	        };
	        /**
	         * @param {?} parentElement
	         * @param {?} name
	         * @param {?=} debugInfo
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.createElement = function (parentElement, name, debugInfo) {
	            var /** @type {?} */ nativeEl = this._delegate.createElement(parentElement, name, debugInfo);
	            var /** @type {?} */ debugEl = new DebugElement(nativeEl, getDebugNode(parentElement), debugInfo);
	            debugEl.name = name;
	            indexDebugNode(debugEl);
	            return nativeEl;
	        };
	        /**
	         * @param {?} hostElement
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.createViewRoot = function (hostElement) { return this._delegate.createViewRoot(hostElement); };
	        /**
	         * @param {?} parentElement
	         * @param {?=} debugInfo
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.createTemplateAnchor = function (parentElement, debugInfo) {
	            var /** @type {?} */ comment = this._delegate.createTemplateAnchor(parentElement, debugInfo);
	            var /** @type {?} */ debugEl = new DebugNode(comment, getDebugNode(parentElement), debugInfo);
	            indexDebugNode(debugEl);
	            return comment;
	        };
	        /**
	         * @param {?} parentElement
	         * @param {?} value
	         * @param {?=} debugInfo
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.createText = function (parentElement, value, debugInfo) {
	            var /** @type {?} */ text = this._delegate.createText(parentElement, value, debugInfo);
	            var /** @type {?} */ debugEl = new DebugNode(text, getDebugNode(parentElement), debugInfo);
	            indexDebugNode(debugEl);
	            return text;
	        };
	        /**
	         * @param {?} parentElement
	         * @param {?} nodes
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.projectNodes = function (parentElement, nodes) {
	            var /** @type {?} */ debugParent = getDebugNode(parentElement);
	            if (isPresent(debugParent) && debugParent instanceof DebugElement) {
	                var /** @type {?} */ debugElement_1 = debugParent;
	                nodes.forEach(function (node) { debugElement_1.addChild(getDebugNode(node)); });
	            }
	            this._delegate.projectNodes(parentElement, nodes);
	        };
	        /**
	         * @param {?} node
	         * @param {?} viewRootNodes
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.attachViewAfter = function (node, viewRootNodes) {
	            var /** @type {?} */ debugNode = getDebugNode(node);
	            if (isPresent(debugNode)) {
	                var /** @type {?} */ debugParent = debugNode.parent;
	                if (viewRootNodes.length > 0 && isPresent(debugParent)) {
	                    var /** @type {?} */ debugViewRootNodes_1 = [];
	                    viewRootNodes.forEach(function (rootNode) { return debugViewRootNodes_1.push(getDebugNode(rootNode)); });
	                    debugParent.insertChildrenAfter(debugNode, debugViewRootNodes_1);
	                }
	            }
	            this._delegate.attachViewAfter(node, viewRootNodes);
	        };
	        /**
	         * @param {?} viewRootNodes
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.detachView = function (viewRootNodes) {
	            viewRootNodes.forEach(function (node) {
	                var /** @type {?} */ debugNode = getDebugNode(node);
	                if (isPresent(debugNode) && isPresent(debugNode.parent)) {
	                    debugNode.parent.removeChild(debugNode);
	                }
	            });
	            this._delegate.detachView(viewRootNodes);
	        };
	        /**
	         * @param {?} hostElement
	         * @param {?} viewAllNodes
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.destroyView = function (hostElement, viewAllNodes) {
	            viewAllNodes = viewAllNodes || [];
	            viewAllNodes.forEach(function (node) { removeDebugNodeFromIndex(getDebugNode(node)); });
	            this._delegate.destroyView(hostElement, viewAllNodes);
	        };
	        /**
	         * @param {?} renderElement
	         * @param {?} name
	         * @param {?} callback
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.listen = function (renderElement, name, callback) {
	            var /** @type {?} */ debugEl = getDebugNode(renderElement);
	            if (isPresent(debugEl)) {
	                debugEl.listeners.push(new EventListener(name, callback));
	            }
	            return this._delegate.listen(renderElement, name, callback);
	        };
	        /**
	         * @param {?} target
	         * @param {?} name
	         * @param {?} callback
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.listenGlobal = function (target, name, callback) {
	            return this._delegate.listenGlobal(target, name, callback);
	        };
	        /**
	         * @param {?} renderElement
	         * @param {?} propertyName
	         * @param {?} propertyValue
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.setElementProperty = function (renderElement, propertyName, propertyValue) {
	            var /** @type {?} */ debugEl = getDebugNode(renderElement);
	            if (isPresent(debugEl) && debugEl instanceof DebugElement) {
	                debugEl.properties[propertyName] = propertyValue;
	            }
	            this._delegate.setElementProperty(renderElement, propertyName, propertyValue);
	        };
	        /**
	         * @param {?} renderElement
	         * @param {?} attributeName
	         * @param {?} attributeValue
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.setElementAttribute = function (renderElement, attributeName, attributeValue) {
	            var /** @type {?} */ debugEl = getDebugNode(renderElement);
	            if (isPresent(debugEl) && debugEl instanceof DebugElement) {
	                debugEl.attributes[attributeName] = attributeValue;
	            }
	            this._delegate.setElementAttribute(renderElement, attributeName, attributeValue);
	        };
	        /**
	         * @param {?} renderElement
	         * @param {?} propertyName
	         * @param {?} propertyValue
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.setBindingDebugInfo = function (renderElement, propertyName, propertyValue) {
	            this._delegate.setBindingDebugInfo(renderElement, propertyName, propertyValue);
	        };
	        /**
	         * @param {?} renderElement
	         * @param {?} className
	         * @param {?} isAdd
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.setElementClass = function (renderElement, className, isAdd) {
	            var /** @type {?} */ debugEl = getDebugNode(renderElement);
	            if (isPresent(debugEl) && debugEl instanceof DebugElement) {
	                debugEl.classes[className] = isAdd;
	            }
	            this._delegate.setElementClass(renderElement, className, isAdd);
	        };
	        /**
	         * @param {?} renderElement
	         * @param {?} styleName
	         * @param {?} styleValue
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.setElementStyle = function (renderElement, styleName, styleValue) {
	            var /** @type {?} */ debugEl = getDebugNode(renderElement);
	            if (isPresent(debugEl) && debugEl instanceof DebugElement) {
	                debugEl.styles[styleName] = styleValue;
	            }
	            this._delegate.setElementStyle(renderElement, styleName, styleValue);
	        };
	        /**
	         * @param {?} renderElement
	         * @param {?} methodName
	         * @param {?=} args
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.invokeElementMethod = function (renderElement, methodName, args) {
	            this._delegate.invokeElementMethod(renderElement, methodName, args);
	        };
	        /**
	         * @param {?} renderNode
	         * @param {?} text
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.setText = function (renderNode, text) { this._delegate.setText(renderNode, text); };
	        /**
	         * @param {?} element
	         * @param {?} startingStyles
	         * @param {?} keyframes
	         * @param {?} duration
	         * @param {?} delay
	         * @param {?} easing
	         * @param {?=} previousPlayers
	         * @return {?}
	         */
	        DebugDomRenderer.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing, previousPlayers) {
	            if (previousPlayers === void 0) { previousPlayers = []; }
	            return this._delegate.animate(element, startingStyles, keyframes, duration, delay, easing, previousPlayers);
	        };
	        return DebugDomRenderer;
	    }());

	    var ViewType = {};
	    ViewType.HOST = 0;
	    ViewType.COMPONENT = 1;
	    ViewType.EMBEDDED = 2;
	    ViewType[ViewType.HOST] = "HOST";
	    ViewType[ViewType.COMPONENT] = "COMPONENT";
	    ViewType[ViewType.EMBEDDED] = "EMBEDDED";

	    var StaticNodeDebugInfo = (function () {
	        /**
	         * @param {?} providerTokens
	         * @param {?} componentToken
	         * @param {?} refTokens
	         */
	        function StaticNodeDebugInfo(providerTokens, componentToken, refTokens) {
	            this.providerTokens = providerTokens;
	            this.componentToken = componentToken;
	            this.refTokens = refTokens;
	        }
	        return StaticNodeDebugInfo;
	    }());
	    var DebugContext = (function () {
	        /**
	         * @param {?} _view
	         * @param {?} _nodeIndex
	         * @param {?} _tplRow
	         * @param {?} _tplCol
	         */
	        function DebugContext(_view, _nodeIndex, _tplRow, _tplCol) {
	            this._view = _view;
	            this._nodeIndex = _nodeIndex;
	            this._tplRow = _tplRow;
	            this._tplCol = _tplCol;
	        }
	        Object.defineProperty(DebugContext.prototype, "_staticNodeInfo", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return isPresent(this._nodeIndex) ? this._view.staticNodeDebugInfos[this._nodeIndex] : null;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugContext.prototype, "context", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._view.context; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugContext.prototype, "component", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                var /** @type {?} */ staticNodeInfo = this._staticNodeInfo;
	                if (isPresent(staticNodeInfo) && isPresent(staticNodeInfo.componentToken)) {
	                    return this.injector.get(staticNodeInfo.componentToken);
	                }
	                return null;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugContext.prototype, "componentRenderElement", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                var /** @type {?} */ componentView = this._view;
	                while (isPresent(componentView.parentView) && componentView.type !== ViewType.COMPONENT) {
	                    componentView = (componentView.parentView);
	                }
	                return componentView.parentElement;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugContext.prototype, "injector", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._view.injector(this._nodeIndex); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugContext.prototype, "renderNode", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                if (isPresent(this._nodeIndex) && this._view.allNodes) {
	                    return this._view.allNodes[this._nodeIndex];
	                }
	                else {
	                    return null;
	                }
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugContext.prototype, "providerTokens", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                var /** @type {?} */ staticNodeInfo = this._staticNodeInfo;
	                return isPresent(staticNodeInfo) ? staticNodeInfo.providerTokens : null;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugContext.prototype, "source", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return this._view.componentType.templateUrl + ":" + this._tplRow + ":" + this._tplCol;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(DebugContext.prototype, "references", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                var _this = this;
	                var /** @type {?} */ varValues = {};
	                var /** @type {?} */ staticNodeInfo = this._staticNodeInfo;
	                if (isPresent(staticNodeInfo)) {
	                    var /** @type {?} */ refs_1 = staticNodeInfo.refTokens;
	                    Object.keys(refs_1).forEach(function (refName) {
	                        var /** @type {?} */ refToken = refs_1[refName];
	                        var /** @type {?} */ varValue;
	                        if (isBlank(refToken)) {
	                            varValue = _this._view.allNodes ? _this._view.allNodes[_this._nodeIndex] : null;
	                        }
	                        else {
	                            varValue = _this._view.injectorGet(refToken, _this._nodeIndex, null);
	                        }
	                        varValues[refName] = varValue;
	                    });
	                }
	                return varValues;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        return DebugContext;
	    }());

	    var ViewAnimationMap = (function () {
	        function ViewAnimationMap() {
	            this._map = new Map();
	            this._allPlayers = [];
	        }
	        /**
	         * @param {?} element
	         * @param {?} animationName
	         * @return {?}
	         */
	        ViewAnimationMap.prototype.find = function (element, animationName) {
	            var /** @type {?} */ playersByAnimation = this._map.get(element);
	            if (isPresent(playersByAnimation)) {
	                return playersByAnimation[animationName];
	            }
	        };
	        /**
	         * @param {?} element
	         * @return {?}
	         */
	        ViewAnimationMap.prototype.findAllPlayersByElement = function (element) {
	            var /** @type {?} */ el = this._map.get(element);
	            return el ? Object.keys(el).map(function (k) { return el[k]; }) : [];
	        };
	        /**
	         * @param {?} element
	         * @param {?} animationName
	         * @param {?} player
	         * @return {?}
	         */
	        ViewAnimationMap.prototype.set = function (element, animationName, player) {
	            var /** @type {?} */ playersByAnimation = this._map.get(element);
	            if (!isPresent(playersByAnimation)) {
	                playersByAnimation = {};
	            }
	            var /** @type {?} */ existingEntry = playersByAnimation[animationName];
	            if (isPresent(existingEntry)) {
	                this.remove(element, animationName);
	            }
	            playersByAnimation[animationName] = player;
	            this._allPlayers.push(player);
	            this._map.set(element, playersByAnimation);
	        };
	        /**
	         * @return {?}
	         */
	        ViewAnimationMap.prototype.getAllPlayers = function () { return this._allPlayers; };
	        /**
	         * @param {?} element
	         * @param {?} animationName
	         * @param {?=} targetPlayer
	         * @return {?}
	         */
	        ViewAnimationMap.prototype.remove = function (element, animationName, targetPlayer) {
	            if (targetPlayer === void 0) { targetPlayer = null; }
	            var /** @type {?} */ playersByAnimation = this._map.get(element);
	            if (playersByAnimation) {
	                var /** @type {?} */ player = playersByAnimation[animationName];
	                if (!targetPlayer || player === targetPlayer) {
	                    delete playersByAnimation[animationName];
	                    var /** @type {?} */ index = this._allPlayers.indexOf(player);
	                    this._allPlayers.splice(index, 1);
	                    if (Object.keys(playersByAnimation).length === 0) {
	                        this._map.delete(element);
	                    }
	                }
	            }
	        };
	        return ViewAnimationMap;
	    }());

	    var AnimationViewContext = (function () {
	        /**
	         * @param {?} _animationQueue
	         */
	        function AnimationViewContext(_animationQueue) {
	            this._animationQueue = _animationQueue;
	            this._players = new ViewAnimationMap();
	        }
	        /**
	         * @param {?} callback
	         * @return {?}
	         */
	        AnimationViewContext.prototype.onAllActiveAnimationsDone = function (callback) {
	            var /** @type {?} */ activeAnimationPlayers = this._players.getAllPlayers();
	            // we check for the length to avoid having GroupAnimationPlayer
	            // issue an unnecessary microtask when zero players are passed in
	            if (activeAnimationPlayers.length) {
	                new AnimationGroupPlayer(activeAnimationPlayers).onDone(function () { return callback(); });
	            }
	            else {
	                callback();
	            }
	        };
	        /**
	         * @param {?} element
	         * @param {?} animationName
	         * @param {?} player
	         * @return {?}
	         */
	        AnimationViewContext.prototype.queueAnimation = function (element, animationName, player) {
	            var _this = this;
	            this._animationQueue.enqueue(player);
	            this._players.set(element, animationName, player);
	            player.onDone(function () { return _this._players.remove(element, animationName, player); });
	        };
	        /**
	         * @param {?} element
	         * @param {?=} animationName
	         * @return {?}
	         */
	        AnimationViewContext.prototype.getAnimationPlayers = function (element, animationName) {
	            if (animationName === void 0) { animationName = null; }
	            var /** @type {?} */ players = [];
	            if (animationName) {
	                var /** @type {?} */ currentPlayer = this._players.find(element, animationName);
	                if (currentPlayer) {
	                    _recursePlayers(currentPlayer, players);
	                }
	            }
	            else {
	                this._players.findAllPlayersByElement(element).forEach(function (player) { return _recursePlayers(player, players); });
	            }
	            return players;
	        };
	        return AnimationViewContext;
	    }());
	    /**
	     * @param {?} player
	     * @param {?} collectedPlayers
	     * @return {?}
	     */
	    function _recursePlayers(player, collectedPlayers) {
	        if ((player instanceof AnimationGroupPlayer) || (player instanceof AnimationSequencePlayer)) {
	            player.players.forEach(function (player) { return _recursePlayers(player, collectedPlayers); });
	        }
	        else {
	            collectedPlayers.push(player);
	        }
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$15 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var ElementInjector = (function (_super) {
	        __extends$15(ElementInjector, _super);
	        /**
	         * @param {?} _view
	         * @param {?} _nodeIndex
	         */
	        function ElementInjector(_view, _nodeIndex) {
	            _super.call(this);
	            this._view = _view;
	            this._nodeIndex = _nodeIndex;
	        }
	        /**
	         * @param {?} token
	         * @param {?=} notFoundValue
	         * @return {?}
	         */
	        ElementInjector.prototype.get = function (token, notFoundValue) {
	            if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }
	            return this._view.injectorGet(token, this._nodeIndex, notFoundValue);
	        };
	        return ElementInjector;
	    }(Injector));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$14 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ _scope_check = wtfCreateScope("AppView#check(ascii id)");
	    /**
	     * @experimental
	     */
	    var /** @type {?} */ EMPTY_CONTEXT = new Object();
	    var /** @type {?} */ UNDEFINED$1 = new Object();
	    /**
	     * Cost of making objects: http://jsperf.com/instantiate-size-of-object
	     *
	     * @abstract
	     */
	    var AppView = (function () {
	        /**
	         * @param {?} clazz
	         * @param {?} componentType
	         * @param {?} type
	         * @param {?} viewUtils
	         * @param {?} parentView
	         * @param {?} parentIndex
	         * @param {?} parentElement
	         * @param {?} cdMode
	         * @param {?=} declaredViewContainer
	         */
	        function AppView(clazz, componentType, type, viewUtils, parentView, parentIndex, parentElement, cdMode, declaredViewContainer) {
	            if (declaredViewContainer === void 0) { declaredViewContainer = null; }
	            this.clazz = clazz;
	            this.componentType = componentType;
	            this.type = type;
	            this.viewUtils = viewUtils;
	            this.parentView = parentView;
	            this.parentIndex = parentIndex;
	            this.parentElement = parentElement;
	            this.cdMode = cdMode;
	            this.declaredViewContainer = declaredViewContainer;
	            this.numberOfChecks = 0;
	            this.ref = new ViewRef_(this, viewUtils.animationQueue);
	            if (type === ViewType.COMPONENT || type === ViewType.HOST) {
	                this.renderer = viewUtils.renderComponent(componentType);
	            }
	            else {
	                this.renderer = parentView.renderer;
	            }
	            this._directRenderer = this.renderer.directRenderer;
	        }
	        Object.defineProperty(AppView.prototype, "animationContext", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                if (!this._animationContext) {
	                    this._animationContext = new AnimationViewContext(this.viewUtils.animationQueue);
	                }
	                return this._animationContext;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AppView.prototype, "destroyed", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.cdMode === ChangeDetectorStatus.Destroyed; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} context
	         * @return {?}
	         */
	        AppView.prototype.create = function (context) {
	            this.context = context;
	            return this.createInternal(null);
	        };
	        /**
	         * @param {?} rootSelectorOrNode
	         * @param {?} hostInjector
	         * @param {?} projectableNodes
	         * @return {?}
	         */
	        AppView.prototype.createHostView = function (rootSelectorOrNode, hostInjector, projectableNodes) {
	            this.context = (EMPTY_CONTEXT);
	            this._hasExternalHostElement = isPresent(rootSelectorOrNode);
	            this._hostInjector = hostInjector;
	            this._hostProjectableNodes = projectableNodes;
	            return this.createInternal(rootSelectorOrNode);
	        };
	        /**
	         * Overwritten by implementations.
	         * Returns the ComponentRef for the host element for ViewType.HOST.
	         * @param {?} rootSelectorOrNode
	         * @return {?}
	         */
	        AppView.prototype.createInternal = function (rootSelectorOrNode) { return null; };
	        /**
	         * Overwritten by implementations.
	         * @param {?} templateNodeIndex
	         * @return {?}
	         */
	        AppView.prototype.createEmbeddedViewInternal = function (templateNodeIndex) { return null; };
	        /**
	         * @param {?} lastRootNode
	         * @param {?} allNodes
	         * @param {?} disposables
	         * @return {?}
	         */
	        AppView.prototype.init = function (lastRootNode, allNodes, disposables) {
	            this.lastRootNode = lastRootNode;
	            this.allNodes = allNodes;
	            this.disposables = disposables;
	            if (this.type === ViewType.COMPONENT) {
	                this.dirtyParentQueriesInternal();
	            }
	        };
	        /**
	         * @param {?} token
	         * @param {?} nodeIndex
	         * @param {?=} notFoundValue
	         * @return {?}
	         */
	        AppView.prototype.injectorGet = function (token, nodeIndex, notFoundValue) {
	            if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }
	            var /** @type {?} */ result = UNDEFINED$1;
	            var /** @type {?} */ view = this;
	            while (result === UNDEFINED$1) {
	                if (isPresent(nodeIndex)) {
	                    result = view.injectorGetInternal(token, nodeIndex, UNDEFINED$1);
	                }
	                if (result === UNDEFINED$1 && view.type === ViewType.HOST) {
	                    result = view._hostInjector.get(token, notFoundValue);
	                }
	                nodeIndex = view.parentIndex;
	                view = view.parentView;
	            }
	            return result;
	        };
	        /**
	         * Overwritten by implementations
	         * @param {?} token
	         * @param {?} nodeIndex
	         * @param {?} notFoundResult
	         * @return {?}
	         */
	        AppView.prototype.injectorGetInternal = function (token, nodeIndex, notFoundResult) {
	            return notFoundResult;
	        };
	        /**
	         * @param {?} nodeIndex
	         * @return {?}
	         */
	        AppView.prototype.injector = function (nodeIndex) { return new ElementInjector(this, nodeIndex); };
	        /**
	         * @return {?}
	         */
	        AppView.prototype.detachAndDestroy = function () {
	            if (this.viewContainer) {
	                this.viewContainer.detachView(this.viewContainer.nestedViews.indexOf(this));
	            }
	            else if (this.appRef) {
	                this.appRef.detachView(this.ref);
	            }
	            else if (this._hasExternalHostElement) {
	                this.detach();
	            }
	            this.destroy();
	        };
	        /**
	         * @return {?}
	         */
	        AppView.prototype.destroy = function () {
	            var _this = this;
	            if (this.cdMode === ChangeDetectorStatus.Destroyed) {
	                return;
	            }
	            var /** @type {?} */ hostElement = this.type === ViewType.COMPONENT ? this.parentElement : null;
	            if (this.disposables) {
	                for (var /** @type {?} */ i = 0; i < this.disposables.length; i++) {
	                    this.disposables[i]();
	                }
	            }
	            this.destroyInternal();
	            this.dirtyParentQueriesInternal();
	            if (this._animationContext) {
	                this._animationContext.onAllActiveAnimationsDone(function () { return _this.renderer.destroyView(hostElement, _this.allNodes); });
	            }
	            else {
	                this.renderer.destroyView(hostElement, this.allNodes);
	            }
	            this.cdMode = ChangeDetectorStatus.Destroyed;
	        };
	        /**
	         * Overwritten by implementations
	         * @return {?}
	         */
	        AppView.prototype.destroyInternal = function () { };
	        /**
	         * Overwritten by implementations
	         * @return {?}
	         */
	        AppView.prototype.detachInternal = function () { };
	        /**
	         * @return {?}
	         */
	        AppView.prototype.detach = function () {
	            var _this = this;
	            this.detachInternal();
	            if (this._animationContext) {
	                this._animationContext.onAllActiveAnimationsDone(function () { return _this._renderDetach(); });
	            }
	            else {
	                this._renderDetach();
	            }
	            if (this.declaredViewContainer && this.declaredViewContainer !== this.viewContainer &&
	                this.declaredViewContainer.projectedViews) {
	                var /** @type {?} */ projectedViews = this.declaredViewContainer.projectedViews;
	                var /** @type {?} */ index = projectedViews.indexOf(this);
	                // perf: pop is faster than splice!
	                if (index >= projectedViews.length - 1) {
	                    projectedViews.pop();
	                }
	                else {
	                    projectedViews.splice(index, 1);
	                }
	            }
	            this.appRef = null;
	            this.viewContainer = null;
	            this.dirtyParentQueriesInternal();
	        };
	        /**
	         * @return {?}
	         */
	        AppView.prototype._renderDetach = function () {
	            if (this._directRenderer) {
	                this.visitRootNodesInternal(this._directRenderer.remove, null);
	            }
	            else {
	                this.renderer.detachView(this.flatRootNodes);
	            }
	        };
	        /**
	         * @param {?} appRef
	         * @return {?}
	         */
	        AppView.prototype.attachToAppRef = function (appRef) {
	            if (this.viewContainer) {
	                throw new Error('This view is already attached to a ViewContainer!');
	            }
	            this.appRef = appRef;
	            this.dirtyParentQueriesInternal();
	        };
	        /**
	         * @param {?} viewContainer
	         * @param {?} prevView
	         * @return {?}
	         */
	        AppView.prototype.attachAfter = function (viewContainer, prevView) {
	            if (this.appRef) {
	                throw new Error('This view is already attached directly to the ApplicationRef!');
	            }
	            this._renderAttach(viewContainer, prevView);
	            this.viewContainer = viewContainer;
	            if (this.declaredViewContainer && this.declaredViewContainer !== viewContainer) {
	                if (!this.declaredViewContainer.projectedViews) {
	                    this.declaredViewContainer.projectedViews = [];
	                }
	                this.declaredViewContainer.projectedViews.push(this);
	            }
	            this.dirtyParentQueriesInternal();
	        };
	        /**
	         * @param {?} viewContainer
	         * @param {?} prevView
	         * @return {?}
	         */
	        AppView.prototype.moveAfter = function (viewContainer, prevView) {
	            this._renderAttach(viewContainer, prevView);
	            this.dirtyParentQueriesInternal();
	        };
	        /**
	         * @param {?} viewContainer
	         * @param {?} prevView
	         * @return {?}
	         */
	        AppView.prototype._renderAttach = function (viewContainer, prevView) {
	            var /** @type {?} */ prevNode = prevView ? prevView.lastRootNode : viewContainer.nativeElement;
	            if (this._directRenderer) {
	                var /** @type {?} */ nextSibling = this._directRenderer.nextSibling(prevNode);
	                if (nextSibling) {
	                    this.visitRootNodesInternal(this._directRenderer.insertBefore, nextSibling);
	                }
	                else {
	                    var /** @type {?} */ parentElement = this._directRenderer.parentElement(prevNode);
	                    if (parentElement) {
	                        this.visitRootNodesInternal(this._directRenderer.appendChild, parentElement);
	                    }
	                }
	            }
	            else {
	                this.renderer.attachViewAfter(prevNode, this.flatRootNodes);
	            }
	        };
	        Object.defineProperty(AppView.prototype, "changeDetectorRef", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.ref; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(AppView.prototype, "flatRootNodes", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                var /** @type {?} */ nodes = [];
	                this.visitRootNodesInternal(addToArray, nodes);
	                return nodes;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} parentElement
	         * @param {?} ngContentIndex
	         * @return {?}
	         */
	        AppView.prototype.projectNodes = function (parentElement, ngContentIndex) {
	            if (this._directRenderer) {
	                this.visitProjectedNodes(ngContentIndex, this._directRenderer.appendChild, parentElement);
	            }
	            else {
	                var /** @type {?} */ nodes = [];
	                this.visitProjectedNodes(ngContentIndex, addToArray, nodes);
	                this.renderer.projectNodes(parentElement, nodes);
	            }
	        };
	        /**
	         * @param {?} ngContentIndex
	         * @param {?} cb
	         * @param {?} c
	         * @return {?}
	         */
	        AppView.prototype.visitProjectedNodes = function (ngContentIndex, cb, c) {
	            switch (this.type) {
	                case ViewType.EMBEDDED:
	                    this.parentView.visitProjectedNodes(ngContentIndex, cb, c);
	                    break;
	                case ViewType.COMPONENT:
	                    if (this.parentView.type === ViewType.HOST) {
	                        var /** @type {?} */ nodes = this.parentView._hostProjectableNodes[ngContentIndex] || [];
	                        for (var /** @type {?} */ i = 0; i < nodes.length; i++) {
	                            cb(nodes[i], c);
	                        }
	                    }
	                    else {
	                        this.parentView.visitProjectableNodesInternal(this.parentIndex, ngContentIndex, cb, c);
	                    }
	                    break;
	            }
	        };
	        /**
	         * Overwritten by implementations
	         * @param {?} cb
	         * @param {?} c
	         * @return {?}
	         */
	        AppView.prototype.visitRootNodesInternal = function (cb, c) { };
	        /**
	         * Overwritten by implementations
	         * @param {?} nodeIndex
	         * @param {?} ngContentIndex
	         * @param {?} cb
	         * @param {?} c
	         * @return {?}
	         */
	        AppView.prototype.visitProjectableNodesInternal = function (nodeIndex, ngContentIndex, cb, c) { };
	        /**
	         * Overwritten by implementations
	         * @return {?}
	         */
	        AppView.prototype.dirtyParentQueriesInternal = function () { };
	        /**
	         * @param {?} throwOnChange
	         * @return {?}
	         */
	        AppView.prototype.internalDetectChanges = function (throwOnChange) {
	            if (this.cdMode !== ChangeDetectorStatus.Detached) {
	                this.detectChanges(throwOnChange);
	            }
	        };
	        /**
	         * @param {?} throwOnChange
	         * @return {?}
	         */
	        AppView.prototype.detectChanges = function (throwOnChange) {
	            var /** @type {?} */ s = _scope_check(this.clazz);
	            if (this.cdMode === ChangeDetectorStatus.Checked ||
	                this.cdMode === ChangeDetectorStatus.Errored)
	                return;
	            if (this.cdMode === ChangeDetectorStatus.Destroyed) {
	                this.throwDestroyedError('detectChanges');
	            }
	            this.detectChangesInternal(throwOnChange);
	            if (this.cdMode === ChangeDetectorStatus.CheckOnce)
	                this.cdMode = ChangeDetectorStatus.Checked;
	            this.numberOfChecks++;
	            wtfLeave(s);
	        };
	        /**
	         * Overwritten by implementations
	         * @param {?} throwOnChange
	         * @return {?}
	         */
	        AppView.prototype.detectChangesInternal = function (throwOnChange) { };
	        /**
	         * @return {?}
	         */
	        AppView.prototype.markAsCheckOnce = function () { this.cdMode = ChangeDetectorStatus.CheckOnce; };
	        /**
	         * @return {?}
	         */
	        AppView.prototype.markPathToRootAsCheckOnce = function () {
	            var /** @type {?} */ c = this;
	            while (isPresent(c) && c.cdMode !== ChangeDetectorStatus.Detached) {
	                if (c.cdMode === ChangeDetectorStatus.Checked) {
	                    c.cdMode = ChangeDetectorStatus.CheckOnce;
	                }
	                if (c.type === ViewType.COMPONENT) {
	                    c = c.parentView;
	                }
	                else {
	                    c = c.viewContainer ? c.viewContainer.parentView : null;
	                }
	            }
	        };
	        /**
	         * @param {?} cb
	         * @return {?}
	         */
	        AppView.prototype.eventHandler = function (cb) {
	            return cb;
	        };
	        /**
	         * @param {?} details
	         * @return {?}
	         */
	        AppView.prototype.throwDestroyedError = function (details) { throw new ViewDestroyedError(details); };
	        return AppView;
	    }());
	    var DebugAppView = (function (_super) {
	        __extends$14(DebugAppView, _super);
	        /**
	         * @param {?} clazz
	         * @param {?} componentType
	         * @param {?} type
	         * @param {?} viewUtils
	         * @param {?} parentView
	         * @param {?} parentIndex
	         * @param {?} parentNode
	         * @param {?} cdMode
	         * @param {?} staticNodeDebugInfos
	         * @param {?=} declaredViewContainer
	         */
	        function DebugAppView(clazz, componentType, type, viewUtils, parentView, parentIndex, parentNode, cdMode, staticNodeDebugInfos, declaredViewContainer) {
	            if (declaredViewContainer === void 0) { declaredViewContainer = null; }
	            _super.call(this, clazz, componentType, type, viewUtils, parentView, parentIndex, parentNode, cdMode, declaredViewContainer);
	            this.staticNodeDebugInfos = staticNodeDebugInfos;
	            this._currentDebugContext = null;
	        }
	        /**
	         * @param {?} context
	         * @return {?}
	         */
	        DebugAppView.prototype.create = function (context) {
	            this._resetDebug();
	            try {
	                return _super.prototype.create.call(this, context);
	            }
	            catch (e) {
	                this._rethrowWithContext(e);
	                throw e;
	            }
	        };
	        /**
	         * @param {?} rootSelectorOrNode
	         * @param {?} injector
	         * @param {?=} projectableNodes
	         * @return {?}
	         */
	        DebugAppView.prototype.createHostView = function (rootSelectorOrNode, injector, projectableNodes) {
	            if (projectableNodes === void 0) { projectableNodes = null; }
	            this._resetDebug();
	            try {
	                return _super.prototype.createHostView.call(this, rootSelectorOrNode, injector, projectableNodes);
	            }
	            catch (e) {
	                this._rethrowWithContext(e);
	                throw e;
	            }
	        };
	        /**
	         * @param {?} token
	         * @param {?} nodeIndex
	         * @param {?=} notFoundResult
	         * @return {?}
	         */
	        DebugAppView.prototype.injectorGet = function (token, nodeIndex, notFoundResult) {
	            this._resetDebug();
	            try {
	                return _super.prototype.injectorGet.call(this, token, nodeIndex, notFoundResult);
	            }
	            catch (e) {
	                this._rethrowWithContext(e);
	                throw e;
	            }
	        };
	        /**
	         * @return {?}
	         */
	        DebugAppView.prototype.detach = function () {
	            this._resetDebug();
	            try {
	                _super.prototype.detach.call(this);
	            }
	            catch (e) {
	                this._rethrowWithContext(e);
	                throw e;
	            }
	        };
	        /**
	         * @return {?}
	         */
	        DebugAppView.prototype.destroy = function () {
	            this._resetDebug();
	            try {
	                _super.prototype.destroy.call(this);
	            }
	            catch (e) {
	                this._rethrowWithContext(e);
	                throw e;
	            }
	        };
	        /**
	         * @param {?} throwOnChange
	         * @return {?}
	         */
	        DebugAppView.prototype.detectChanges = function (throwOnChange) {
	            this._resetDebug();
	            try {
	                _super.prototype.detectChanges.call(this, throwOnChange);
	            }
	            catch (e) {
	                this._rethrowWithContext(e);
	                throw e;
	            }
	        };
	        /**
	         * @return {?}
	         */
	        DebugAppView.prototype._resetDebug = function () { this._currentDebugContext = null; };
	        /**
	         * @param {?} nodeIndex
	         * @param {?} rowNum
	         * @param {?} colNum
	         * @return {?}
	         */
	        DebugAppView.prototype.debug = function (nodeIndex, rowNum, colNum) {
	            return this._currentDebugContext = new DebugContext(this, nodeIndex, rowNum, colNum);
	        };
	        /**
	         * @param {?} e
	         * @return {?}
	         */
	        DebugAppView.prototype._rethrowWithContext = function (e) {
	            if (!(e instanceof ViewWrappedError)) {
	                if (!(e instanceof ExpressionChangedAfterItHasBeenCheckedError)) {
	                    this.cdMode = ChangeDetectorStatus.Errored;
	                }
	                if (isPresent(this._currentDebugContext)) {
	                    throw new ViewWrappedError(e, this._currentDebugContext);
	                }
	            }
	        };
	        /**
	         * @param {?} cb
	         * @return {?}
	         */
	        DebugAppView.prototype.eventHandler = function (cb) {
	            var _this = this;
	            var /** @type {?} */ superHandler = _super.prototype.eventHandler.call(this, cb);
	            return function (eventName, event) {
	                _this._resetDebug();
	                try {
	                    return superHandler.call(_this, eventName, event);
	                }
	                catch (e) {
	                    _this._rethrowWithContext(e);
	                    throw e;
	                }
	            };
	        };
	        return DebugAppView;
	    }(AppView));

	    /**
	     * A ViewContainer is created for elements that have a ViewContainerRef
	     * to keep track of the nested views.
	     */
	    var ViewContainer = (function () {
	        /**
	         * @param {?} index
	         * @param {?} parentIndex
	         * @param {?} parentView
	         * @param {?} nativeElement
	         */
	        function ViewContainer(index, parentIndex, parentView, nativeElement) {
	            this.index = index;
	            this.parentIndex = parentIndex;
	            this.parentView = parentView;
	            this.nativeElement = nativeElement;
	        }
	        Object.defineProperty(ViewContainer.prototype, "elementRef", {
	            /**
	             * @return {?}
	             */
	            get: function () { return new ElementRef(this.nativeElement); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ViewContainer.prototype, "vcRef", {
	            /**
	             * @return {?}
	             */
	            get: function () { return new ViewContainerRef_(this); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ViewContainer.prototype, "parentInjector", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.parentView.injector(this.parentIndex); },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(ViewContainer.prototype, "injector", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.parentView.injector(this.index); },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} throwOnChange
	         * @return {?}
	         */
	        ViewContainer.prototype.detectChangesInNestedViews = function (throwOnChange) {
	            if (this.nestedViews) {
	                for (var /** @type {?} */ i = 0; i < this.nestedViews.length; i++) {
	                    this.nestedViews[i].detectChanges(throwOnChange);
	                }
	            }
	        };
	        /**
	         * @return {?}
	         */
	        ViewContainer.prototype.destroyNestedViews = function () {
	            if (this.nestedViews) {
	                for (var /** @type {?} */ i = 0; i < this.nestedViews.length; i++) {
	                    this.nestedViews[i].destroy();
	                }
	            }
	        };
	        /**
	         * @param {?} cb
	         * @param {?} c
	         * @return {?}
	         */
	        ViewContainer.prototype.visitNestedViewRootNodes = function (cb, c) {
	            if (this.nestedViews) {
	                for (var /** @type {?} */ i = 0; i < this.nestedViews.length; i++) {
	                    this.nestedViews[i].visitRootNodesInternal(cb, c);
	                }
	            }
	        };
	        /**
	         * @param {?} nestedViewClass
	         * @param {?} callback
	         * @return {?}
	         */
	        ViewContainer.prototype.mapNestedViews = function (nestedViewClass, callback) {
	            var /** @type {?} */ result = [];
	            if (this.nestedViews) {
	                for (var /** @type {?} */ i = 0; i < this.nestedViews.length; i++) {
	                    var /** @type {?} */ nestedView = this.nestedViews[i];
	                    if (nestedView.clazz === nestedViewClass) {
	                        result.push(callback(nestedView));
	                    }
	                }
	            }
	            if (this.projectedViews) {
	                for (var /** @type {?} */ i = 0; i < this.projectedViews.length; i++) {
	                    var /** @type {?} */ projectedView = this.projectedViews[i];
	                    if (projectedView.clazz === nestedViewClass) {
	                        result.push(callback(projectedView));
	                    }
	                }
	            }
	            return result;
	        };
	        /**
	         * @param {?} view
	         * @param {?} currentIndex
	         * @return {?}
	         */
	        ViewContainer.prototype.moveView = function (view, currentIndex) {
	            var /** @type {?} */ previousIndex = this.nestedViews.indexOf(view);
	            if (view.type === ViewType.COMPONENT) {
	                throw new Error("Component views can't be moved!");
	            }
	            var /** @type {?} */ nestedViews = this.nestedViews;
	            if (nestedViews == null) {
	                nestedViews = [];
	                this.nestedViews = nestedViews;
	            }
	            nestedViews.splice(previousIndex, 1);
	            nestedViews.splice(currentIndex, 0, view);
	            var /** @type {?} */ prevView = currentIndex > 0 ? nestedViews[currentIndex - 1] : null;
	            view.moveAfter(this, prevView);
	        };
	        /**
	         * @param {?} view
	         * @param {?} viewIndex
	         * @return {?}
	         */
	        ViewContainer.prototype.attachView = function (view, viewIndex) {
	            if (view.type === ViewType.COMPONENT) {
	                throw new Error("Component views can't be moved!");
	            }
	            var /** @type {?} */ nestedViews = this.nestedViews;
	            if (nestedViews == null) {
	                nestedViews = [];
	                this.nestedViews = nestedViews;
	            }
	            // perf: array.push is faster than array.splice!
	            if (viewIndex >= nestedViews.length) {
	                nestedViews.push(view);
	            }
	            else {
	                nestedViews.splice(viewIndex, 0, view);
	            }
	            var /** @type {?} */ prevView = viewIndex > 0 ? nestedViews[viewIndex - 1] : null;
	            view.attachAfter(this, prevView);
	        };
	        /**
	         * @param {?} viewIndex
	         * @return {?}
	         */
	        ViewContainer.prototype.detachView = function (viewIndex) {
	            var /** @type {?} */ view = this.nestedViews[viewIndex];
	            // perf: array.pop is faster than array.splice!
	            if (viewIndex >= this.nestedViews.length - 1) {
	                this.nestedViews.pop();
	            }
	            else {
	                this.nestedViews.splice(viewIndex, 1);
	            }
	            if (view.type === ViewType.COMPONENT) {
	                throw new Error("Component views can't be moved!");
	            }
	            view.detach();
	            return view;
	        };
	        return ViewContainer;
	    }());

	    var /** @type {?} */ __core_private__ = {
	        isDefaultChangeDetectionStrategy: isDefaultChangeDetectionStrategy,
	        ChangeDetectorStatus: ChangeDetectorStatus,
	        constructDependencies: constructDependencies,
	        LifecycleHooks: LifecycleHooks,
	        LIFECYCLE_HOOKS_VALUES: LIFECYCLE_HOOKS_VALUES,
	        ReflectorReader: ReflectorReader,
	        CodegenComponentFactoryResolver: CodegenComponentFactoryResolver,
	        ComponentRef_: ComponentRef_,
	        ViewContainer: ViewContainer,
	        AppView: AppView,
	        DebugAppView: DebugAppView,
	        NgModuleInjector: NgModuleInjector,
	        registerModuleFactory: registerModuleFactory,
	        ViewType: ViewType,
	        view_utils: view_utils,
	        ViewMetadata: ViewMetadata,
	        DebugContext: DebugContext,
	        StaticNodeDebugInfo: StaticNodeDebugInfo,
	        devModeEqual: devModeEqual,
	        UNINITIALIZED: UNINITIALIZED,
	        ValueUnwrapper: ValueUnwrapper,
	        RenderDebugInfo: RenderDebugInfo,
	        TemplateRef_: TemplateRef_,
	        ReflectionCapabilities: ReflectionCapabilities,
	        makeDecorator: makeDecorator,
	        DebugDomRootRenderer: DebugDomRootRenderer,
	        Console: Console,
	        reflector: reflector,
	        Reflector: Reflector,
	        NoOpAnimationPlayer: NoOpAnimationPlayer,
	        AnimationPlayer: AnimationPlayer,
	        AnimationSequencePlayer: AnimationSequencePlayer,
	        AnimationGroupPlayer: AnimationGroupPlayer,
	        AnimationKeyframe: AnimationKeyframe,
	        prepareFinalAnimationStyles: prepareFinalAnimationStyles,
	        balanceAnimationKeyframes: balanceAnimationKeyframes,
	        flattenStyles: flattenStyles,
	        clearStyles: clearStyles,
	        renderStyles: renderStyles,
	        collectAndResolveStyles: collectAndResolveStyles,
	        APP_ID_RANDOM_PROVIDER: APP_ID_RANDOM_PROVIDER,
	        AnimationStyles: AnimationStyles,
	        ANY_STATE: ANY_STATE,
	        DEFAULT_STATE: DEFAULT_STATE,
	        EMPTY_STATE: EMPTY_STATE,
	        FILL_STYLE_FLAG: FILL_STYLE_FLAG,
	        ComponentStillLoadingError: ComponentStillLoadingError,
	        isPromise: isPromise,
	        AnimationTransition: AnimationTransition
	    };

	    exports.createPlatform = createPlatform;
	    exports.assertPlatform = assertPlatform;
	    exports.destroyPlatform = destroyPlatform;
	    exports.getPlatform = getPlatform;
	    exports.PlatformRef = PlatformRef;
	    exports.ApplicationRef = ApplicationRef;
	    exports.enableProdMode = enableProdMode;
	    exports.isDevMode = isDevMode;
	    exports.createPlatformFactory = createPlatformFactory;
	    exports.NgProbeToken = NgProbeToken;
	    exports.APP_ID = APP_ID;
	    exports.PACKAGE_ROOT_URL = PACKAGE_ROOT_URL;
	    exports.PLATFORM_INITIALIZER = PLATFORM_INITIALIZER;
	    exports.APP_BOOTSTRAP_LISTENER = APP_BOOTSTRAP_LISTENER;
	    exports.APP_INITIALIZER = APP_INITIALIZER;
	    exports.ApplicationInitStatus = ApplicationInitStatus;
	    exports.DebugElement = DebugElement;
	    exports.DebugNode = DebugNode;
	    exports.asNativeElements = asNativeElements;
	    exports.getDebugNode = getDebugNode;
	    exports.Testability = Testability;
	    exports.TestabilityRegistry = TestabilityRegistry;
	    exports.setTestabilityGetter = setTestabilityGetter;
	    exports.TRANSLATIONS = TRANSLATIONS;
	    exports.TRANSLATIONS_FORMAT = TRANSLATIONS_FORMAT;
	    exports.LOCALE_ID = LOCALE_ID;
	    exports.ApplicationModule = ApplicationModule;
	    exports.wtfCreateScope = wtfCreateScope;
	    exports.wtfLeave = wtfLeave;
	    exports.wtfStartTimeRange = wtfStartTimeRange;
	    exports.wtfEndTimeRange = wtfEndTimeRange;
	    exports.Type = Type;
	    exports.EventEmitter = EventEmitter;
	    exports.ErrorHandler = ErrorHandler;
	    exports.AnimationTransitionEvent = AnimationTransitionEvent;
	    exports.AnimationPlayer = AnimationPlayer;
	    exports.Sanitizer = Sanitizer;
	    exports.SecurityContext = SecurityContext;
	    exports.ANALYZE_FOR_ENTRY_COMPONENTS = ANALYZE_FOR_ENTRY_COMPONENTS;
	    exports.Attribute = Attribute;
	    exports.ContentChild = ContentChild;
	    exports.ContentChildren = ContentChildren;
	    exports.Query = Query;
	    exports.ViewChild = ViewChild;
	    exports.ViewChildren = ViewChildren;
	    exports.Component = Component;
	    exports.Directive = Directive;
	    exports.HostBinding = HostBinding;
	    exports.HostListener = HostListener;
	    exports.Input = Input;
	    exports.Output = Output;
	    exports.Pipe = Pipe;
	    exports.AfterContentChecked = AfterContentChecked;
	    exports.AfterContentInit = AfterContentInit;
	    exports.AfterViewChecked = AfterViewChecked;
	    exports.AfterViewInit = AfterViewInit;
	    exports.DoCheck = DoCheck;
	    exports.OnChanges = OnChanges;
	    exports.OnDestroy = OnDestroy;
	    exports.OnInit = OnInit;
	    exports.CUSTOM_ELEMENTS_SCHEMA = CUSTOM_ELEMENTS_SCHEMA;
	    exports.NO_ERRORS_SCHEMA = NO_ERRORS_SCHEMA;
	    exports.NgModule = NgModule;
	    exports.ViewEncapsulation = ViewEncapsulation;
	    exports.Version = Version;
	    exports.VERSION = VERSION;
	    exports.Class = Class;
	    exports.forwardRef = forwardRef;
	    exports.resolveForwardRef = resolveForwardRef;
	    exports.Injector = Injector;
	    exports.ReflectiveInjector = ReflectiveInjector;
	    exports.ResolvedReflectiveFactory = ResolvedReflectiveFactory;
	    exports.ReflectiveKey = ReflectiveKey;
	    exports.OpaqueToken = OpaqueToken;
	    exports.Inject = Inject;
	    exports.Optional = Optional;
	    exports.Injectable = Injectable;
	    exports.Self = Self;
	    exports.SkipSelf = SkipSelf;
	    exports.Host = Host;
	    exports.NgZone = NgZone;
	    exports.RenderComponentType = RenderComponentType;
	    exports.Renderer = Renderer;
	    exports.RootRenderer = RootRenderer;
	    exports.COMPILER_OPTIONS = COMPILER_OPTIONS;
	    exports.Compiler = Compiler;
	    exports.CompilerFactory = CompilerFactory;
	    exports.ModuleWithComponentFactories = ModuleWithComponentFactories;
	    exports.ComponentFactory = ComponentFactory;
	    exports.ComponentRef = ComponentRef;
	    exports.ComponentFactoryResolver = ComponentFactoryResolver;
	    exports.ElementRef = ElementRef;
	    exports.NgModuleFactory = NgModuleFactory;
	    exports.NgModuleRef = NgModuleRef;
	    exports.NgModuleFactoryLoader = NgModuleFactoryLoader;
	    exports.getModuleFactory = getModuleFactory;
	    exports.QueryList = QueryList;
	    exports.SystemJsNgModuleLoader = SystemJsNgModuleLoader;
	    exports.SystemJsNgModuleLoaderConfig = SystemJsNgModuleLoaderConfig;
	    exports.TemplateRef = TemplateRef;
	    exports.ViewContainerRef = ViewContainerRef;
	    exports.EmbeddedViewRef = EmbeddedViewRef;
	    exports.ViewRef = ViewRef;
	    exports.ChangeDetectionStrategy = ChangeDetectionStrategy;
	    exports.ChangeDetectorRef = ChangeDetectorRef;
	    exports.CollectionChangeRecord = CollectionChangeRecord;
	    exports.DefaultIterableDiffer = DefaultIterableDiffer;
	    exports.IterableDiffers = IterableDiffers;
	    exports.KeyValueChangeRecord = KeyValueChangeRecord;
	    exports.KeyValueDiffers = KeyValueDiffers;
	    exports.SimpleChange = SimpleChange;
	    exports.WrappedValue = WrappedValue;
	    exports.platformCore = platformCore;
	    exports.__core_private__ = __core_private__;
	    exports.AUTO_STYLE = AUTO_STYLE;
	    exports.AnimationEntryMetadata = AnimationEntryMetadata;
	    exports.AnimationStateMetadata = AnimationStateMetadata;
	    exports.AnimationStateDeclarationMetadata = AnimationStateDeclarationMetadata;
	    exports.AnimationStateTransitionMetadata = AnimationStateTransitionMetadata;
	    exports.AnimationMetadata = AnimationMetadata;
	    exports.AnimationKeyframesSequenceMetadata = AnimationKeyframesSequenceMetadata;
	    exports.AnimationStyleMetadata = AnimationStyleMetadata;
	    exports.AnimationAnimateMetadata = AnimationAnimateMetadata;
	    exports.AnimationWithStepsMetadata = AnimationWithStepsMetadata;
	    exports.AnimationSequenceMetadata = AnimationSequenceMetadata;
	    exports.AnimationGroupMetadata = AnimationGroupMetadata;
	    exports.animate = animate;
	    exports.group = group;
	    exports.sequence = sequence;
	    exports.style = style;
	    exports.state = state;
	    exports.keyframes = keyframes;
	    exports.transition = transition;
	    exports.trigger = trigger;

	}));
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(30);
	var Subscriber_1 = __webpack_require__(33);
	var Subscription_1 = __webpack_require__(35);
	var ObjectUnsubscribedError_1 = __webpack_require__(44);
	var SubjectSubscription_1 = __webpack_require__(45);
	var rxSubscriber_1 = __webpack_require__(42);
	/**
	 * @class SubjectSubscriber<T>
	 */
	var SubjectSubscriber = (function (_super) {
	    __extends(SubjectSubscriber, _super);
	    function SubjectSubscriber(destination) {
	        _super.call(this, destination);
	        this.destination = destination;
	    }
	    return SubjectSubscriber;
	}(Subscriber_1.Subscriber));
	exports.SubjectSubscriber = SubjectSubscriber;
	/**
	 * @class Subject<T>
	 */
	var Subject = (function (_super) {
	    __extends(Subject, _super);
	    function Subject() {
	        _super.call(this);
	        this.observers = [];
	        this.closed = false;
	        this.isStopped = false;
	        this.hasError = false;
	        this.thrownError = null;
	    }
	    Subject.prototype[rxSubscriber_1.$$rxSubscriber] = function () {
	        return new SubjectSubscriber(this);
	    };
	    Subject.prototype.lift = function (operator) {
	        var subject = new AnonymousSubject(this, this);
	        subject.operator = operator;
	        return subject;
	    };
	    Subject.prototype.next = function (value) {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        if (!this.isStopped) {
	            var observers = this.observers;
	            var len = observers.length;
	            var copy = observers.slice();
	            for (var i = 0; i < len; i++) {
	                copy[i].next(value);
	            }
	        }
	    };
	    Subject.prototype.error = function (err) {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        this.hasError = true;
	        this.thrownError = err;
	        this.isStopped = true;
	        var observers = this.observers;
	        var len = observers.length;
	        var copy = observers.slice();
	        for (var i = 0; i < len; i++) {
	            copy[i].error(err);
	        }
	        this.observers.length = 0;
	    };
	    Subject.prototype.complete = function () {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        this.isStopped = true;
	        var observers = this.observers;
	        var len = observers.length;
	        var copy = observers.slice();
	        for (var i = 0; i < len; i++) {
	            copy[i].complete();
	        }
	        this.observers.length = 0;
	    };
	    Subject.prototype.unsubscribe = function () {
	        this.isStopped = true;
	        this.closed = true;
	        this.observers = null;
	    };
	    Subject.prototype._subscribe = function (subscriber) {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        else if (this.hasError) {
	            subscriber.error(this.thrownError);
	            return Subscription_1.Subscription.EMPTY;
	        }
	        else if (this.isStopped) {
	            subscriber.complete();
	            return Subscription_1.Subscription.EMPTY;
	        }
	        else {
	            this.observers.push(subscriber);
	            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
	        }
	    };
	    Subject.prototype.asObservable = function () {
	        var observable = new Observable_1.Observable();
	        observable.source = this;
	        return observable;
	    };
	    Subject.create = function (destination, source) {
	        return new AnonymousSubject(destination, source);
	    };
	    return Subject;
	}(Observable_1.Observable));
	exports.Subject = Subject;
	/**
	 * @class AnonymousSubject<T>
	 */
	var AnonymousSubject = (function (_super) {
	    __extends(AnonymousSubject, _super);
	    function AnonymousSubject(destination, source) {
	        _super.call(this);
	        this.destination = destination;
	        this.source = source;
	    }
	    AnonymousSubject.prototype.next = function (value) {
	        var destination = this.destination;
	        if (destination && destination.next) {
	            destination.next(value);
	        }
	    };
	    AnonymousSubject.prototype.error = function (err) {
	        var destination = this.destination;
	        if (destination && destination.error) {
	            this.destination.error(err);
	        }
	    };
	    AnonymousSubject.prototype.complete = function () {
	        var destination = this.destination;
	        if (destination && destination.complete) {
	            this.destination.complete();
	        }
	    };
	    AnonymousSubject.prototype._subscribe = function (subscriber) {
	        var source = this.source;
	        if (source) {
	            return this.source.subscribe(subscriber);
	        }
	        else {
	            return Subscription_1.Subscription.EMPTY;
	        }
	    };
	    return AnonymousSubject;
	}(Subject));
	exports.AnonymousSubject = AnonymousSubject;
	//# sourceMappingURL=Subject.js.map

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(31);
	var toSubscriber_1 = __webpack_require__(32);
	var observable_1 = __webpack_require__(43);
	/**
	 * A representation of any set of values over any amount of time. This the most basic building block
	 * of RxJS.
	 *
	 * @class Observable<T>
	 */
	var Observable = (function () {
	    /**
	     * @constructor
	     * @param {Function} subscribe the function that is  called when the Observable is
	     * initially subscribed to. This function is given a Subscriber, to which new values
	     * can be `next`ed, or an `error` method can be called to raise an error, or
	     * `complete` can be called to notify of a successful completion.
	     */
	    function Observable(subscribe) {
	        this._isScalar = false;
	        if (subscribe) {
	            this._subscribe = subscribe;
	        }
	    }
	    /**
	     * Creates a new Observable, with this Observable as the source, and the passed
	     * operator defined as the new observable's operator.
	     * @method lift
	     * @param {Operator} operator the operator defining the operation to take on the observable
	     * @return {Observable} a new observable with the Operator applied
	     */
	    Observable.prototype.lift = function (operator) {
	        var observable = new Observable();
	        observable.source = this;
	        observable.operator = operator;
	        return observable;
	    };
	    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
	        var operator = this.operator;
	        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
	        if (operator) {
	            operator.call(sink, this.source);
	        }
	        else {
	            sink.add(this._subscribe(sink));
	        }
	        if (sink.syncErrorThrowable) {
	            sink.syncErrorThrowable = false;
	            if (sink.syncErrorThrown) {
	                throw sink.syncErrorValue;
	            }
	        }
	        return sink;
	    };
	    /**
	     * @method forEach
	     * @param {Function} next a handler for each value emitted by the observable
	     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
	     * @return {Promise} a promise that either resolves on observable completion or
	     *  rejects with the handled error
	     */
	    Observable.prototype.forEach = function (next, PromiseCtor) {
	        var _this = this;
	        if (!PromiseCtor) {
	            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
	                PromiseCtor = root_1.root.Rx.config.Promise;
	            }
	            else if (root_1.root.Promise) {
	                PromiseCtor = root_1.root.Promise;
	            }
	        }
	        if (!PromiseCtor) {
	            throw new Error('no Promise impl found');
	        }
	        return new PromiseCtor(function (resolve, reject) {
	            var subscription = _this.subscribe(function (value) {
	                if (subscription) {
	                    // if there is a subscription, then we can surmise
	                    // the next handling is asynchronous. Any errors thrown
	                    // need to be rejected explicitly and unsubscribe must be
	                    // called manually
	                    try {
	                        next(value);
	                    }
	                    catch (err) {
	                        reject(err);
	                        subscription.unsubscribe();
	                    }
	                }
	                else {
	                    // if there is NO subscription, then we're getting a nexted
	                    // value synchronously during subscription. We can just call it.
	                    // If it errors, Observable's `subscribe` will ensure the
	                    // unsubscription logic is called, then synchronously rethrow the error.
	                    // After that, Promise will trap the error and send it
	                    // down the rejection path.
	                    next(value);
	                }
	            }, reject, resolve);
	        });
	    };
	    Observable.prototype._subscribe = function (subscriber) {
	        return this.source.subscribe(subscriber);
	    };
	    /**
	     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
	     * @method Symbol.observable
	     * @return {Observable} this instance of the observable
	     */
	    Observable.prototype[observable_1.$$observable] = function () {
	        return this;
	    };
	    // HACK: Since TypeScript inherits static properties too, we have to
	    // fight against TypeScript here so Subject can have a different static create signature
	    /**
	     * Creates a new cold Observable by calling the Observable constructor
	     * @static true
	     * @owner Observable
	     * @method create
	     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
	     * @return {Observable} a new cold observable
	     */
	    Observable.create = function (subscribe) {
	        return new Observable(subscribe);
	    };
	    return Observable;
	}());
	exports.Observable = Observable;
	//# sourceMappingURL=Observable.js.map

/***/ },
/* 31 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	/**
	 * window: browser in DOM main thread
	 * self: browser in WebWorker
	 * global: Node.js/other
	 */
	exports.root = (typeof window == 'object' && window.window === window && window
	    || typeof self == 'object' && self.self === self && self
	    || typeof global == 'object' && global.global === global && global);
	if (!exports.root) {
	    throw new Error('RxJS could not find any global context (window, self, global)');
	}
	//# sourceMappingURL=root.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Subscriber_1 = __webpack_require__(33);
	var rxSubscriber_1 = __webpack_require__(42);
	var Observer_1 = __webpack_require__(41);
	function toSubscriber(nextOrObserver, error, complete) {
	    if (nextOrObserver) {
	        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
	            return nextOrObserver;
	        }
	        if (nextOrObserver[rxSubscriber_1.$$rxSubscriber]) {
	            return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();
	        }
	    }
	    if (!nextOrObserver && !error && !complete) {
	        return new Subscriber_1.Subscriber(Observer_1.empty);
	    }
	    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
	}
	exports.toSubscriber = toSubscriber;
	//# sourceMappingURL=toSubscriber.js.map

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isFunction_1 = __webpack_require__(34);
	var Subscription_1 = __webpack_require__(35);
	var Observer_1 = __webpack_require__(41);
	var rxSubscriber_1 = __webpack_require__(42);
	/**
	 * Implements the {@link Observer} interface and extends the
	 * {@link Subscription} class. While the {@link Observer} is the public API for
	 * consuming the values of an {@link Observable}, all Observers get converted to
	 * a Subscriber, in order to provide Subscription-like capabilities such as
	 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
	 * implementing operators, but it is rarely used as a public API.
	 *
	 * @class Subscriber<T>
	 */
	var Subscriber = (function (_super) {
	    __extends(Subscriber, _super);
	    /**
	     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
	     * defined Observer or a `next` callback function.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     */
	    function Subscriber(destinationOrNext, error, complete) {
	        _super.call(this);
	        this.syncErrorValue = null;
	        this.syncErrorThrown = false;
	        this.syncErrorThrowable = false;
	        this.isStopped = false;
	        switch (arguments.length) {
	            case 0:
	                this.destination = Observer_1.empty;
	                break;
	            case 1:
	                if (!destinationOrNext) {
	                    this.destination = Observer_1.empty;
	                    break;
	                }
	                if (typeof destinationOrNext === 'object') {
	                    if (destinationOrNext instanceof Subscriber) {
	                        this.destination = destinationOrNext;
	                        this.destination.add(this);
	                    }
	                    else {
	                        this.syncErrorThrowable = true;
	                        this.destination = new SafeSubscriber(this, destinationOrNext);
	                    }
	                    break;
	                }
	            default:
	                this.syncErrorThrowable = true;
	                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
	                break;
	        }
	    }
	    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () { return this; };
	    /**
	     * A static factory for a Subscriber, given a (potentially partial) definition
	     * of an Observer.
	     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
	     * Observer represented by the given arguments.
	     */
	    Subscriber.create = function (next, error, complete) {
	        var subscriber = new Subscriber(next, error, complete);
	        subscriber.syncErrorThrowable = false;
	        return subscriber;
	    };
	    /**
	     * The {@link Observer} callback to receive notifications of type `next` from
	     * the Observable, with a value. The Observable may call this method 0 or more
	     * times.
	     * @param {T} [value] The `next` value.
	     * @return {void}
	     */
	    Subscriber.prototype.next = function (value) {
	        if (!this.isStopped) {
	            this._next(value);
	        }
	    };
	    /**
	     * The {@link Observer} callback to receive notifications of type `error` from
	     * the Observable, with an attached {@link Error}. Notifies the Observer that
	     * the Observable has experienced an error condition.
	     * @param {any} [err] The `error` exception.
	     * @return {void}
	     */
	    Subscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._error(err);
	        }
	    };
	    /**
	     * The {@link Observer} callback to receive a valueless notification of type
	     * `complete` from the Observable. Notifies the Observer that the Observable
	     * has finished sending push-based notifications.
	     * @return {void}
	     */
	    Subscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._complete();
	        }
	    };
	    Subscriber.prototype.unsubscribe = function () {
	        if (this.closed) {
	            return;
	        }
	        this.isStopped = true;
	        _super.prototype.unsubscribe.call(this);
	    };
	    Subscriber.prototype._next = function (value) {
	        this.destination.next(value);
	    };
	    Subscriber.prototype._error = function (err) {
	        this.destination.error(err);
	        this.unsubscribe();
	    };
	    Subscriber.prototype._complete = function () {
	        this.destination.complete();
	        this.unsubscribe();
	    };
	    return Subscriber;
	}(Subscription_1.Subscription));
	exports.Subscriber = Subscriber;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SafeSubscriber = (function (_super) {
	    __extends(SafeSubscriber, _super);
	    function SafeSubscriber(_parent, observerOrNext, error, complete) {
	        _super.call(this);
	        this._parent = _parent;
	        var next;
	        var context = this;
	        if (isFunction_1.isFunction(observerOrNext)) {
	            next = observerOrNext;
	        }
	        else if (observerOrNext) {
	            context = observerOrNext;
	            next = observerOrNext.next;
	            error = observerOrNext.error;
	            complete = observerOrNext.complete;
	            if (isFunction_1.isFunction(context.unsubscribe)) {
	                this.add(context.unsubscribe.bind(context));
	            }
	            context.unsubscribe = this.unsubscribe.bind(this);
	        }
	        this._context = context;
	        this._next = next;
	        this._error = error;
	        this._complete = complete;
	    }
	    SafeSubscriber.prototype.next = function (value) {
	        if (!this.isStopped && this._next) {
	            var _parent = this._parent;
	            if (!_parent.syncErrorThrowable) {
	                this.__tryOrUnsub(this._next, value);
	            }
	            else if (this.__tryOrSetError(_parent, this._next, value)) {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            var _parent = this._parent;
	            if (this._error) {
	                if (!_parent.syncErrorThrowable) {
	                    this.__tryOrUnsub(this._error, err);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parent, this._error, err);
	                    this.unsubscribe();
	                }
	            }
	            else if (!_parent.syncErrorThrowable) {
	                this.unsubscribe();
	                throw err;
	            }
	            else {
	                _parent.syncErrorValue = err;
	                _parent.syncErrorThrown = true;
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            var _parent = this._parent;
	            if (this._complete) {
	                if (!_parent.syncErrorThrowable) {
	                    this.__tryOrUnsub(this._complete);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parent, this._complete);
	                    this.unsubscribe();
	                }
	            }
	            else {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            this.unsubscribe();
	            throw err;
	        }
	    };
	    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            parent.syncErrorValue = err;
	            parent.syncErrorThrown = true;
	            return true;
	        }
	        return false;
	    };
	    SafeSubscriber.prototype._unsubscribe = function () {
	        var _parent = this._parent;
	        this._context = null;
	        this._parent = null;
	        _parent.unsubscribe();
	    };
	    return SafeSubscriber;
	}(Subscriber));
	//# sourceMappingURL=Subscriber.js.map

/***/ },
/* 34 */
/***/ function(module, exports) {

	"use strict";
	function isFunction(x) {
	    return typeof x === 'function';
	}
	exports.isFunction = isFunction;
	//# sourceMappingURL=isFunction.js.map

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var isArray_1 = __webpack_require__(36);
	var isObject_1 = __webpack_require__(37);
	var isFunction_1 = __webpack_require__(34);
	var tryCatch_1 = __webpack_require__(38);
	var errorObject_1 = __webpack_require__(39);
	var UnsubscriptionError_1 = __webpack_require__(40);
	/**
	 * Represents a disposable resource, such as the execution of an Observable. A
	 * Subscription has one important method, `unsubscribe`, that takes no argument
	 * and just disposes the resource held by the subscription.
	 *
	 * Additionally, subscriptions may be grouped together through the `add()`
	 * method, which will attach a child Subscription to the current Subscription.
	 * When a Subscription is unsubscribed, all its children (and its grandchildren)
	 * will be unsubscribed as well.
	 *
	 * @class Subscription
	 */
	var Subscription = (function () {
	    /**
	     * @param {function(): void} [unsubscribe] A function describing how to
	     * perform the disposal of resources when the `unsubscribe` method is called.
	     */
	    function Subscription(unsubscribe) {
	        /**
	         * A flag to indicate whether this Subscription has already been unsubscribed.
	         * @type {boolean}
	         */
	        this.closed = false;
	        if (unsubscribe) {
	            this._unsubscribe = unsubscribe;
	        }
	    }
	    /**
	     * Disposes the resources held by the subscription. May, for instance, cancel
	     * an ongoing Observable execution or cancel any other type of work that
	     * started when the Subscription was created.
	     * @return {void}
	     */
	    Subscription.prototype.unsubscribe = function () {
	        var hasErrors = false;
	        var errors;
	        if (this.closed) {
	            return;
	        }
	        this.closed = true;
	        var _a = this, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
	        this._subscriptions = null;
	        if (isFunction_1.isFunction(_unsubscribe)) {
	            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
	            if (trial === errorObject_1.errorObject) {
	                hasErrors = true;
	                (errors = errors || []).push(errorObject_1.errorObject.e);
	            }
	        }
	        if (isArray_1.isArray(_subscriptions)) {
	            var index = -1;
	            var len = _subscriptions.length;
	            while (++index < len) {
	                var sub = _subscriptions[index];
	                if (isObject_1.isObject(sub)) {
	                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
	                    if (trial === errorObject_1.errorObject) {
	                        hasErrors = true;
	                        errors = errors || [];
	                        var err = errorObject_1.errorObject.e;
	                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
	                            errors = errors.concat(err.errors);
	                        }
	                        else {
	                            errors.push(err);
	                        }
	                    }
	                }
	            }
	        }
	        if (hasErrors) {
	            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
	        }
	    };
	    /**
	     * Adds a tear down to be called during the unsubscribe() of this
	     * Subscription.
	     *
	     * If the tear down being added is a subscription that is already
	     * unsubscribed, is the same reference `add` is being called on, or is
	     * `Subscription.EMPTY`, it will not be added.
	     *
	     * If this subscription is already in an `closed` state, the passed
	     * tear down logic will be executed immediately.
	     *
	     * @param {TeardownLogic} teardown The additional logic to execute on
	     * teardown.
	     * @return {Subscription} Returns the Subscription used or created to be
	     * added to the inner subscriptions list. This Subscription can be used with
	     * `remove()` to remove the passed teardown logic from the inner subscriptions
	     * list.
	     */
	    Subscription.prototype.add = function (teardown) {
	        if (!teardown || (teardown === Subscription.EMPTY)) {
	            return Subscription.EMPTY;
	        }
	        if (teardown === this) {
	            return this;
	        }
	        var sub = teardown;
	        switch (typeof teardown) {
	            case 'function':
	                sub = new Subscription(teardown);
	            case 'object':
	                if (sub.closed || typeof sub.unsubscribe !== 'function') {
	                    break;
	                }
	                else if (this.closed) {
	                    sub.unsubscribe();
	                }
	                else {
	                    (this._subscriptions || (this._subscriptions = [])).push(sub);
	                }
	                break;
	            default:
	                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
	        }
	        return sub;
	    };
	    /**
	     * Removes a Subscription from the internal list of subscriptions that will
	     * unsubscribe during the unsubscribe process of this Subscription.
	     * @param {Subscription} subscription The subscription to remove.
	     * @return {void}
	     */
	    Subscription.prototype.remove = function (subscription) {
	        // HACK: This might be redundant because of the logic in `add()`
	        if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {
	            return;
	        }
	        var subscriptions = this._subscriptions;
	        if (subscriptions) {
	            var subscriptionIndex = subscriptions.indexOf(subscription);
	            if (subscriptionIndex !== -1) {
	                subscriptions.splice(subscriptionIndex, 1);
	            }
	        }
	    };
	    Subscription.EMPTY = (function (empty) {
	        empty.closed = true;
	        return empty;
	    }(new Subscription()));
	    return Subscription;
	}());
	exports.Subscription = Subscription;
	//# sourceMappingURL=Subscription.js.map

/***/ },
/* 36 */
/***/ function(module, exports) {

	"use strict";
	exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });
	//# sourceMappingURL=isArray.js.map

/***/ },
/* 37 */
/***/ function(module, exports) {

	"use strict";
	function isObject(x) {
	    return x != null && typeof x === 'object';
	}
	exports.isObject = isObject;
	//# sourceMappingURL=isObject.js.map

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var errorObject_1 = __webpack_require__(39);
	var tryCatchTarget;
	function tryCatcher() {
	    try {
	        return tryCatchTarget.apply(this, arguments);
	    }
	    catch (e) {
	        errorObject_1.errorObject.e = e;
	        return errorObject_1.errorObject;
	    }
	}
	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}
	exports.tryCatch = tryCatch;
	;
	//# sourceMappingURL=tryCatch.js.map

/***/ },
/* 39 */
/***/ function(module, exports) {

	"use strict";
	// typeof any so that it we don't have to cast when comparing a result to the error object
	exports.errorObject = { e: {} };
	//# sourceMappingURL=errorObject.js.map

/***/ },
/* 40 */
/***/ function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when one or more errors have occurred during the
	 * `unsubscribe` of a {@link Subscription}.
	 */
	var UnsubscriptionError = (function (_super) {
	    __extends(UnsubscriptionError, _super);
	    function UnsubscriptionError(errors) {
	        _super.call(this);
	        this.errors = errors;
	        var err = Error.call(this, errors ?
	            errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n  ') : '');
	        this.name = err.name = 'UnsubscriptionError';
	        this.stack = err.stack;
	        this.message = err.message;
	    }
	    return UnsubscriptionError;
	}(Error));
	exports.UnsubscriptionError = UnsubscriptionError;
	//# sourceMappingURL=UnsubscriptionError.js.map

/***/ },
/* 41 */
/***/ function(module, exports) {

	"use strict";
	exports.empty = {
	    closed: true,
	    next: function (value) { },
	    error: function (err) { throw err; },
	    complete: function () { }
	};
	//# sourceMappingURL=Observer.js.map

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(31);
	var Symbol = root_1.root.Symbol;
	exports.$$rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
	    Symbol.for('rxSubscriber') : '@@rxSubscriber';
	//# sourceMappingURL=rxSubscriber.js.map

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(31);
	function getSymbolObservable(context) {
	    var $$observable;
	    var Symbol = context.Symbol;
	    if (typeof Symbol === 'function') {
	        if (Symbol.observable) {
	            $$observable = Symbol.observable;
	        }
	        else {
	            $$observable = Symbol('observable');
	            Symbol.observable = $$observable;
	        }
	    }
	    else {
	        $$observable = '@@observable';
	    }
	    return $$observable;
	}
	exports.getSymbolObservable = getSymbolObservable;
	exports.$$observable = getSymbolObservable(root_1.root);
	//# sourceMappingURL=observable.js.map

/***/ },
/* 44 */
/***/ function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when an action is invalid because the object has been
	 * unsubscribed.
	 *
	 * @see {@link Subject}
	 * @see {@link BehaviorSubject}
	 *
	 * @class ObjectUnsubscribedError
	 */
	var ObjectUnsubscribedError = (function (_super) {
	    __extends(ObjectUnsubscribedError, _super);
	    function ObjectUnsubscribedError() {
	        var err = _super.call(this, 'object unsubscribed');
	        this.name = err.name = 'ObjectUnsubscribedError';
	        this.stack = err.stack;
	        this.message = err.message;
	    }
	    return ObjectUnsubscribedError;
	}(Error));
	exports.ObjectUnsubscribedError = ObjectUnsubscribedError;
	//# sourceMappingURL=ObjectUnsubscribedError.js.map

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscription_1 = __webpack_require__(35);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SubjectSubscription = (function (_super) {
	    __extends(SubjectSubscription, _super);
	    function SubjectSubscription(subject, subscriber) {
	        _super.call(this);
	        this.subject = subject;
	        this.subscriber = subscriber;
	        this.closed = false;
	    }
	    SubjectSubscription.prototype.unsubscribe = function () {
	        if (this.closed) {
	            return;
	        }
	        this.closed = true;
	        var subject = this.subject;
	        var observers = subject.observers;
	        this.subject = null;
	        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
	            return;
	        }
	        var subscriberIndex = observers.indexOf(this.subscriber);
	        if (subscriberIndex !== -1) {
	            observers.splice(subscriberIndex, 1);
	        }
	    };
	    return SubjectSubscription;
	}(Subscription_1.Subscription));
	exports.SubjectSubscription = SubjectSubscription;
	//# sourceMappingURL=SubjectSubscription.js.map

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * @license Angular v2.4.4
	 * (c) 2010-2016 Google, Inc. https://angular.io/
	 * License: MIT
	 */
	(function (global, factory) {
	     true ? factory(exports, __webpack_require__(47), __webpack_require__(28)) :
	    typeof define === 'function' && define.amd ? define(['exports', '@angular/common', '@angular/core'], factory) :
	    (factory((global.ng = global.ng || {}, global.ng.platformBrowser = global.ng.platformBrowser || {}),global.ng.common,global.ng.core));
	}(this, function (exports,_angular_common,core) { 'use strict';

	    var /** @type {?} */ DebugDomRootRenderer = core.__core_private__.DebugDomRootRenderer;
	    var /** @type {?} */ NoOpAnimationPlayer = core.__core_private__.NoOpAnimationPlayer;

	    /**
	     * \@experimental
	     */
	    var NoOpAnimationDriver = (function () {
	        function NoOpAnimationDriver() {
	        }
	        /**
	         * @param {?} element
	         * @param {?} startingStyles
	         * @param {?} keyframes
	         * @param {?} duration
	         * @param {?} delay
	         * @param {?} easing
	         * @param {?=} previousPlayers
	         * @return {?}
	         */
	        NoOpAnimationDriver.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing, previousPlayers) {
	            if (previousPlayers === void 0) { previousPlayers = []; }
	            return new NoOpAnimationPlayer();
	        };
	        return NoOpAnimationDriver;
	    }());
	    /**
	     * \@experimental
	     * @abstract
	     */
	    var AnimationDriver = (function () {
	        function AnimationDriver() {
	        }
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} startingStyles
	         * @param {?} keyframes
	         * @param {?} duration
	         * @param {?} delay
	         * @param {?} easing
	         * @param {?=} previousPlayers
	         * @return {?}
	         */
	        AnimationDriver.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing, previousPlayers) { };
	        AnimationDriver.NOOP = new NoOpAnimationDriver();
	        return AnimationDriver;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var /** @type {?} */ globalScope;
	    if (typeof window === 'undefined') {
	        if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
	            // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
	            globalScope = (self);
	        }
	        else {
	            globalScope = (global);
	        }
	    }
	    else {
	        globalScope = (window);
	    }
	    // Need to declare a new variable for global here since TypeScript
	    // exports the original value of the symbol.
	    var /** @type {?} */ global$1 = globalScope;
	    // TODO: remove calls to assert in production environment
	    // Note: Can't just export this and import in in other files
	    // as `assert` is a reserved keyword in Dart
	    global$1.assert = function assert(condition) {
	        // TODO: to be fixed properly via #2830, noop for now
	    };
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isPresent(obj) {
	        return obj != null;
	    }
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isBlank(obj) {
	        return obj == null;
	    }
	    /**
	     * @param {?} token
	     * @return {?}
	     */
	    function stringify(token) {
	        if (typeof token === 'string') {
	            return token;
	        }
	        if (token == null) {
	            return '' + token;
	        }
	        if (token.overriddenName) {
	            return "" + token.overriddenName;
	        }
	        if (token.name) {
	            return "" + token.name;
	        }
	        var /** @type {?} */ res = token.toString();
	        var /** @type {?} */ newLineIndex = res.indexOf('\n');
	        return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
	    }
	    /**
	     * @param {?} global
	     * @param {?} path
	     * @param {?} value
	     * @return {?}
	     */
	    function setValueOnPath(global, path, value) {
	        var /** @type {?} */ parts = path.split('.');
	        var /** @type {?} */ obj = global;
	        while (parts.length > 1) {
	            var /** @type {?} */ name_1 = parts.shift();
	            if (obj.hasOwnProperty(name_1) && obj[name_1] != null) {
	                obj = obj[name_1];
	            }
	            else {
	                obj = obj[name_1] = {};
	            }
	        }
	        if (obj === undefined || obj === null) {
	            obj = {};
	        }
	        obj[parts.shift()] = value;
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var /** @type {?} */ _DOM = null;
	    /**
	     * @return {?}
	     */
	    function getDOM() {
	        return _DOM;
	    }
	    /**
	     * @param {?} adapter
	     * @return {?}
	     */
	    function setRootDomAdapter(adapter) {
	        if (!_DOM) {
	            _DOM = adapter;
	        }
	    }
	    /**
	     * Provides DOM operations in an environment-agnostic way.
	     *
	     * \@security Tread carefully! Interacting with the DOM directly is dangerous and
	     * can introduce XSS risks.
	     * @abstract
	     */
	    var DomAdapter = (function () {
	        function DomAdapter() {
	            this.resourceLoaderType = null;
	        }
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} name
	         * @return {?}
	         */
	        DomAdapter.prototype.hasProperty = function (element /** TODO #9100 */, name) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} name
	         * @param {?} value
	         * @return {?}
	         */
	        DomAdapter.prototype.setProperty = function (el, name, value) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} name
	         * @return {?}
	         */
	        DomAdapter.prototype.getProperty = function (el, name) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} methodName
	         * @param {?} args
	         * @return {?}
	         */
	        DomAdapter.prototype.invoke = function (el, methodName, args) { };
	        /**
	         * @abstract
	         * @param {?} error
	         * @return {?}
	         */
	        DomAdapter.prototype.logError = function (error) { };
	        /**
	         * @abstract
	         * @param {?} error
	         * @return {?}
	         */
	        DomAdapter.prototype.log = function (error) { };
	        /**
	         * @abstract
	         * @param {?} error
	         * @return {?}
	         */
	        DomAdapter.prototype.logGroup = function (error) { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DomAdapter.prototype.logGroupEnd = function () { };
	        Object.defineProperty(DomAdapter.prototype, "attrToPropMap", {
	            /**
	             * Maps attribute names to their corresponding property names for cases
	             * where attribute name doesn't match property name.
	             * @return {?}
	             */
	            get: function () { return this._attrToPropMap; },
	            /**
	             * @param {?} value
	             * @return {?}
	             */
	            set: function (value) { this._attrToPropMap = value; },
	            enumerable: true,
	            configurable: true
	        });
	        ;
	        ;
	        /**
	         * @abstract
	         * @param {?} templateHtml
	         * @return {?}
	         */
	        DomAdapter.prototype.parse = function (templateHtml) { };
	        /**
	         * @abstract
	         * @param {?} selector
	         * @return {?}
	         */
	        DomAdapter.prototype.query = function (selector) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} selector
	         * @return {?}
	         */
	        DomAdapter.prototype.querySelector = function (el /** TODO #9100 */, selector) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} selector
	         * @return {?}
	         */
	        DomAdapter.prototype.querySelectorAll = function (el /** TODO #9100 */, selector) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} evt
	         * @param {?} listener
	         * @return {?}
	         */
	        DomAdapter.prototype.on = function (el /** TODO #9100 */, evt /** TODO #9100 */, listener) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} evt
	         * @param {?} listener
	         * @return {?}
	         */
	        DomAdapter.prototype.onAndCancel = function (el /** TODO #9100 */, evt /** TODO #9100 */, listener) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} evt
	         * @return {?}
	         */
	        DomAdapter.prototype.dispatchEvent = function (el /** TODO #9100 */, evt) { };
	        /**
	         * @abstract
	         * @param {?} eventType
	         * @return {?}
	         */
	        DomAdapter.prototype.createMouseEvent = function (eventType) { };
	        /**
	         * @abstract
	         * @param {?} eventType
	         * @return {?}
	         */
	        DomAdapter.prototype.createEvent = function (eventType) { };
	        /**
	         * @abstract
	         * @param {?} evt
	         * @return {?}
	         */
	        DomAdapter.prototype.preventDefault = function (evt) { };
	        /**
	         * @abstract
	         * @param {?} evt
	         * @return {?}
	         */
	        DomAdapter.prototype.isPrevented = function (evt) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.getInnerHTML = function (el) { };
	        /**
	         * Returns content if el is a <template> element, null otherwise.
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.getTemplateContent = function (el) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.getOuterHTML = function (el) { };
	        /**
	         * @abstract
	         * @param {?} node
	         * @return {?}
	         */
	        DomAdapter.prototype.nodeName = function (node) { };
	        /**
	         * @abstract
	         * @param {?} node
	         * @return {?}
	         */
	        DomAdapter.prototype.nodeValue = function (node) { };
	        /**
	         * @abstract
	         * @param {?} node
	         * @return {?}
	         */
	        DomAdapter.prototype.type = function (node) { };
	        /**
	         * @abstract
	         * @param {?} node
	         * @return {?}
	         */
	        DomAdapter.prototype.content = function (node) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.firstChild = function (el) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.nextSibling = function (el) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.parentElement = function (el) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.childNodes = function (el) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.childNodesAsList = function (el) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.clearNodes = function (el) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} node
	         * @return {?}
	         */
	        DomAdapter.prototype.appendChild = function (el /** TODO #9100 */, node) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} node
	         * @return {?}
	         */
	        DomAdapter.prototype.removeChild = function (el /** TODO #9100 */, node) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} newNode
	         * @param {?} oldNode
	         * @return {?}
	         */
	        DomAdapter.prototype.replaceChild = function (el /** TODO #9100 */, newNode /** TODO #9100 */, oldNode) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.remove = function (el) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} node
	         * @return {?}
	         */
	        DomAdapter.prototype.insertBefore = function (el /** TODO #9100 */, node) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} nodes
	         * @return {?}
	         */
	        DomAdapter.prototype.insertAllBefore = function (el /** TODO #9100 */, nodes) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} node
	         * @return {?}
	         */
	        DomAdapter.prototype.insertAfter = function (el /** TODO #9100 */, node) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} value
	         * @return {?}
	         */
	        DomAdapter.prototype.setInnerHTML = function (el /** TODO #9100 */, value) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.getText = function (el) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} value
	         * @return {?}
	         */
	        DomAdapter.prototype.setText = function (el /** TODO #9100 */, value) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.getValue = function (el) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} value
	         * @return {?}
	         */
	        DomAdapter.prototype.setValue = function (el /** TODO #9100 */, value) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.getChecked = function (el) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @param {?} value
	         * @return {?}
	         */
	        DomAdapter.prototype.setChecked = function (el /** TODO #9100 */, value) { };
	        /**
	         * @abstract
	         * @param {?} text
	         * @return {?}
	         */
	        DomAdapter.prototype.createComment = function (text) { };
	        /**
	         * @abstract
	         * @param {?} html
	         * @return {?}
	         */
	        DomAdapter.prototype.createTemplate = function (html) { };
	        /**
	         * @abstract
	         * @param {?} tagName
	         * @param {?=} doc
	         * @return {?}
	         */
	        DomAdapter.prototype.createElement = function (tagName /** TODO #9100 */, doc) { };
	        /**
	         * @abstract
	         * @param {?} ns
	         * @param {?} tagName
	         * @param {?=} doc
	         * @return {?}
	         */
	        DomAdapter.prototype.createElementNS = function (ns, tagName, doc) { };
	        /**
	         * @abstract
	         * @param {?} text
	         * @param {?=} doc
	         * @return {?}
	         */
	        DomAdapter.prototype.createTextNode = function (text, doc) { };
	        /**
	         * @abstract
	         * @param {?} attrName
	         * @param {?} attrValue
	         * @param {?=} doc
	         * @return {?}
	         */
	        DomAdapter.prototype.createScriptTag = function (attrName, attrValue, doc) { };
	        /**
	         * @abstract
	         * @param {?} css
	         * @param {?=} doc
	         * @return {?}
	         */
	        DomAdapter.prototype.createStyleElement = function (css, doc) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.createShadowRoot = function (el) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.getShadowRoot = function (el) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.getHost = function (el) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.getDistributedNodes = function (el) { };
	        /**
	         * @abstract
	         * @param {?} node
	         * @return {?}
	         */
	        DomAdapter.prototype.clone /*<T extends Node>*/ = function (node) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} name
	         * @return {?}
	         */
	        DomAdapter.prototype.getElementsByClassName = function (element /** TODO #9100 */, name) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} name
	         * @return {?}
	         */
	        DomAdapter.prototype.getElementsByTagName = function (element /** TODO #9100 */, name) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @return {?}
	         */
	        DomAdapter.prototype.classList = function (element) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} className
	         * @return {?}
	         */
	        DomAdapter.prototype.addClass = function (element /** TODO #9100 */, className) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} className
	         * @return {?}
	         */
	        DomAdapter.prototype.removeClass = function (element /** TODO #9100 */, className) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} className
	         * @return {?}
	         */
	        DomAdapter.prototype.hasClass = function (element /** TODO #9100 */, className) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} styleName
	         * @param {?} styleValue
	         * @return {?}
	         */
	        DomAdapter.prototype.setStyle = function (element /** TODO #9100 */, styleName, styleValue) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} styleName
	         * @return {?}
	         */
	        DomAdapter.prototype.removeStyle = function (element /** TODO #9100 */, styleName) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} styleName
	         * @return {?}
	         */
	        DomAdapter.prototype.getStyle = function (element /** TODO #9100 */, styleName) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} styleName
	         * @param {?=} styleValue
	         * @return {?}
	         */
	        DomAdapter.prototype.hasStyle = function (element /** TODO #9100 */, styleName, styleValue) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @return {?}
	         */
	        DomAdapter.prototype.tagName = function (element) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @return {?}
	         */
	        DomAdapter.prototype.attributeMap = function (element) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} attribute
	         * @return {?}
	         */
	        DomAdapter.prototype.hasAttribute = function (element /** TODO #9100 */, attribute) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} ns
	         * @param {?} attribute
	         * @return {?}
	         */
	        DomAdapter.prototype.hasAttributeNS = function (element /** TODO #9100 */, ns, attribute) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} attribute
	         * @return {?}
	         */
	        DomAdapter.prototype.getAttribute = function (element /** TODO #9100 */, attribute) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} ns
	         * @param {?} attribute
	         * @return {?}
	         */
	        DomAdapter.prototype.getAttributeNS = function (element /** TODO #9100 */, ns, attribute) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} name
	         * @param {?} value
	         * @return {?}
	         */
	        DomAdapter.prototype.setAttribute = function (element /** TODO #9100 */, name, value) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} ns
	         * @param {?} name
	         * @param {?} value
	         * @return {?}
	         */
	        DomAdapter.prototype.setAttributeNS = function (element /** TODO #9100 */, ns, name, value) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} attribute
	         * @return {?}
	         */
	        DomAdapter.prototype.removeAttribute = function (element /** TODO #9100 */, attribute) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} ns
	         * @param {?} attribute
	         * @return {?}
	         */
	        DomAdapter.prototype.removeAttributeNS = function (element /** TODO #9100 */, ns, attribute) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.templateAwareRoot = function (el) { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DomAdapter.prototype.createHtmlDocument = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DomAdapter.prototype.defaultDoc = function () { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.getBoundingClientRect = function (el) { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DomAdapter.prototype.getTitle = function () { };
	        /**
	         * @abstract
	         * @param {?} newTitle
	         * @return {?}
	         */
	        DomAdapter.prototype.setTitle = function (newTitle) { };
	        /**
	         * @abstract
	         * @param {?} n
	         * @param {?} selector
	         * @return {?}
	         */
	        DomAdapter.prototype.elementMatches = function (n /** TODO #9100 */, selector) { };
	        /**
	         * @abstract
	         * @param {?} el
	         * @return {?}
	         */
	        DomAdapter.prototype.isTemplateElement = function (el) { };
	        /**
	         * @abstract
	         * @param {?} node
	         * @return {?}
	         */
	        DomAdapter.prototype.isTextNode = function (node) { };
	        /**
	         * @abstract
	         * @param {?} node
	         * @return {?}
	         */
	        DomAdapter.prototype.isCommentNode = function (node) { };
	        /**
	         * @abstract
	         * @param {?} node
	         * @return {?}
	         */
	        DomAdapter.prototype.isElementNode = function (node) { };
	        /**
	         * @abstract
	         * @param {?} node
	         * @return {?}
	         */
	        DomAdapter.prototype.hasShadowRoot = function (node) { };
	        /**
	         * @abstract
	         * @param {?} node
	         * @return {?}
	         */
	        DomAdapter.prototype.isShadowRoot = function (node) { };
	        /**
	         * @abstract
	         * @param {?} node
	         * @return {?}
	         */
	        DomAdapter.prototype.importIntoDoc /*<T extends Node>*/ = function (node) { };
	        /**
	         * @abstract
	         * @param {?} node
	         * @return {?}
	         */
	        DomAdapter.prototype.adoptNode /*<T extends Node>*/ = function (node) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @return {?}
	         */
	        DomAdapter.prototype.getHref = function (element) { };
	        /**
	         * @abstract
	         * @param {?} event
	         * @return {?}
	         */
	        DomAdapter.prototype.getEventKey = function (event) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} baseUrl
	         * @param {?} href
	         * @return {?}
	         */
	        DomAdapter.prototype.resolveAndSetHref = function (element /** TODO #9100 */, baseUrl, href) { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DomAdapter.prototype.supportsDOMEvents = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DomAdapter.prototype.supportsNativeShadowDOM = function () { };
	        /**
	         * @abstract
	         * @param {?} target
	         * @return {?}
	         */
	        DomAdapter.prototype.getGlobalEventTarget = function (target) { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DomAdapter.prototype.getHistory = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DomAdapter.prototype.getLocation = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DomAdapter.prototype.getBaseHref = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DomAdapter.prototype.resetBaseElement = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DomAdapter.prototype.getUserAgent = function () { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} name
	         * @param {?} value
	         * @return {?}
	         */
	        DomAdapter.prototype.setData = function (element /** TODO #9100 */, name, value) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @return {?}
	         */
	        DomAdapter.prototype.getComputedStyle = function (element) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} name
	         * @return {?}
	         */
	        DomAdapter.prototype.getData = function (element /** TODO #9100 */, name) { };
	        /**
	         * @abstract
	         * @param {?} name
	         * @param {?} value
	         * @return {?}
	         */
	        DomAdapter.prototype.setGlobalVar = function (name, value) { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DomAdapter.prototype.supportsWebAnimation = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DomAdapter.prototype.performanceNow = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DomAdapter.prototype.getAnimationPrefix = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DomAdapter.prototype.getTransitionEnd = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DomAdapter.prototype.supportsAnimation = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        DomAdapter.prototype.supportsCookies = function () { };
	        /**
	         * @abstract
	         * @param {?} name
	         * @return {?}
	         */
	        DomAdapter.prototype.getCookie = function (name) { };
	        /**
	         * @abstract
	         * @param {?} name
	         * @param {?} value
	         * @return {?}
	         */
	        DomAdapter.prototype.setCookie = function (name, value) { };
	        return DomAdapter;
	    }());

	    var WebAnimationsPlayer = (function () {
	        /**
	         * @param {?} element
	         * @param {?} keyframes
	         * @param {?} options
	         * @param {?=} previousPlayers
	         */
	        function WebAnimationsPlayer(element, keyframes, options, previousPlayers) {
	            var _this = this;
	            if (previousPlayers === void 0) { previousPlayers = []; }
	            this.element = element;
	            this.keyframes = keyframes;
	            this.options = options;
	            this._onDoneFns = [];
	            this._onStartFns = [];
	            this._initialized = false;
	            this._finished = false;
	            this._started = false;
	            this._destroyed = false;
	            this.parentPlayer = null;
	            this._duration = options['duration'];
	            this.previousStyles = {};
	            previousPlayers.forEach(function (player) {
	                var styles = player._captureStyles();
	                Object.keys(styles).forEach(function (prop) { return _this.previousStyles[prop] = styles[prop]; });
	            });
	        }
	        /**
	         * @return {?}
	         */
	        WebAnimationsPlayer.prototype._onFinish = function () {
	            if (!this._finished) {
	                this._finished = true;
	                this._onDoneFns.forEach(function (fn) { return fn(); });
	                this._onDoneFns = [];
	            }
	        };
	        /**
	         * @return {?}
	         */
	        WebAnimationsPlayer.prototype.init = function () {
	            var _this = this;
	            if (this._initialized)
	                return;
	            this._initialized = true;
	            var /** @type {?} */ keyframes = this.keyframes.map(function (styles) {
	                var /** @type {?} */ formattedKeyframe = {};
	                Object.keys(styles).forEach(function (prop, index) {
	                    var /** @type {?} */ value = styles[prop];
	                    if (value == core.AUTO_STYLE) {
	                        value = _computeStyle(_this.element, prop);
	                    }
	                    if (value != undefined) {
	                        formattedKeyframe[prop] = value;
	                    }
	                });
	                return formattedKeyframe;
	            });
	            var /** @type {?} */ previousStyleProps = Object.keys(this.previousStyles);
	            if (previousStyleProps.length) {
	                var /** @type {?} */ startingKeyframe_1 = keyframes[0];
	                var /** @type {?} */ missingStyleProps_1 = [];
	                previousStyleProps.forEach(function (prop) {
	                    if (!isPresent(startingKeyframe_1[prop])) {
	                        missingStyleProps_1.push(prop);
	                    }
	                    startingKeyframe_1[prop] = _this.previousStyles[prop];
	                });
	                if (missingStyleProps_1.length) {
	                    var _loop_1 = function(i) {
	                        var /** @type {?} */ kf = keyframes[i];
	                        missingStyleProps_1.forEach(function (prop) { kf[prop] = _computeStyle(_this.element, prop); });
	                    };
	                    for (var /** @type {?} */ i = 1; i < keyframes.length; i++) {
	                        _loop_1(i);
	                    }
	                }
	            }
	            this._player = this._triggerWebAnimation(this.element, keyframes, this.options);
	            this._finalKeyframe = _copyKeyframeStyles(keyframes[keyframes.length - 1]);
	            // this is required so that the player doesn't start to animate right away
	            this._resetDomPlayerState();
	            this._player.addEventListener('finish', function () { return _this._onFinish(); });
	        };
	        /**
	         * \@internal
	         * @param {?} element
	         * @param {?} keyframes
	         * @param {?} options
	         * @return {?}
	         */
	        WebAnimationsPlayer.prototype._triggerWebAnimation = function (element, keyframes, options) {
	            // jscompiler doesn't seem to know animate is a native property because it's not fully
	            // supported yet across common browsers (we polyfill it for Edge/Safari) [CL #143630929]
	            return (element['animate'](keyframes, options));
	        };
	        Object.defineProperty(WebAnimationsPlayer.prototype, "domPlayer", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._player; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        WebAnimationsPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        WebAnimationsPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };
	        /**
	         * @return {?}
	         */
	        WebAnimationsPlayer.prototype.play = function () {
	            this.init();
	            if (!this.hasStarted()) {
	                this._onStartFns.forEach(function (fn) { return fn(); });
	                this._onStartFns = [];
	                this._started = true;
	            }
	            this._player.play();
	        };
	        /**
	         * @return {?}
	         */
	        WebAnimationsPlayer.prototype.pause = function () {
	            this.init();
	            this._player.pause();
	        };
	        /**
	         * @return {?}
	         */
	        WebAnimationsPlayer.prototype.finish = function () {
	            this.init();
	            this._onFinish();
	            this._player.finish();
	        };
	        /**
	         * @return {?}
	         */
	        WebAnimationsPlayer.prototype.reset = function () {
	            this._resetDomPlayerState();
	            this._destroyed = false;
	            this._finished = false;
	            this._started = false;
	        };
	        /**
	         * @return {?}
	         */
	        WebAnimationsPlayer.prototype._resetDomPlayerState = function () {
	            if (this._player) {
	                this._player.cancel();
	            }
	        };
	        /**
	         * @return {?}
	         */
	        WebAnimationsPlayer.prototype.restart = function () {
	            this.reset();
	            this.play();
	        };
	        /**
	         * @return {?}
	         */
	        WebAnimationsPlayer.prototype.hasStarted = function () { return this._started; };
	        /**
	         * @return {?}
	         */
	        WebAnimationsPlayer.prototype.destroy = function () {
	            if (!this._destroyed) {
	                this._resetDomPlayerState();
	                this._onFinish();
	                this._destroyed = true;
	            }
	        };
	        Object.defineProperty(WebAnimationsPlayer.prototype, "totalTime", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._duration; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} p
	         * @return {?}
	         */
	        WebAnimationsPlayer.prototype.setPosition = function (p) { this._player.currentTime = p * this.totalTime; };
	        /**
	         * @return {?}
	         */
	        WebAnimationsPlayer.prototype.getPosition = function () { return this._player.currentTime / this.totalTime; };
	        /**
	         * @return {?}
	         */
	        WebAnimationsPlayer.prototype._captureStyles = function () {
	            var _this = this;
	            var /** @type {?} */ styles = {};
	            if (this.hasStarted()) {
	                Object.keys(this._finalKeyframe).forEach(function (prop) {
	                    if (prop != 'offset') {
	                        styles[prop] =
	                            _this._finished ? _this._finalKeyframe[prop] : _computeStyle(_this.element, prop);
	                    }
	                });
	            }
	            return styles;
	        };
	        return WebAnimationsPlayer;
	    }());
	    /**
	     * @param {?} element
	     * @param {?} prop
	     * @return {?}
	     */
	    function _computeStyle(element, prop) {
	        return getDOM().getComputedStyle(element)[prop];
	    }
	    /**
	     * @param {?} styles
	     * @return {?}
	     */
	    function _copyKeyframeStyles(styles) {
	        var /** @type {?} */ newStyles = {};
	        Object.keys(styles).forEach(function (prop) {
	            if (prop != 'offset') {
	                newStyles[prop] = styles[prop];
	            }
	        });
	        return newStyles;
	    }

	    var WebAnimationsDriver = (function () {
	        function WebAnimationsDriver() {
	        }
	        /**
	         * @param {?} element
	         * @param {?} startingStyles
	         * @param {?} keyframes
	         * @param {?} duration
	         * @param {?} delay
	         * @param {?} easing
	         * @param {?=} previousPlayers
	         * @return {?}
	         */
	        WebAnimationsDriver.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing, previousPlayers) {
	            if (previousPlayers === void 0) { previousPlayers = []; }
	            var /** @type {?} */ formattedSteps = [];
	            var /** @type {?} */ startingStyleLookup = {};
	            if (isPresent(startingStyles)) {
	                startingStyleLookup = _populateStyles(startingStyles, {});
	            }
	            keyframes.forEach(function (keyframe) {
	                var /** @type {?} */ data = _populateStyles(keyframe.styles, startingStyleLookup);
	                data['offset'] = Math.max(0, Math.min(1, keyframe.offset));
	                formattedSteps.push(data);
	            });
	            // Styling passed into element.animate() must always be balanced.
	            // The special cases below can occur if only style() calls exist
	            // within an animation or when a style() calls are used prior
	            // to a group() animation being issued or if the renderer is
	            // invoked by the user directly.
	            if (formattedSteps.length == 0) {
	                formattedSteps = [startingStyleLookup, startingStyleLookup];
	            }
	            else if (formattedSteps.length == 1) {
	                var /** @type {?} */ start = startingStyleLookup;
	                var /** @type {?} */ end = formattedSteps[0];
	                end['offset'] = null;
	                formattedSteps = [start, end];
	            }
	            var /** @type {?} */ playerOptions = {
	                'duration': duration,
	                'delay': delay,
	                'fill': 'both' // we use `both` because it allows for styling at 0% to work with `delay`
	            };
	            // we check for this to avoid having a null|undefined value be present
	            // for the easing (which results in an error for certain browsers #9752)
	            if (easing) {
	                playerOptions['easing'] = easing;
	            }
	            // there may be a chance a NoOp player is returned depending
	            // on when the previous animation was cancelled
	            previousPlayers = previousPlayers.filter(filterWebAnimationPlayerFn);
	            return new WebAnimationsPlayer(element, formattedSteps, playerOptions, /** @type {?} */ (previousPlayers));
	        };
	        return WebAnimationsDriver;
	    }());
	    /**
	     * @param {?} styles
	     * @param {?} defaultStyles
	     * @return {?}
	     */
	    function _populateStyles(styles, defaultStyles) {
	        var /** @type {?} */ data = {};
	        styles.styles.forEach(function (entry) { Object.keys(entry).forEach(function (prop) { data[prop] = entry[prop]; }); });
	        Object.keys(defaultStyles).forEach(function (prop) {
	            if (!isPresent(data[prop])) {
	                data[prop] = defaultStyles[prop];
	            }
	        });
	        return data;
	    }
	    /**
	     * @param {?} player
	     * @return {?}
	     */
	    function filterWebAnimationPlayerFn(player) {
	        return player instanceof WebAnimationsPlayer;
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$1 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * Provides DOM operations in any browser environment.
	     *
	     * \@security Tread carefully! Interacting with the DOM directly is dangerous and
	     * can introduce XSS risks.
	     * @abstract
	     */
	    var GenericBrowserDomAdapter = (function (_super) {
	        __extends$1(GenericBrowserDomAdapter, _super);
	        function GenericBrowserDomAdapter() {
	            var _this = this;
	            _super.call(this);
	            this._animationPrefix = null;
	            this._transitionEnd = null;
	            try {
	                var element_1 = this.createElement('div', this.defaultDoc());
	                if (isPresent(this.getStyle(element_1, 'animationName'))) {
	                    this._animationPrefix = '';
	                }
	                else {
	                    var domPrefixes = ['Webkit', 'Moz', 'O', 'ms'];
	                    for (var i = 0; i < domPrefixes.length; i++) {
	                        if (isPresent(this.getStyle(element_1, domPrefixes[i] + 'AnimationName'))) {
	                            this._animationPrefix = '-' + domPrefixes[i].toLowerCase() + '-';
	                            break;
	                        }
	                    }
	                }
	                var transEndEventNames_1 = {
	                    WebkitTransition: 'webkitTransitionEnd',
	                    MozTransition: 'transitionend',
	                    OTransition: 'oTransitionEnd otransitionend',
	                    transition: 'transitionend'
	                };
	                Object.keys(transEndEventNames_1).forEach(function (key) {
	                    if (isPresent(_this.getStyle(element_1, key))) {
	                        _this._transitionEnd = transEndEventNames_1[key];
	                    }
	                });
	            }
	            catch (e) {
	                this._animationPrefix = null;
	                this._transitionEnd = null;
	            }
	        }
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        GenericBrowserDomAdapter.prototype.getDistributedNodes = function (el) { return ((el)).getDistributedNodes(); };
	        /**
	         * @param {?} el
	         * @param {?} baseUrl
	         * @param {?} href
	         * @return {?}
	         */
	        GenericBrowserDomAdapter.prototype.resolveAndSetHref = function (el, baseUrl, href) {
	            el.href = href == null ? baseUrl : baseUrl + '/../' + href;
	        };
	        /**
	         * @return {?}
	         */
	        GenericBrowserDomAdapter.prototype.supportsDOMEvents = function () { return true; };
	        /**
	         * @return {?}
	         */
	        GenericBrowserDomAdapter.prototype.supportsNativeShadowDOM = function () {
	            return typeof ((this.defaultDoc().body)).createShadowRoot === 'function';
	        };
	        /**
	         * @return {?}
	         */
	        GenericBrowserDomAdapter.prototype.getAnimationPrefix = function () { return this._animationPrefix ? this._animationPrefix : ''; };
	        /**
	         * @return {?}
	         */
	        GenericBrowserDomAdapter.prototype.getTransitionEnd = function () { return this._transitionEnd ? this._transitionEnd : ''; };
	        /**
	         * @return {?}
	         */
	        GenericBrowserDomAdapter.prototype.supportsAnimation = function () {
	            return isPresent(this._animationPrefix) && isPresent(this._transitionEnd);
	        };
	        return GenericBrowserDomAdapter;
	    }(DomAdapter));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ _attrToPropMap = {
	        'class': 'className',
	        'innerHtml': 'innerHTML',
	        'readonly': 'readOnly',
	        'tabindex': 'tabIndex',
	    };
	    var /** @type {?} */ DOM_KEY_LOCATION_NUMPAD = 3;
	    // Map to convert some key or keyIdentifier values to what will be returned by getEventKey
	    var /** @type {?} */ _keyMap = {
	        // The following values are here for cross-browser compatibility and to match the W3C standard
	        // cf http://www.w3.org/TR/DOM-Level-3-Events-key/
	        '\b': 'Backspace',
	        '\t': 'Tab',
	        '\x7F': 'Delete',
	        '\x1B': 'Escape',
	        'Del': 'Delete',
	        'Esc': 'Escape',
	        'Left': 'ArrowLeft',
	        'Right': 'ArrowRight',
	        'Up': 'ArrowUp',
	        'Down': 'ArrowDown',
	        'Menu': 'ContextMenu',
	        'Scroll': 'ScrollLock',
	        'Win': 'OS'
	    };
	    // There is a bug in Chrome for numeric keypad keys:
	    // https://code.google.com/p/chromium/issues/detail?id=155654
	    // 1, 2, 3 ... are reported as A, B, C ...
	    var /** @type {?} */ _chromeNumKeyPadMap = {
	        'A': '1',
	        'B': '2',
	        'C': '3',
	        'D': '4',
	        'E': '5',
	        'F': '6',
	        'G': '7',
	        'H': '8',
	        'I': '9',
	        'J': '*',
	        'K': '+',
	        'M': '-',
	        'N': '.',
	        'O': '/',
	        '\x60': '0',
	        '\x90': 'NumLock'
	    };
	    var BrowserDomAdapter = (function (_super) {
	        __extends(BrowserDomAdapter, _super);
	        function BrowserDomAdapter() {
	            _super.apply(this, arguments);
	        }
	        /**
	         * @param {?} templateHtml
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.parse = function (templateHtml) { throw new Error('parse not implemented'); };
	        /**
	         * @return {?}
	         */
	        BrowserDomAdapter.makeCurrent = function () { setRootDomAdapter(new BrowserDomAdapter()); };
	        /**
	         * @param {?} element
	         * @param {?} name
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.hasProperty = function (element, name) { return name in element; };
	        /**
	         * @param {?} el
	         * @param {?} name
	         * @param {?} value
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.setProperty = function (el, name, value) { ((el))[name] = value; };
	        /**
	         * @param {?} el
	         * @param {?} name
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getProperty = function (el, name) { return ((el))[name]; };
	        /**
	         * @param {?} el
	         * @param {?} methodName
	         * @param {?} args
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.invoke = function (el, methodName, args) { (_a = ((el)))[methodName].apply(_a, args); var _a; };
	        /**
	         * @param {?} error
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.logError = function (error) {
	            if (window.console) {
	                if (console.error) {
	                    console.error(error);
	                }
	                else {
	                    console.log(error);
	                }
	            }
	        };
	        /**
	         * @param {?} error
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.log = function (error) {
	            if (window.console) {
	                window.console.log && window.console.log(error);
	            }
	        };
	        /**
	         * @param {?} error
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.logGroup = function (error) {
	            if (window.console) {
	                window.console.group && window.console.group(error);
	            }
	        };
	        /**
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.logGroupEnd = function () {
	            if (window.console) {
	                window.console.groupEnd && window.console.groupEnd();
	            }
	        };
	        Object.defineProperty(BrowserDomAdapter.prototype, "attrToPropMap", {
	            /**
	             * @return {?}
	             */
	            get: function () { return _attrToPropMap; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} selector
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.query = function (selector) { return document.querySelector(selector); };
	        /**
	         * @param {?} el
	         * @param {?} selector
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.querySelector = function (el, selector) {
	            return (el.querySelector(selector));
	        };
	        /**
	         * @param {?} el
	         * @param {?} selector
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.querySelectorAll = function (el, selector) { return el.querySelectorAll(selector); };
	        /**
	         * @param {?} el
	         * @param {?} evt
	         * @param {?} listener
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.on = function (el, evt, listener) { el.addEventListener(evt, listener, false); };
	        /**
	         * @param {?} el
	         * @param {?} evt
	         * @param {?} listener
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.onAndCancel = function (el, evt, listener) {
	            el.addEventListener(evt, listener, false);
	            // Needed to follow Dart's subscription semantic, until fix of
	            // https://code.google.com/p/dart/issues/detail?id=17406
	            return function () { el.removeEventListener(evt, listener, false); };
	        };
	        /**
	         * @param {?} el
	         * @param {?} evt
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.dispatchEvent = function (el, evt) { el.dispatchEvent(evt); };
	        /**
	         * @param {?} eventType
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.createMouseEvent = function (eventType) {
	            var /** @type {?} */ evt = document.createEvent('MouseEvent');
	            evt.initEvent(eventType, true, true);
	            return evt;
	        };
	        /**
	         * @param {?} eventType
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.createEvent = function (eventType) {
	            var /** @type {?} */ evt = document.createEvent('Event');
	            evt.initEvent(eventType, true, true);
	            return evt;
	        };
	        /**
	         * @param {?} evt
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.preventDefault = function (evt) {
	            evt.preventDefault();
	            evt.returnValue = false;
	        };
	        /**
	         * @param {?} evt
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.isPrevented = function (evt) {
	            return evt.defaultPrevented || isPresent(evt.returnValue) && !evt.returnValue;
	        };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getInnerHTML = function (el) { return el.innerHTML; };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getTemplateContent = function (el) {
	            return 'content' in el && el instanceof HTMLTemplateElement ? el.content : null;
	        };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getOuterHTML = function (el) { return el.outerHTML; };
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.nodeName = function (node) { return node.nodeName; };
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.nodeValue = function (node) { return node.nodeValue; };
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.type = function (node) { return node.type; };
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.content = function (node) {
	            if (this.hasProperty(node, 'content')) {
	                return ((node)).content;
	            }
	            else {
	                return node;
	            }
	        };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.firstChild = function (el) { return el.firstChild; };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.nextSibling = function (el) { return el.nextSibling; };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.parentElement = function (el) { return el.parentNode; };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.childNodes = function (el) { return el.childNodes; };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.childNodesAsList = function (el) {
	            var /** @type {?} */ childNodes = el.childNodes;
	            var /** @type {?} */ res = new Array(childNodes.length);
	            for (var /** @type {?} */ i = 0; i < childNodes.length; i++) {
	                res[i] = childNodes[i];
	            }
	            return res;
	        };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.clearNodes = function (el) {
	            while (el.firstChild) {
	                el.removeChild(el.firstChild);
	            }
	        };
	        /**
	         * @param {?} el
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.appendChild = function (el, node) { el.appendChild(node); };
	        /**
	         * @param {?} el
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.removeChild = function (el, node) { el.removeChild(node); };
	        /**
	         * @param {?} el
	         * @param {?} newChild
	         * @param {?} oldChild
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.replaceChild = function (el, newChild, oldChild) { el.replaceChild(newChild, oldChild); };
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.remove = function (node) {
	            if (node.parentNode) {
	                node.parentNode.removeChild(node);
	            }
	            return node;
	        };
	        /**
	         * @param {?} el
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.insertBefore = function (el, node) { el.parentNode.insertBefore(node, el); };
	        /**
	         * @param {?} el
	         * @param {?} nodes
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.insertAllBefore = function (el, nodes) {
	            nodes.forEach(function (n) { return el.parentNode.insertBefore(n, el); });
	        };
	        /**
	         * @param {?} el
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.insertAfter = function (el, node) { el.parentNode.insertBefore(node, el.nextSibling); };
	        /**
	         * @param {?} el
	         * @param {?} value
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.setInnerHTML = function (el, value) { el.innerHTML = value; };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getText = function (el) { return el.textContent; };
	        /**
	         * @param {?} el
	         * @param {?} value
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.setText = function (el, value) { el.textContent = value; };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getValue = function (el) { return el.value; };
	        /**
	         * @param {?} el
	         * @param {?} value
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.setValue = function (el, value) { el.value = value; };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getChecked = function (el) { return el.checked; };
	        /**
	         * @param {?} el
	         * @param {?} value
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.setChecked = function (el, value) { el.checked = value; };
	        /**
	         * @param {?} text
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.createComment = function (text) { return document.createComment(text); };
	        /**
	         * @param {?} html
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.createTemplate = function (html) {
	            var /** @type {?} */ t = document.createElement('template');
	            t.innerHTML = html;
	            return t;
	        };
	        /**
	         * @param {?} tagName
	         * @param {?=} doc
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.createElement = function (tagName, doc) {
	            if (doc === void 0) { doc = document; }
	            return doc.createElement(tagName);
	        };
	        /**
	         * @param {?} ns
	         * @param {?} tagName
	         * @param {?=} doc
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.createElementNS = function (ns, tagName, doc) {
	            if (doc === void 0) { doc = document; }
	            return doc.createElementNS(ns, tagName);
	        };
	        /**
	         * @param {?} text
	         * @param {?=} doc
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.createTextNode = function (text, doc) {
	            if (doc === void 0) { doc = document; }
	            return doc.createTextNode(text);
	        };
	        /**
	         * @param {?} attrName
	         * @param {?} attrValue
	         * @param {?=} doc
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.createScriptTag = function (attrName, attrValue, doc) {
	            if (doc === void 0) { doc = document; }
	            var /** @type {?} */ el = (doc.createElement('SCRIPT'));
	            el.setAttribute(attrName, attrValue);
	            return el;
	        };
	        /**
	         * @param {?} css
	         * @param {?=} doc
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.createStyleElement = function (css, doc) {
	            if (doc === void 0) { doc = document; }
	            var /** @type {?} */ style = (doc.createElement('style'));
	            this.appendChild(style, this.createTextNode(css));
	            return style;
	        };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.createShadowRoot = function (el) { return ((el)).createShadowRoot(); };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getShadowRoot = function (el) { return ((el)).shadowRoot; };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getHost = function (el) { return ((el)).host; };
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.clone = function (node) { return node.cloneNode(true); };
	        /**
	         * @param {?} element
	         * @param {?} name
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getElementsByClassName = function (element, name) {
	            return element.getElementsByClassName(name);
	        };
	        /**
	         * @param {?} element
	         * @param {?} name
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getElementsByTagName = function (element, name) {
	            return element.getElementsByTagName(name);
	        };
	        /**
	         * @param {?} element
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.classList = function (element) { return Array.prototype.slice.call(element.classList, 0); };
	        /**
	         * @param {?} element
	         * @param {?} className
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.addClass = function (element, className) { element.classList.add(className); };
	        /**
	         * @param {?} element
	         * @param {?} className
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.removeClass = function (element, className) { element.classList.remove(className); };
	        /**
	         * @param {?} element
	         * @param {?} className
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.hasClass = function (element, className) {
	            return element.classList.contains(className);
	        };
	        /**
	         * @param {?} element
	         * @param {?} styleName
	         * @param {?} styleValue
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.setStyle = function (element, styleName, styleValue) {
	            element.style[styleName] = styleValue;
	        };
	        /**
	         * @param {?} element
	         * @param {?} stylename
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.removeStyle = function (element, stylename) {
	            // IE requires '' instead of null
	            // see https://github.com/angular/angular/issues/7916
	            element.style[stylename] = '';
	        };
	        /**
	         * @param {?} element
	         * @param {?} stylename
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getStyle = function (element, stylename) { return element.style[stylename]; };
	        /**
	         * @param {?} element
	         * @param {?} styleName
	         * @param {?=} styleValue
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.hasStyle = function (element, styleName, styleValue) {
	            if (styleValue === void 0) { styleValue = null; }
	            var /** @type {?} */ value = this.getStyle(element, styleName) || '';
	            return styleValue ? value == styleValue : value.length > 0;
	        };
	        /**
	         * @param {?} element
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.tagName = function (element) { return element.tagName; };
	        /**
	         * @param {?} element
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.attributeMap = function (element) {
	            var /** @type {?} */ res = new Map();
	            var /** @type {?} */ elAttrs = element.attributes;
	            for (var /** @type {?} */ i = 0; i < elAttrs.length; i++) {
	                var /** @type {?} */ attrib = elAttrs[i];
	                res.set(attrib.name, attrib.value);
	            }
	            return res;
	        };
	        /**
	         * @param {?} element
	         * @param {?} attribute
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.hasAttribute = function (element, attribute) {
	            return element.hasAttribute(attribute);
	        };
	        /**
	         * @param {?} element
	         * @param {?} ns
	         * @param {?} attribute
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.hasAttributeNS = function (element, ns, attribute) {
	            return element.hasAttributeNS(ns, attribute);
	        };
	        /**
	         * @param {?} element
	         * @param {?} attribute
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getAttribute = function (element, attribute) {
	            return element.getAttribute(attribute);
	        };
	        /**
	         * @param {?} element
	         * @param {?} ns
	         * @param {?} name
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getAttributeNS = function (element, ns, name) {
	            return element.getAttributeNS(ns, name);
	        };
	        /**
	         * @param {?} element
	         * @param {?} name
	         * @param {?} value
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.setAttribute = function (element, name, value) { element.setAttribute(name, value); };
	        /**
	         * @param {?} element
	         * @param {?} ns
	         * @param {?} name
	         * @param {?} value
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.setAttributeNS = function (element, ns, name, value) {
	            element.setAttributeNS(ns, name, value);
	        };
	        /**
	         * @param {?} element
	         * @param {?} attribute
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.removeAttribute = function (element, attribute) { element.removeAttribute(attribute); };
	        /**
	         * @param {?} element
	         * @param {?} ns
	         * @param {?} name
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.removeAttributeNS = function (element, ns, name) {
	            element.removeAttributeNS(ns, name);
	        };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.templateAwareRoot = function (el) { return this.isTemplateElement(el) ? this.content(el) : el; };
	        /**
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.createHtmlDocument = function () {
	            return document.implementation.createHTMLDocument('fakeTitle');
	        };
	        /**
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.defaultDoc = function () { return document; };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getBoundingClientRect = function (el) {
	            try {
	                return el.getBoundingClientRect();
	            }
	            catch (e) {
	                return { top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0 };
	            }
	        };
	        /**
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getTitle = function () { return document.title; };
	        /**
	         * @param {?} newTitle
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.setTitle = function (newTitle) { document.title = newTitle || ''; };
	        /**
	         * @param {?} n
	         * @param {?} selector
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.elementMatches = function (n, selector) {
	            if (n instanceof HTMLElement) {
	                return n.matches && n.matches(selector) ||
	                    n.msMatchesSelector && n.msMatchesSelector(selector) ||
	                    n.webkitMatchesSelector && n.webkitMatchesSelector(selector);
	            }
	            return false;
	        };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.isTemplateElement = function (el) {
	            return el instanceof HTMLElement && el.nodeName == 'TEMPLATE';
	        };
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.isTextNode = function (node) { return node.nodeType === Node.TEXT_NODE; };
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.isCommentNode = function (node) { return node.nodeType === Node.COMMENT_NODE; };
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.isElementNode = function (node) { return node.nodeType === Node.ELEMENT_NODE; };
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.hasShadowRoot = function (node) {
	            return isPresent(node.shadowRoot) && node instanceof HTMLElement;
	        };
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.isShadowRoot = function (node) { return node instanceof DocumentFragment; };
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.importIntoDoc = function (node) { return document.importNode(this.templateAwareRoot(node), true); };
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.adoptNode = function (node) { return document.adoptNode(node); };
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getHref = function (el) { return ((el)).href; };
	        /**
	         * @param {?} event
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getEventKey = function (event) {
	            var /** @type {?} */ key = event.key;
	            if (isBlank(key)) {
	                key = event.keyIdentifier;
	                // keyIdentifier is defined in the old draft of DOM Level 3 Events implemented by Chrome and
	                // Safari cf
	                // http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/events.html#Events-KeyboardEvents-Interfaces
	                if (isBlank(key)) {
	                    return 'Unidentified';
	                }
	                if (key.startsWith('U+')) {
	                    key = String.fromCharCode(parseInt(key.substring(2), 16));
	                    if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {
	                        // There is a bug in Chrome for numeric keypad keys:
	                        // https://code.google.com/p/chromium/issues/detail?id=155654
	                        // 1, 2, 3 ... are reported as A, B, C ...
	                        key = ((_chromeNumKeyPadMap))[key];
	                    }
	                }
	            }
	            return _keyMap[key] || key;
	        };
	        /**
	         * @param {?} target
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getGlobalEventTarget = function (target) {
	            if (target === 'window') {
	                return window;
	            }
	            if (target === 'document') {
	                return document;
	            }
	            if (target === 'body') {
	                return document.body;
	            }
	        };
	        /**
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getHistory = function () { return window.history; };
	        /**
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getLocation = function () { return window.location; };
	        /**
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getBaseHref = function () {
	            var /** @type {?} */ href = getBaseElementHref();
	            return isBlank(href) ? null : relativePath(href);
	        };
	        /**
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.resetBaseElement = function () { baseElement = null; };
	        /**
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getUserAgent = function () { return window.navigator.userAgent; };
	        /**
	         * @param {?} element
	         * @param {?} name
	         * @param {?} value
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.setData = function (element, name, value) {
	            this.setAttribute(element, 'data-' + name, value);
	        };
	        /**
	         * @param {?} element
	         * @param {?} name
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getData = function (element, name) {
	            return this.getAttribute(element, 'data-' + name);
	        };
	        /**
	         * @param {?} element
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getComputedStyle = function (element) { return getComputedStyle(element); };
	        /**
	         * @param {?} path
	         * @param {?} value
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.setGlobalVar = function (path, value) { setValueOnPath(global$1, path, value); };
	        /**
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.supportsWebAnimation = function () {
	            return typeof ((Element)).prototype['animate'] === 'function';
	        };
	        /**
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.performanceNow = function () {
	            // performance.now() is not available in all browsers, see
	            // http://caniuse.com/#search=performance.now
	            return window.performance && window.performance.now ? window.performance.now() :
	                new Date().getTime();
	        };
	        /**
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.supportsCookies = function () { return true; };
	        /**
	         * @param {?} name
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.getCookie = function (name) { return parseCookieValue(document.cookie, name); };
	        /**
	         * @param {?} name
	         * @param {?} value
	         * @return {?}
	         */
	        BrowserDomAdapter.prototype.setCookie = function (name, value) {
	            // document.cookie is magical, assigning into it assigns/overrides one cookie value, but does
	            // not clear other cookies.
	            document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value);
	        };
	        return BrowserDomAdapter;
	    }(GenericBrowserDomAdapter));
	    var /** @type {?} */ baseElement = null;
	    /**
	     * @return {?}
	     */
	    function getBaseElementHref() {
	        if (!baseElement) {
	            baseElement = document.querySelector('base');
	            if (!baseElement) {
	                return null;
	            }
	        }
	        return baseElement.getAttribute('href');
	    }
	    // based on urlUtils.js in AngularJS 1
	    var /** @type {?} */ urlParsingNode;
	    /**
	     * @param {?} url
	     * @return {?}
	     */
	    function relativePath(url) {
	        if (!urlParsingNode) {
	            urlParsingNode = document.createElement('a');
	        }
	        urlParsingNode.setAttribute('href', url);
	        return (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname :
	            '/' + urlParsingNode.pathname;
	    }
	    /**
	     * @param {?} cookieStr
	     * @param {?} name
	     * @return {?}
	     */
	    function parseCookieValue(cookieStr, name) {
	        name = encodeURIComponent(name);
	        for (var _i = 0, _a = cookieStr.split(';'); _i < _a.length; _i++) {
	            var cookie = _a[_i];
	            var /** @type {?} */ eqIndex = cookie.indexOf('=');
	            var _b = eqIndex == -1 ? [cookie, ''] : [cookie.slice(0, eqIndex), cookie.slice(eqIndex + 1)], cookieName = _b[0], cookieValue = _b[1];
	            if (cookieName.trim() === name) {
	                return decodeURIComponent(cookieValue);
	            }
	        }
	        return null;
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     * @return {?}
	     */
	    function supportsState() {
	        return !!window.history.pushState;
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$2 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * `PlatformLocation` encapsulates all of the direct calls to platform APIs.
	     * This class should not be used directly by an application developer. Instead, use
	     * {\@link Location}.
	     */
	    var BrowserPlatformLocation = (function (_super) {
	        __extends$2(BrowserPlatformLocation, _super);
	        function BrowserPlatformLocation() {
	            _super.call(this);
	            this._init();
	        }
	        /**
	         * \@internal
	         * @return {?}
	         */
	        BrowserPlatformLocation.prototype._init = function () {
	            this._location = getDOM().getLocation();
	            this._history = getDOM().getHistory();
	        };
	        Object.defineProperty(BrowserPlatformLocation.prototype, "location", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._location; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        BrowserPlatformLocation.prototype.getBaseHrefFromDOM = function () { return getDOM().getBaseHref(); };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        BrowserPlatformLocation.prototype.onPopState = function (fn) {
	            getDOM().getGlobalEventTarget('window').addEventListener('popstate', fn, false);
	        };
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        BrowserPlatformLocation.prototype.onHashChange = function (fn) {
	            getDOM().getGlobalEventTarget('window').addEventListener('hashchange', fn, false);
	        };
	        Object.defineProperty(BrowserPlatformLocation.prototype, "pathname", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._location.pathname; },
	            /**
	             * @param {?} newPath
	             * @return {?}
	             */
	            set: function (newPath) { this._location.pathname = newPath; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(BrowserPlatformLocation.prototype, "search", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._location.search; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(BrowserPlatformLocation.prototype, "hash", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._location.hash; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} state
	         * @param {?} title
	         * @param {?} url
	         * @return {?}
	         */
	        BrowserPlatformLocation.prototype.pushState = function (state, title, url) {
	            if (supportsState()) {
	                this._history.pushState(state, title, url);
	            }
	            else {
	                this._location.hash = url;
	            }
	        };
	        /**
	         * @param {?} state
	         * @param {?} title
	         * @param {?} url
	         * @return {?}
	         */
	        BrowserPlatformLocation.prototype.replaceState = function (state, title, url) {
	            if (supportsState()) {
	                this._history.replaceState(state, title, url);
	            }
	            else {
	                this._location.hash = url;
	            }
	        };
	        /**
	         * @return {?}
	         */
	        BrowserPlatformLocation.prototype.forward = function () { this._history.forward(); };
	        /**
	         * @return {?}
	         */
	        BrowserPlatformLocation.prototype.back = function () { this._history.back(); };
	        BrowserPlatformLocation.decorators = [
	            { type: core.Injectable },
	        ];
	        /** @nocollapse */
	        BrowserPlatformLocation.ctorParameters = function () { return []; };
	        return BrowserPlatformLocation;
	    }(_angular_common.PlatformLocation));

	    var BrowserGetTestability = (function () {
	        function BrowserGetTestability() {
	        }
	        /**
	         * @return {?}
	         */
	        BrowserGetTestability.init = function () { core.setTestabilityGetter(new BrowserGetTestability()); };
	        /**
	         * @param {?} registry
	         * @return {?}
	         */
	        BrowserGetTestability.prototype.addToWindow = function (registry) {
	            global$1.getAngularTestability = function (elem, findInAncestors) {
	                if (findInAncestors === void 0) { findInAncestors = true; }
	                var /** @type {?} */ testability = registry.findTestabilityInTree(elem, findInAncestors);
	                if (testability == null) {
	                    throw new Error('Could not find testability for element.');
	                }
	                return testability;
	            };
	            global$1.getAllAngularTestabilities = function () { return registry.getAllTestabilities(); };
	            global$1.getAllAngularRootElements = function () { return registry.getAllRootElements(); };
	            var /** @type {?} */ whenAllStable = function (callback /** TODO #9100 */) {
	                var /** @type {?} */ testabilities = global$1.getAllAngularTestabilities();
	                var /** @type {?} */ count = testabilities.length;
	                var /** @type {?} */ didWork = false;
	                var /** @type {?} */ decrement = function (didWork_ /** TODO #9100 */) {
	                    didWork = didWork || didWork_;
	                    count--;
	                    if (count == 0) {
	                        callback(didWork);
	                    }
	                };
	                testabilities.forEach(function (testability /** TODO #9100 */) {
	                    testability.whenStable(decrement);
	                });
	            };
	            if (!global$1['frameworkStabilizers']) {
	                global$1['frameworkStabilizers'] = [];
	            }
	            global$1['frameworkStabilizers'].push(whenAllStable);
	        };
	        /**
	         * @param {?} registry
	         * @param {?} elem
	         * @param {?} findInAncestors
	         * @return {?}
	         */
	        BrowserGetTestability.prototype.findTestabilityInTree = function (registry, elem, findInAncestors) {
	            if (elem == null) {
	                return null;
	            }
	            var /** @type {?} */ t = registry.getTestability(elem);
	            if (isPresent(t)) {
	                return t;
	            }
	            else if (!findInAncestors) {
	                return null;
	            }
	            if (getDOM().isShadowRoot(elem)) {
	                return this.findTestabilityInTree(registry, getDOM().getHost(elem), true);
	            }
	            return this.findTestabilityInTree(registry, getDOM().parentElement(elem), true);
	        };
	        return BrowserGetTestability;
	    }());

	    /**
	     * A service that can be used to get and set the title of a current HTML document.
	     *
	     * Since an Angular 2 application can't be bootstrapped on the entire HTML document (`<html>` tag)
	     * it is not possible to bind to the `text` property of the `HTMLTitleElement` elements
	     * (representing the `<title>` tag). Instead, this service can be used to set and get the current
	     * title value.
	     *
	     * \@experimental
	     */
	    var Title = (function () {
	        function Title() {
	        }
	        /**
	         * Get the title of the current HTML document.
	         * @return {?}
	         */
	        Title.prototype.getTitle = function () { return getDOM().getTitle(); };
	        /**
	         * Set the title of the current HTML document.
	         * @param {?} newTitle
	         * @return {?}
	         */
	        Title.prototype.setTitle = function (newTitle) { getDOM().setTitle(newTitle); };
	        return Title;
	    }());

	    /**
	     * Wraps Javascript Objects
	     */
	    var StringMapWrapper = (function () {
	        function StringMapWrapper() {
	        }
	        /**
	         * @param {?} m1
	         * @param {?} m2
	         * @return {?}
	         */
	        StringMapWrapper.merge = function (m1, m2) {
	            var /** @type {?} */ m = {};
	            for (var _i = 0, _a = Object.keys(m1); _i < _a.length; _i++) {
	                var k = _a[_i];
	                m[k] = m1[k];
	            }
	            for (var _b = 0, _c = Object.keys(m2); _b < _c.length; _b++) {
	                var k = _c[_b];
	                m[k] = m2[k];
	            }
	            return m;
	        };
	        /**
	         * @param {?} m1
	         * @param {?} m2
	         * @return {?}
	         */
	        StringMapWrapper.equals = function (m1, m2) {
	            var /** @type {?} */ k1 = Object.keys(m1);
	            var /** @type {?} */ k2 = Object.keys(m2);
	            if (k1.length != k2.length) {
	                return false;
	            }
	            for (var /** @type {?} */ i = 0; i < k1.length; i++) {
	                var /** @type {?} */ key = k1[i];
	                if (m1[key] !== m2[key]) {
	                    return false;
	                }
	            }
	            return true;
	        };
	        return StringMapWrapper;
	    }());

	    /**
	     * A DI Token representing the main rendering context. In a browser this is the DOM Document.
	     *
	     * Note: Document might not be available in the Application Context when Application and Rendering
	     * Contexts are not the same (e.g. when running the application into a Web Worker).
	     *
	     * @stable
	     */
	    var /** @type {?} */ DOCUMENT = new core.OpaqueToken('DocumentToken');

	    /**
	     * @stable
	     */
	    var /** @type {?} */ EVENT_MANAGER_PLUGINS = new core.OpaqueToken('EventManagerPlugins');
	    /**
	     * \@stable
	     */
	    var EventManager = (function () {
	        /**
	         * @param {?} plugins
	         * @param {?} _zone
	         */
	        function EventManager(plugins, _zone) {
	            var _this = this;
	            this._zone = _zone;
	            this._eventNameToPlugin = new Map();
	            plugins.forEach(function (p) { return p.manager = _this; });
	            this._plugins = plugins.slice().reverse();
	        }
	        /**
	         * @param {?} element
	         * @param {?} eventName
	         * @param {?} handler
	         * @return {?}
	         */
	        EventManager.prototype.addEventListener = function (element, eventName, handler) {
	            var /** @type {?} */ plugin = this._findPluginFor(eventName);
	            return plugin.addEventListener(element, eventName, handler);
	        };
	        /**
	         * @param {?} target
	         * @param {?} eventName
	         * @param {?} handler
	         * @return {?}
	         */
	        EventManager.prototype.addGlobalEventListener = function (target, eventName, handler) {
	            var /** @type {?} */ plugin = this._findPluginFor(eventName);
	            return plugin.addGlobalEventListener(target, eventName, handler);
	        };
	        /**
	         * @return {?}
	         */
	        EventManager.prototype.getZone = function () { return this._zone; };
	        /**
	         * \@internal
	         * @param {?} eventName
	         * @return {?}
	         */
	        EventManager.prototype._findPluginFor = function (eventName) {
	            var /** @type {?} */ plugin = this._eventNameToPlugin.get(eventName);
	            if (plugin) {
	                return plugin;
	            }
	            var /** @type {?} */ plugins = this._plugins;
	            for (var /** @type {?} */ i = 0; i < plugins.length; i++) {
	                var /** @type {?} */ plugin_1 = plugins[i];
	                if (plugin_1.supports(eventName)) {
	                    this._eventNameToPlugin.set(eventName, plugin_1);
	                    return plugin_1;
	                }
	            }
	            throw new Error("No event manager plugin found for event " + eventName);
	        };
	        EventManager.decorators = [
	            { type: core.Injectable },
	        ];
	        /** @nocollapse */
	        EventManager.ctorParameters = function () { return [
	            { type: Array, decorators: [{ type: core.Inject, args: [EVENT_MANAGER_PLUGINS,] },] },
	            { type: core.NgZone, },
	        ]; };
	        return EventManager;
	    }());
	    /**
	     * @abstract
	     */
	    var EventManagerPlugin = (function () {
	        function EventManagerPlugin() {
	        }
	        /**
	         * @abstract
	         * @param {?} eventName
	         * @return {?}
	         */
	        EventManagerPlugin.prototype.supports = function (eventName) { };
	        /**
	         * @abstract
	         * @param {?} element
	         * @param {?} eventName
	         * @param {?} handler
	         * @return {?}
	         */
	        EventManagerPlugin.prototype.addEventListener = function (element, eventName, handler) { };
	        /**
	         * @param {?} element
	         * @param {?} eventName
	         * @param {?} handler
	         * @return {?}
	         */
	        EventManagerPlugin.prototype.addGlobalEventListener = function (element, eventName, handler) {
	            var /** @type {?} */ target = getDOM().getGlobalEventTarget(element);
	            if (!target) {
	                throw new Error("Unsupported event target " + target + " for event " + eventName);
	            }
	            return this.addEventListener(target, eventName, handler);
	        };
	        ;
	        return EventManagerPlugin;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$4 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var SharedStylesHost = (function () {
	        function SharedStylesHost() {
	            /** @internal */
	            this._styles = [];
	            /** @internal */
	            this._stylesSet = new Set();
	        }
	        /**
	         * @param {?} styles
	         * @return {?}
	         */
	        SharedStylesHost.prototype.addStyles = function (styles) {
	            var _this = this;
	            var /** @type {?} */ additions = [];
	            styles.forEach(function (style) {
	                if (!_this._stylesSet.has(style)) {
	                    _this._stylesSet.add(style);
	                    _this._styles.push(style);
	                    additions.push(style);
	                }
	            });
	            this.onStylesAdded(additions);
	        };
	        /**
	         * @param {?} additions
	         * @return {?}
	         */
	        SharedStylesHost.prototype.onStylesAdded = function (additions) { };
	        /**
	         * @return {?}
	         */
	        SharedStylesHost.prototype.getAllStyles = function () { return this._styles; };
	        SharedStylesHost.decorators = [
	            { type: core.Injectable },
	        ];
	        /** @nocollapse */
	        SharedStylesHost.ctorParameters = function () { return []; };
	        return SharedStylesHost;
	    }());
	    var DomSharedStylesHost = (function (_super) {
	        __extends$4(DomSharedStylesHost, _super);
	        /**
	         * @param {?} doc
	         */
	        function DomSharedStylesHost(doc) {
	            _super.call(this);
	            this._hostNodes = new Set();
	            this._hostNodes.add(doc.head);
	        }
	        /**
	         * \@internal
	         * @param {?} styles
	         * @param {?} host
	         * @return {?}
	         */
	        DomSharedStylesHost.prototype._addStylesToHost = function (styles, host) {
	            for (var /** @type {?} */ i = 0; i < styles.length; i++) {
	                var /** @type {?} */ styleEl = document.createElement('style');
	                styleEl.textContent = styles[i];
	                host.appendChild(styleEl);
	            }
	        };
	        /**
	         * @param {?} hostNode
	         * @return {?}
	         */
	        DomSharedStylesHost.prototype.addHost = function (hostNode) {
	            this._addStylesToHost(this._styles, hostNode);
	            this._hostNodes.add(hostNode);
	        };
	        /**
	         * @param {?} hostNode
	         * @return {?}
	         */
	        DomSharedStylesHost.prototype.removeHost = function (hostNode) { this._hostNodes.delete(hostNode); };
	        /**
	         * @param {?} additions
	         * @return {?}
	         */
	        DomSharedStylesHost.prototype.onStylesAdded = function (additions) {
	            var _this = this;
	            this._hostNodes.forEach(function (hostNode) { _this._addStylesToHost(additions, hostNode); });
	        };
	        DomSharedStylesHost.decorators = [
	            { type: core.Injectable },
	        ];
	        /** @nocollapse */
	        DomSharedStylesHost.ctorParameters = function () { return [
	            { type: undefined, decorators: [{ type: core.Inject, args: [DOCUMENT,] },] },
	        ]; };
	        return DomSharedStylesHost;
	    }(SharedStylesHost));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$3 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ NAMESPACE_URIS = {
	        'xlink': 'http://www.w3.org/1999/xlink',
	        'svg': 'http://www.w3.org/2000/svg',
	        'xhtml': 'http://www.w3.org/1999/xhtml'
	    };
	    var /** @type {?} */ TEMPLATE_COMMENT_TEXT = 'template bindings={}';
	    var /** @type {?} */ TEMPLATE_BINDINGS_EXP = /^template bindings=(.*)$/;
	    /**
	     * @abstract
	     */
	    var DomRootRenderer = (function () {
	        /**
	         * @param {?} document
	         * @param {?} eventManager
	         * @param {?} sharedStylesHost
	         * @param {?} animationDriver
	         * @param {?} appId
	         */
	        function DomRootRenderer(document, eventManager, sharedStylesHost, animationDriver, appId) {
	            this.document = document;
	            this.eventManager = eventManager;
	            this.sharedStylesHost = sharedStylesHost;
	            this.animationDriver = animationDriver;
	            this.appId = appId;
	            this.registeredComponents = new Map();
	        }
	        /**
	         * @param {?} componentProto
	         * @return {?}
	         */
	        DomRootRenderer.prototype.renderComponent = function (componentProto) {
	            var /** @type {?} */ renderer = this.registeredComponents.get(componentProto.id);
	            if (!renderer) {
	                renderer = new DomRenderer(this, componentProto, this.animationDriver, this.appId + "-" + componentProto.id);
	                this.registeredComponents.set(componentProto.id, renderer);
	            }
	            return renderer;
	        };
	        return DomRootRenderer;
	    }());
	    var DomRootRenderer_ = (function (_super) {
	        __extends$3(DomRootRenderer_, _super);
	        /**
	         * @param {?} _document
	         * @param {?} _eventManager
	         * @param {?} sharedStylesHost
	         * @param {?} animationDriver
	         * @param {?} appId
	         */
	        function DomRootRenderer_(_document, _eventManager, sharedStylesHost, animationDriver, appId) {
	            _super.call(this, _document, _eventManager, sharedStylesHost, animationDriver, appId);
	        }
	        DomRootRenderer_.decorators = [
	            { type: core.Injectable },
	        ];
	        /** @nocollapse */
	        DomRootRenderer_.ctorParameters = function () { return [
	            { type: undefined, decorators: [{ type: core.Inject, args: [DOCUMENT,] },] },
	            { type: EventManager, },
	            { type: DomSharedStylesHost, },
	            { type: AnimationDriver, },
	            { type: undefined, decorators: [{ type: core.Inject, args: [core.APP_ID,] },] },
	        ]; };
	        return DomRootRenderer_;
	    }(DomRootRenderer));
	    var /** @type {?} */ DIRECT_DOM_RENDERER = {
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        remove: function (node) {
	            if (node.parentNode) {
	                node.parentNode.removeChild(node);
	            }
	        },
	        /**
	         * @param {?} node
	         * @param {?} parent
	         * @return {?}
	         */
	        appendChild: function (node, parent) { parent.appendChild(node); },
	        /**
	         * @param {?} node
	         * @param {?} refNode
	         * @return {?}
	         */
	        insertBefore: function (node, refNode) { refNode.parentNode.insertBefore(node, refNode); },
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        nextSibling: function (node) { return node.nextSibling; },
	        /**
	         * @param {?} node
	         * @return {?}
	         */
	        parentElement: function (node) { return (node.parentNode); }
	    };
	    var DomRenderer = (function () {
	        /**
	         * @param {?} _rootRenderer
	         * @param {?} componentProto
	         * @param {?} _animationDriver
	         * @param {?} styleShimId
	         */
	        function DomRenderer(_rootRenderer, componentProto, _animationDriver, styleShimId) {
	            this._rootRenderer = _rootRenderer;
	            this.componentProto = componentProto;
	            this._animationDriver = _animationDriver;
	            this.directRenderer = DIRECT_DOM_RENDERER;
	            this._styles = flattenStyles(styleShimId, componentProto.styles, []);
	            if (componentProto.encapsulation !== core.ViewEncapsulation.Native) {
	                this._rootRenderer.sharedStylesHost.addStyles(this._styles);
	            }
	            if (this.componentProto.encapsulation === core.ViewEncapsulation.Emulated) {
	                this._contentAttr = shimContentAttribute(styleShimId);
	                this._hostAttr = shimHostAttribute(styleShimId);
	            }
	            else {
	                this._contentAttr = null;
	                this._hostAttr = null;
	            }
	        }
	        /**
	         * @param {?} selectorOrNode
	         * @param {?} debugInfo
	         * @return {?}
	         */
	        DomRenderer.prototype.selectRootElement = function (selectorOrNode, debugInfo) {
	            var /** @type {?} */ el;
	            if (typeof selectorOrNode === 'string') {
	                el = this._rootRenderer.document.querySelector(selectorOrNode);
	                if (!el) {
	                    throw new Error("The selector \"" + selectorOrNode + "\" did not match any elements");
	                }
	            }
	            else {
	                el = selectorOrNode;
	            }
	            while (el.firstChild) {
	                el.removeChild(el.firstChild);
	            }
	            return el;
	        };
	        /**
	         * @param {?} parent
	         * @param {?} name
	         * @param {?} debugInfo
	         * @return {?}
	         */
	        DomRenderer.prototype.createElement = function (parent, name, debugInfo) {
	            var /** @type {?} */ el;
	            if (isNamespaced(name)) {
	                var /** @type {?} */ nsAndName = splitNamespace(name);
	                el = document.createElementNS((NAMESPACE_URIS)[nsAndName[0]], nsAndName[1]);
	            }
	            else {
	                el = document.createElement(name);
	            }
	            if (this._contentAttr) {
	                el.setAttribute(this._contentAttr, '');
	            }
	            if (parent) {
	                parent.appendChild(el);
	            }
	            return el;
	        };
	        /**
	         * @param {?} hostElement
	         * @return {?}
	         */
	        DomRenderer.prototype.createViewRoot = function (hostElement) {
	            var /** @type {?} */ nodesParent;
	            if (this.componentProto.encapsulation === core.ViewEncapsulation.Native) {
	                nodesParent = ((hostElement)).createShadowRoot();
	                this._rootRenderer.sharedStylesHost.addHost(nodesParent);
	                for (var /** @type {?} */ i = 0; i < this._styles.length; i++) {
	                    var /** @type {?} */ styleEl = document.createElement('style');
	                    styleEl.textContent = this._styles[i];
	                    nodesParent.appendChild(styleEl);
	                }
	            }
	            else {
	                if (this._hostAttr) {
	                    hostElement.setAttribute(this._hostAttr, '');
	                }
	                nodesParent = hostElement;
	            }
	            return nodesParent;
	        };
	        /**
	         * @param {?} parentElement
	         * @param {?} debugInfo
	         * @return {?}
	         */
	        DomRenderer.prototype.createTemplateAnchor = function (parentElement, debugInfo) {
	            var /** @type {?} */ comment = document.createComment(TEMPLATE_COMMENT_TEXT);
	            if (parentElement) {
	                parentElement.appendChild(comment);
	            }
	            return comment;
	        };
	        /**
	         * @param {?} parentElement
	         * @param {?} value
	         * @param {?} debugInfo
	         * @return {?}
	         */
	        DomRenderer.prototype.createText = function (parentElement, value, debugInfo) {
	            var /** @type {?} */ node = document.createTextNode(value);
	            if (parentElement) {
	                parentElement.appendChild(node);
	            }
	            return node;
	        };
	        /**
	         * @param {?} parentElement
	         * @param {?} nodes
	         * @return {?}
	         */
	        DomRenderer.prototype.projectNodes = function (parentElement, nodes) {
	            if (!parentElement)
	                return;
	            appendNodes(parentElement, nodes);
	        };
	        /**
	         * @param {?} node
	         * @param {?} viewRootNodes
	         * @return {?}
	         */
	        DomRenderer.prototype.attachViewAfter = function (node, viewRootNodes) { moveNodesAfterSibling(node, viewRootNodes); };
	        /**
	         * @param {?} viewRootNodes
	         * @return {?}
	         */
	        DomRenderer.prototype.detachView = function (viewRootNodes) {
	            for (var /** @type {?} */ i = 0; i < viewRootNodes.length; i++) {
	                var /** @type {?} */ node = viewRootNodes[i];
	                if (node.parentNode) {
	                    node.parentNode.removeChild(node);
	                }
	            }
	        };
	        /**
	         * @param {?} hostElement
	         * @param {?} viewAllNodes
	         * @return {?}
	         */
	        DomRenderer.prototype.destroyView = function (hostElement, viewAllNodes) {
	            if (this.componentProto.encapsulation === core.ViewEncapsulation.Native && hostElement) {
	                this._rootRenderer.sharedStylesHost.removeHost(((hostElement)).shadowRoot);
	            }
	        };
	        /**
	         * @param {?} renderElement
	         * @param {?} name
	         * @param {?} callback
	         * @return {?}
	         */
	        DomRenderer.prototype.listen = function (renderElement, name, callback) {
	            return this._rootRenderer.eventManager.addEventListener(renderElement, name, decoratePreventDefault(callback));
	        };
	        /**
	         * @param {?} target
	         * @param {?} name
	         * @param {?} callback
	         * @return {?}
	         */
	        DomRenderer.prototype.listenGlobal = function (target, name, callback) {
	            return this._rootRenderer.eventManager.addGlobalEventListener(target, name, decoratePreventDefault(callback));
	        };
	        /**
	         * @param {?} renderElement
	         * @param {?} propertyName
	         * @param {?} propertyValue
	         * @return {?}
	         */
	        DomRenderer.prototype.setElementProperty = function (renderElement, propertyName, propertyValue) {
	            ((renderElement))[propertyName] = propertyValue;
	        };
	        /**
	         * @param {?} renderElement
	         * @param {?} attributeName
	         * @param {?} attributeValue
	         * @return {?}
	         */
	        DomRenderer.prototype.setElementAttribute = function (renderElement, attributeName, attributeValue) {
	            var /** @type {?} */ attrNs;
	            var /** @type {?} */ attrNameWithoutNs = attributeName;
	            if (isNamespaced(attributeName)) {
	                var /** @type {?} */ nsAndName = splitNamespace(attributeName);
	                attrNameWithoutNs = nsAndName[1];
	                attributeName = nsAndName[0] + ':' + nsAndName[1];
	                attrNs = NAMESPACE_URIS[nsAndName[0]];
	            }
	            if (isPresent(attributeValue)) {
	                if (attrNs) {
	                    renderElement.setAttributeNS(attrNs, attributeName, attributeValue);
	                }
	                else {
	                    renderElement.setAttribute(attributeName, attributeValue);
	                }
	            }
	            else {
	                if (isPresent(attrNs)) {
	                    renderElement.removeAttributeNS(attrNs, attrNameWithoutNs);
	                }
	                else {
	                    renderElement.removeAttribute(attributeName);
	                }
	            }
	        };
	        /**
	         * @param {?} renderElement
	         * @param {?} propertyName
	         * @param {?} propertyValue
	         * @return {?}
	         */
	        DomRenderer.prototype.setBindingDebugInfo = function (renderElement, propertyName, propertyValue) {
	            if (renderElement.nodeType === Node.COMMENT_NODE) {
	                var /** @type {?} */ existingBindings = renderElement.nodeValue.replace(/\n/g, '').match(TEMPLATE_BINDINGS_EXP);
	                var /** @type {?} */ parsedBindings = JSON.parse(existingBindings[1]);
	                parsedBindings[propertyName] = propertyValue;
	                renderElement.nodeValue =
	                    TEMPLATE_COMMENT_TEXT.replace('{}', JSON.stringify(parsedBindings, null, 2));
	            }
	            else {
	                this.setElementAttribute(renderElement, propertyName, propertyValue);
	            }
	        };
	        /**
	         * @param {?} renderElement
	         * @param {?} className
	         * @param {?} isAdd
	         * @return {?}
	         */
	        DomRenderer.prototype.setElementClass = function (renderElement, className, isAdd) {
	            if (isAdd) {
	                renderElement.classList.add(className);
	            }
	            else {
	                renderElement.classList.remove(className);
	            }
	        };
	        /**
	         * @param {?} renderElement
	         * @param {?} styleName
	         * @param {?} styleValue
	         * @return {?}
	         */
	        DomRenderer.prototype.setElementStyle = function (renderElement, styleName, styleValue) {
	            if (isPresent(styleValue)) {
	                ((renderElement.style))[styleName] = stringify(styleValue);
	            }
	            else {
	                // IE requires '' instead of null
	                // see https://github.com/angular/angular/issues/7916
	                ((renderElement.style))[styleName] = '';
	            }
	        };
	        /**
	         * @param {?} renderElement
	         * @param {?} methodName
	         * @param {?} args
	         * @return {?}
	         */
	        DomRenderer.prototype.invokeElementMethod = function (renderElement, methodName, args) {
	            ((renderElement))[methodName].apply(renderElement, args);
	        };
	        /**
	         * @param {?} renderNode
	         * @param {?} text
	         * @return {?}
	         */
	        DomRenderer.prototype.setText = function (renderNode, text) { renderNode.nodeValue = text; };
	        /**
	         * @param {?} element
	         * @param {?} startingStyles
	         * @param {?} keyframes
	         * @param {?} duration
	         * @param {?} delay
	         * @param {?} easing
	         * @param {?=} previousPlayers
	         * @return {?}
	         */
	        DomRenderer.prototype.animate = function (element, startingStyles, keyframes, duration, delay, easing, previousPlayers) {
	            if (previousPlayers === void 0) { previousPlayers = []; }
	            if (this._rootRenderer.document.body.contains(element)) {
	                return this._animationDriver.animate(element, startingStyles, keyframes, duration, delay, easing, previousPlayers);
	            }
	            return new NoOpAnimationPlayer();
	        };
	        return DomRenderer;
	    }());
	    /**
	     * @param {?} sibling
	     * @param {?} nodes
	     * @return {?}
	     */
	    function moveNodesAfterSibling(sibling, nodes) {
	        var /** @type {?} */ parent = sibling.parentNode;
	        if (nodes.length > 0 && parent) {
	            var /** @type {?} */ nextSibling = sibling.nextSibling;
	            if (nextSibling) {
	                for (var /** @type {?} */ i = 0; i < nodes.length; i++) {
	                    parent.insertBefore(nodes[i], nextSibling);
	                }
	            }
	            else {
	                for (var /** @type {?} */ i = 0; i < nodes.length; i++) {
	                    parent.appendChild(nodes[i]);
	                }
	            }
	        }
	    }
	    /**
	     * @param {?} parent
	     * @param {?} nodes
	     * @return {?}
	     */
	    function appendNodes(parent, nodes) {
	        for (var /** @type {?} */ i = 0; i < nodes.length; i++) {
	            parent.appendChild(nodes[i]);
	        }
	    }
	    /**
	     * @param {?} eventHandler
	     * @return {?}
	     */
	    function decoratePreventDefault(eventHandler) {
	        return function (event) {
	            var /** @type {?} */ allowDefaultBehavior = eventHandler(event);
	            if (allowDefaultBehavior === false) {
	                // TODO(tbosch): move preventDefault into event plugins...
	                event.preventDefault();
	                event.returnValue = false;
	            }
	        };
	    }
	    var /** @type {?} */ COMPONENT_REGEX = /%COMP%/g;
	    var /** @type {?} */ COMPONENT_VARIABLE = '%COMP%';
	    var /** @type {?} */ HOST_ATTR = "_nghost-" + COMPONENT_VARIABLE;
	    var /** @type {?} */ CONTENT_ATTR = "_ngcontent-" + COMPONENT_VARIABLE;
	    /**
	     * @param {?} componentShortId
	     * @return {?}
	     */
	    function shimContentAttribute(componentShortId) {
	        return CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId);
	    }
	    /**
	     * @param {?} componentShortId
	     * @return {?}
	     */
	    function shimHostAttribute(componentShortId) {
	        return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId);
	    }
	    /**
	     * @param {?} compId
	     * @param {?} styles
	     * @param {?} target
	     * @return {?}
	     */
	    function flattenStyles(compId, styles, target) {
	        for (var /** @type {?} */ i = 0; i < styles.length; i++) {
	            var /** @type {?} */ style = styles[i];
	            if (Array.isArray(style)) {
	                flattenStyles(compId, style, target);
	            }
	            else {
	                style = style.replace(COMPONENT_REGEX, compId);
	                target.push(style);
	            }
	        }
	        return target;
	    }
	    var /** @type {?} */ NS_PREFIX_RE = /^:([^:]+):(.+)$/;
	    /**
	     * @param {?} name
	     * @return {?}
	     */
	    function isNamespaced(name) {
	        return name[0] === ':';
	    }
	    /**
	     * @param {?} name
	     * @return {?}
	     */
	    function splitNamespace(name) {
	        var /** @type {?} */ match = name.match(NS_PREFIX_RE);
	        return [match[1], match[2]];
	    }

	    var /** @type {?} */ CORE_TOKENS = {
	        'ApplicationRef': core.ApplicationRef,
	        'NgZone': core.NgZone,
	    };
	    var /** @type {?} */ INSPECT_GLOBAL_NAME = 'ng.probe';
	    var /** @type {?} */ CORE_TOKENS_GLOBAL_NAME = 'ng.coreTokens';
	    /**
	     * Returns a {\@link DebugElement} for the given native DOM element, or
	     * null if the given native element does not have an Angular view associated
	     * with it.
	     * @param {?} element
	     * @return {?}
	     */
	    function inspectNativeElement(element) {
	        return core.getDebugNode(element);
	    }
	    /**
	     * Deprecated. Use the one from '\@angular/core'.
	     * @deprecated
	     */
	    var NgProbeToken = (function () {
	        /**
	         * @param {?} name
	         * @param {?} token
	         */
	        function NgProbeToken(name, token) {
	            this.name = name;
	            this.token = token;
	        }
	        return NgProbeToken;
	    }());
	    /**
	     * @param {?} rootRenderer
	     * @param {?} extraTokens
	     * @param {?} coreTokens
	     * @return {?}
	     */
	    function _createConditionalRootRenderer(rootRenderer, extraTokens, coreTokens) {
	        return core.isDevMode() ?
	            _createRootRenderer(rootRenderer, (extraTokens || []).concat(coreTokens || [])) :
	            rootRenderer;
	    }
	    /**
	     * @param {?} rootRenderer
	     * @param {?} extraTokens
	     * @return {?}
	     */
	    function _createRootRenderer(rootRenderer, extraTokens) {
	        getDOM().setGlobalVar(INSPECT_GLOBAL_NAME, inspectNativeElement);
	        getDOM().setGlobalVar(CORE_TOKENS_GLOBAL_NAME, StringMapWrapper.merge(CORE_TOKENS, _ngProbeTokensToMap(extraTokens || [])));
	        return new DebugDomRootRenderer(rootRenderer);
	    }
	    /**
	     * @param {?} tokens
	     * @return {?}
	     */
	    function _ngProbeTokensToMap(tokens) {
	        return tokens.reduce(function (prev, t) { return (prev[t.name] = t.token, prev); }, {});
	    }
	    /**
	     * Providers which support debugging Angular applications (e.g. via `ng.probe`).
	     */
	    var /** @type {?} */ ELEMENT_PROBE_PROVIDERS = [{
	            provide: core.RootRenderer,
	            useFactory: _createConditionalRootRenderer,
	            deps: [
	                DomRootRenderer, [NgProbeToken, new core.Optional()],
	                [core.NgProbeToken, new core.Optional()]
	            ]
	        }];

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$5 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var DomEventsPlugin = (function (_super) {
	        __extends$5(DomEventsPlugin, _super);
	        function DomEventsPlugin() {
	            _super.apply(this, arguments);
	        }
	        /**
	         * @param {?} eventName
	         * @return {?}
	         */
	        DomEventsPlugin.prototype.supports = function (eventName) { return true; };
	        /**
	         * @param {?} element
	         * @param {?} eventName
	         * @param {?} handler
	         * @return {?}
	         */
	        DomEventsPlugin.prototype.addEventListener = function (element, eventName, handler) {
	            element.addEventListener(eventName, /** @type {?} */ (handler), false);
	            return function () { return element.removeEventListener(eventName, /** @type {?} */ (handler), false); };
	        };
	        DomEventsPlugin.decorators = [
	            { type: core.Injectable },
	        ];
	        /** @nocollapse */
	        DomEventsPlugin.ctorParameters = function () { return []; };
	        return DomEventsPlugin;
	    }(EventManagerPlugin));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$6 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ EVENT_NAMES = {
	        // pan
	        'pan': true,
	        'panstart': true,
	        'panmove': true,
	        'panend': true,
	        'pancancel': true,
	        'panleft': true,
	        'panright': true,
	        'panup': true,
	        'pandown': true,
	        // pinch
	        'pinch': true,
	        'pinchstart': true,
	        'pinchmove': true,
	        'pinchend': true,
	        'pinchcancel': true,
	        'pinchin': true,
	        'pinchout': true,
	        // press
	        'press': true,
	        'pressup': true,
	        // rotate
	        'rotate': true,
	        'rotatestart': true,
	        'rotatemove': true,
	        'rotateend': true,
	        'rotatecancel': true,
	        // swipe
	        'swipe': true,
	        'swipeleft': true,
	        'swiperight': true,
	        'swipeup': true,
	        'swipedown': true,
	        // tap
	        'tap': true,
	    };
	    /**
	     * A DI token that you can use to provide{@link HammerGestureConfig} to Angular. Use it to configure
	     * Hammer gestures.
	     *
	     * @experimental
	     */
	    var /** @type {?} */ HAMMER_GESTURE_CONFIG = new core.OpaqueToken('HammerGestureConfig');
	    /**
	     * \@experimental
	     */
	    var HammerGestureConfig = (function () {
	        function HammerGestureConfig() {
	            this.events = [];
	            this.overrides = {};
	        }
	        /**
	         * @param {?} element
	         * @return {?}
	         */
	        HammerGestureConfig.prototype.buildHammer = function (element) {
	            var /** @type {?} */ mc = new Hammer(element);
	            mc.get('pinch').set({ enable: true });
	            mc.get('rotate').set({ enable: true });
	            for (var eventName in this.overrides) {
	                mc.get(eventName).set(this.overrides[eventName]);
	            }
	            return mc;
	        };
	        HammerGestureConfig.decorators = [
	            { type: core.Injectable },
	        ];
	        /** @nocollapse */
	        HammerGestureConfig.ctorParameters = function () { return []; };
	        return HammerGestureConfig;
	    }());
	    var HammerGesturesPlugin = (function (_super) {
	        __extends$6(HammerGesturesPlugin, _super);
	        /**
	         * @param {?} _config
	         */
	        function HammerGesturesPlugin(_config) {
	            _super.call(this);
	            this._config = _config;
	        }
	        /**
	         * @param {?} eventName
	         * @return {?}
	         */
	        HammerGesturesPlugin.prototype.supports = function (eventName) {
	            if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {
	                return false;
	            }
	            if (!((window)).Hammer) {
	                throw new Error("Hammer.js is not loaded, can not bind " + eventName + " event");
	            }
	            return true;
	        };
	        /**
	         * @param {?} element
	         * @param {?} eventName
	         * @param {?} handler
	         * @return {?}
	         */
	        HammerGesturesPlugin.prototype.addEventListener = function (element, eventName, handler) {
	            var _this = this;
	            var /** @type {?} */ zone = this.manager.getZone();
	            eventName = eventName.toLowerCase();
	            return zone.runOutsideAngular(function () {
	                // Creating the manager bind events, must be done outside of angular
	                var /** @type {?} */ mc = _this._config.buildHammer(element);
	                var /** @type {?} */ callback = function (eventObj) {
	                    zone.runGuarded(function () { handler(eventObj); });
	                };
	                mc.on(eventName, callback);
	                return function () { return mc.off(eventName, callback); };
	            });
	        };
	        /**
	         * @param {?} eventName
	         * @return {?}
	         */
	        HammerGesturesPlugin.prototype.isCustomEvent = function (eventName) { return this._config.events.indexOf(eventName) > -1; };
	        HammerGesturesPlugin.decorators = [
	            { type: core.Injectable },
	        ];
	        /** @nocollapse */
	        HammerGesturesPlugin.ctorParameters = function () { return [
	            { type: HammerGestureConfig, decorators: [{ type: core.Inject, args: [HAMMER_GESTURE_CONFIG,] },] },
	        ]; };
	        return HammerGesturesPlugin;
	    }(EventManagerPlugin));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$7 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var /** @type {?} */ MODIFIER_KEYS = ['alt', 'control', 'meta', 'shift'];
	    var /** @type {?} */ MODIFIER_KEY_GETTERS = {
	        'alt': function (event) { return event.altKey; },
	        'control': function (event) { return event.ctrlKey; },
	        'meta': function (event) { return event.metaKey; },
	        'shift': function (event) { return event.shiftKey; }
	    };
	    /**
	     * \@experimental
	     */
	    var KeyEventsPlugin = (function (_super) {
	        __extends$7(KeyEventsPlugin, _super);
	        function KeyEventsPlugin() {
	            _super.call(this);
	        }
	        /**
	         * @param {?} eventName
	         * @return {?}
	         */
	        KeyEventsPlugin.prototype.supports = function (eventName) { return KeyEventsPlugin.parseEventName(eventName) != null; };
	        /**
	         * @param {?} element
	         * @param {?} eventName
	         * @param {?} handler
	         * @return {?}
	         */
	        KeyEventsPlugin.prototype.addEventListener = function (element, eventName, handler) {
	            var /** @type {?} */ parsedEvent = KeyEventsPlugin.parseEventName(eventName);
	            var /** @type {?} */ outsideHandler = KeyEventsPlugin.eventCallback(parsedEvent['fullKey'], handler, this.manager.getZone());
	            return this.manager.getZone().runOutsideAngular(function () {
	                return getDOM().onAndCancel(element, parsedEvent['domEventName'], outsideHandler);
	            });
	        };
	        /**
	         * @param {?} eventName
	         * @return {?}
	         */
	        KeyEventsPlugin.parseEventName = function (eventName) {
	            var /** @type {?} */ parts = eventName.toLowerCase().split('.');
	            var /** @type {?} */ domEventName = parts.shift();
	            if ((parts.length === 0) || !(domEventName === 'keydown' || domEventName === 'keyup')) {
	                return null;
	            }
	            var /** @type {?} */ key = KeyEventsPlugin._normalizeKey(parts.pop());
	            var /** @type {?} */ fullKey = '';
	            MODIFIER_KEYS.forEach(function (modifierName) {
	                var /** @type {?} */ index = parts.indexOf(modifierName);
	                if (index > -1) {
	                    parts.splice(index, 1);
	                    fullKey += modifierName + '.';
	                }
	            });
	            fullKey += key;
	            if (parts.length != 0 || key.length === 0) {
	                // returning null instead of throwing to let another plugin process the event
	                return null;
	            }
	            var /** @type {?} */ result = {};
	            result['domEventName'] = domEventName;
	            result['fullKey'] = fullKey;
	            return result;
	        };
	        /**
	         * @param {?} event
	         * @return {?}
	         */
	        KeyEventsPlugin.getEventFullKey = function (event) {
	            var /** @type {?} */ fullKey = '';
	            var /** @type {?} */ key = getDOM().getEventKey(event);
	            key = key.toLowerCase();
	            if (key === ' ') {
	                key = 'space'; // for readability
	            }
	            else if (key === '.') {
	                key = 'dot'; // because '.' is used as a separator in event names
	            }
	            MODIFIER_KEYS.forEach(function (modifierName) {
	                if (modifierName != key) {
	                    var /** @type {?} */ modifierGetter = MODIFIER_KEY_GETTERS[modifierName];
	                    if (modifierGetter(event)) {
	                        fullKey += modifierName + '.';
	                    }
	                }
	            });
	            fullKey += key;
	            return fullKey;
	        };
	        /**
	         * @param {?} fullKey
	         * @param {?} handler
	         * @param {?} zone
	         * @return {?}
	         */
	        KeyEventsPlugin.eventCallback = function (fullKey, handler, zone) {
	            return function (event /** TODO #9100 */) {
	                if (KeyEventsPlugin.getEventFullKey(event) === fullKey) {
	                    zone.runGuarded(function () { return handler(event); });
	                }
	            };
	        };
	        /**
	         * \@internal
	         * @param {?} keyName
	         * @return {?}
	         */
	        KeyEventsPlugin._normalizeKey = function (keyName) {
	            // TODO: switch to a Map if the mapping grows too much
	            switch (keyName) {
	                case 'esc':
	                    return 'escape';
	                default:
	                    return keyName;
	            }
	        };
	        KeyEventsPlugin.decorators = [
	            { type: core.Injectable },
	        ];
	        /** @nocollapse */
	        KeyEventsPlugin.ctorParameters = function () { return []; };
	        return KeyEventsPlugin;
	    }(EventManagerPlugin));

	    /**
	     * A pattern that recognizes a commonly useful subset of URLs that are safe.
	     *
	     * This regular expression matches a subset of URLs that will not cause script
	     * execution if used in URL context within a HTML document. Specifically, this
	     * regular expression matches if (comment from here on and regex copied from
	     * Soy's EscapingConventions):
	     * (1) Either a protocol in a whitelist (http, https, mailto or ftp).
	     * (2) or no protocol.  A protocol must be followed by a colon. The below
	     *     allows that by allowing colons only after one of the characters [/?#].
	     *     A colon after a hash (#) must be in the fragment.
	     *     Otherwise, a colon after a (?) must be in a query.
	     *     Otherwise, a colon after a single solidus (/) must be in a path.
	     *     Otherwise, a colon after a double solidus (//) must be in the authority
	     *     (before port).
	     *
	     * The pattern disallows &, used in HTML entity declarations before
	     * one of the characters in [/?#]. This disallows HTML entities used in the
	     * protocol name, which should never happen, e.g. "h&#116;tp" for "http".
	     * It also disallows HTML entities in the first path part of a relative path,
	     * e.g. "foo&lt;bar/baz".  Our existing escaping functions should not produce
	     * that. More importantly, it disallows masking of a colon,
	     * e.g. "javascript&#58;...".
	     *
	     * This regular expression was taken from the Closure sanitization library.
	     */
	    var /** @type {?} */ SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;
	    /** A pattern that matches safe data URLs. Only matches image, video and audio types. */
	    var /** @type {?} */ DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;
	    /**
	     * @param {?} url
	     * @return {?}
	     */
	    function sanitizeUrl(url) {
	        url = String(url);
	        if (url.match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN))
	            return url;
	        if (core.isDevMode()) {
	            getDOM().log("WARNING: sanitizing unsafe URL value " + url + " (see http://g.co/ng/security#xss)");
	        }
	        return 'unsafe:' + url;
	    }
	    /**
	     * @param {?} srcset
	     * @return {?}
	     */
	    function sanitizeSrcset(srcset) {
	        srcset = String(srcset);
	        return srcset.split(',').map(function (srcset) { return sanitizeUrl(srcset.trim()); }).join(', ');
	    }

	    /** A <body> element that can be safely used to parse untrusted HTML. Lazily initialized below. */
	    var /** @type {?} */ inertElement = null;
	    /** Lazily initialized to make sure the DOM adapter gets set before use. */
	    var /** @type {?} */ DOM = null;
	    /**
	     * Returns an HTML element that is guaranteed to not execute code when creating elements in it.
	     * @return {?}
	     */
	    function getInertElement() {
	        if (inertElement)
	            return inertElement;
	        DOM = getDOM();
	        // Prefer using <template> element if supported.
	        var /** @type {?} */ templateEl = DOM.createElement('template');
	        if ('content' in templateEl)
	            return templateEl;
	        var /** @type {?} */ doc = DOM.createHtmlDocument();
	        inertElement = DOM.querySelector(doc, 'body');
	        if (inertElement == null) {
	            // usually there should be only one body element in the document, but IE doesn't have any, so we
	            // need to create one.
	            var /** @type {?} */ html = DOM.createElement('html', doc);
	            inertElement = DOM.createElement('body', doc);
	            DOM.appendChild(html, inertElement);
	            DOM.appendChild(doc, html);
	        }
	        return inertElement;
	    }
	    /**
	     * @param {?} tags
	     * @return {?}
	     */
	    function tagSet(tags) {
	        var /** @type {?} */ res = {};
	        for (var _i = 0, _a = tags.split(','); _i < _a.length; _i++) {
	            var t = _a[_i];
	            res[t] = true;
	        }
	        return res;
	    }
	    /**
	     * @param {...?} sets
	     * @return {?}
	     */
	    function merge() {
	        var sets = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            sets[_i - 0] = arguments[_i];
	        }
	        var /** @type {?} */ res = {};
	        for (var _a = 0, sets_1 = sets; _a < sets_1.length; _a++) {
	            var s = sets_1[_a];
	            for (var v in s) {
	                if (s.hasOwnProperty(v))
	                    res[v] = true;
	            }
	        }
	        return res;
	    }
	    // Good source of info about elements and attributes
	    // http://dev.w3.org/html5/spec/Overview.html#semantics
	    // http://simon.html5.org/html-elements
	    // Safe Void Elements - HTML5
	    // http://dev.w3.org/html5/spec/Overview.html#void-elements
	    var /** @type {?} */ VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr');
	    // Elements that you can, intentionally, leave open (and which close themselves)
	    // http://dev.w3.org/html5/spec/Overview.html#optional-tags
	    var /** @type {?} */ OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');
	    var /** @type {?} */ OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet('rp,rt');
	    var /** @type {?} */ OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);
	    // Safe Block Elements - HTML5
	    var /** @type {?} */ BLOCK_ELEMENTS = merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet('address,article,' +
	        'aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' +
	        'h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'));
	    // Inline Elements - HTML5
	    var /** @type {?} */ INLINE_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet('a,abbr,acronym,audio,b,' +
	        'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,' +
	        'samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'));
	    var /** @type {?} */ VALID_ELEMENTS = merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);
	    // Attributes that have href and hence need to be sanitized
	    var /** @type {?} */ URI_ATTRS = tagSet('background,cite,href,itemtype,longdesc,poster,src,xlink:href');
	    // Attributes that have special href set hence need to be sanitized
	    var /** @type {?} */ SRCSET_ATTRS = tagSet('srcset');
	    var /** @type {?} */ HTML_ATTRS = tagSet('abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,' +
	        'compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,' +
	        'ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,' +
	        'scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,' +
	        'valign,value,vspace,width');
	    // NB: This currently conciously doesn't support SVG. SVG sanitization has had several security
	    // issues in the past, so it seems safer to leave it out if possible. If support for binding SVG via
	    // innerHTML is required, SVG attributes should be added here.
	    // NB: Sanitization does not allow <form> elements or other active elements (<button> etc). Those
	    // can be sanitized, but they increase security surface area without a legitimate use case, so they
	    // are left out here.
	    var /** @type {?} */ VALID_ATTRS = merge(URI_ATTRS, SRCSET_ATTRS, HTML_ATTRS);
	    /**
	     * SanitizingHtmlSerializer serializes a DOM fragment, stripping out any unsafe elements and unsafe
	     * attributes.
	     */
	    var SanitizingHtmlSerializer = (function () {
	        function SanitizingHtmlSerializer() {
	            this.sanitizedSomething = false;
	            this.buf = [];
	        }
	        /**
	         * @param {?} el
	         * @return {?}
	         */
	        SanitizingHtmlSerializer.prototype.sanitizeChildren = function (el) {
	            // This cannot use a TreeWalker, as it has to run on Angular's various DOM adapters.
	            // However this code never accesses properties off of `document` before deleting its contents
	            // again, so it shouldn't be vulnerable to DOM clobbering.
	            var /** @type {?} */ current = el.firstChild;
	            while (current) {
	                if (DOM.isElementNode(current)) {
	                    this.startElement(/** @type {?} */ (current));
	                }
	                else if (DOM.isTextNode(current)) {
	                    this.chars(DOM.nodeValue(current));
	                }
	                else {
	                    // Strip non-element, non-text nodes.
	                    this.sanitizedSomething = true;
	                }
	                if (DOM.firstChild(current)) {
	                    current = DOM.firstChild(current);
	                    continue;
	                }
	                while (current) {
	                    // Leaving the element. Walk up and to the right, closing tags as we go.
	                    if (DOM.isElementNode(current)) {
	                        this.endElement(/** @type {?} */ (current));
	                    }
	                    if (DOM.nextSibling(current)) {
	                        current = DOM.nextSibling(current);
	                        break;
	                    }
	                    current = DOM.parentElement(current);
	                }
	            }
	            return this.buf.join('');
	        };
	        /**
	         * @param {?} element
	         * @return {?}
	         */
	        SanitizingHtmlSerializer.prototype.startElement = function (element) {
	            var _this = this;
	            var /** @type {?} */ tagName = DOM.nodeName(element).toLowerCase();
	            if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {
	                this.sanitizedSomething = true;
	                return;
	            }
	            this.buf.push('<');
	            this.buf.push(tagName);
	            DOM.attributeMap(element).forEach(function (value, attrName) {
	                var /** @type {?} */ lower = attrName.toLowerCase();
	                if (!VALID_ATTRS.hasOwnProperty(lower)) {
	                    _this.sanitizedSomething = true;
	                    return;
	                }
	                // TODO(martinprobst): Special case image URIs for data:image/...
	                if (URI_ATTRS[lower])
	                    value = sanitizeUrl(value);
	                if (SRCSET_ATTRS[lower])
	                    value = sanitizeSrcset(value);
	                _this.buf.push(' ');
	                _this.buf.push(attrName);
	                _this.buf.push('="');
	                _this.buf.push(encodeEntities(value));
	                _this.buf.push('"');
	            });
	            this.buf.push('>');
	        };
	        /**
	         * @param {?} current
	         * @return {?}
	         */
	        SanitizingHtmlSerializer.prototype.endElement = function (current) {
	            var /** @type {?} */ tagName = DOM.nodeName(current).toLowerCase();
	            if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {
	                this.buf.push('</');
	                this.buf.push(tagName);
	                this.buf.push('>');
	            }
	        };
	        /**
	         * @param {?} chars
	         * @return {?}
	         */
	        SanitizingHtmlSerializer.prototype.chars = function (chars /** TODO #9100 */) { this.buf.push(encodeEntities(chars)); };
	        return SanitizingHtmlSerializer;
	    }());
	    // Regular Expressions for parsing tags and attributes
	    var /** @type {?} */ SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
	    // ! to ~ is the ASCII range.
	    var /** @type {?} */ NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
	    /**
	     * Escapes all potentially dangerous characters, so that the
	     * resulting string can be safely inserted into attribute or
	     * element text.
	     * @param {?} value
	     * @return {?}
	     */
	    function encodeEntities(value) {
	        return value.replace(/&/g, '&amp;')
	            .replace(SURROGATE_PAIR_REGEXP, function (match) {
	            var /** @type {?} */ hi = match.charCodeAt(0);
	            var /** @type {?} */ low = match.charCodeAt(1);
	            return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
	        })
	            .replace(NON_ALPHANUMERIC_REGEXP, function (match) { return '&#' + match.charCodeAt(0) + ';'; })
	            .replace(/</g, '&lt;')
	            .replace(/>/g, '&gt;');
	    }
	    /**
	     * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1'
	     * attribute to declare ns1 namespace and prefixes the attribute with 'ns1' (e.g. 'ns1:xlink:foo').
	     *
	     * This is undesirable since we don't want to allow any of these custom attributes. This method
	     * strips them all.
	     * @param {?} el
	     * @return {?}
	     */
	    function stripCustomNsAttrs(el) {
	        DOM.attributeMap(el).forEach(function (_, attrName) {
	            if (attrName === 'xmlns:ns1' || attrName.indexOf('ns1:') === 0) {
	                DOM.removeAttribute(el, attrName);
	            }
	        });
	        for (var _i = 0, _a = DOM.childNodesAsList(el); _i < _a.length; _i++) {
	            var n = _a[_i];
	            if (DOM.isElementNode(n))
	                stripCustomNsAttrs(/** @type {?} */ (n));
	        }
	    }
	    /**
	     * Sanitizes the given unsafe, untrusted HTML fragment, and returns HTML text that is safe to add to
	     * the DOM in a browser environment.
	     * @param {?} unsafeHtmlInput
	     * @return {?}
	     */
	    function sanitizeHtml(unsafeHtmlInput) {
	        try {
	            var /** @type {?} */ containerEl = getInertElement();
	            // Make sure unsafeHtml is actually a string (TypeScript types are not enforced at runtime).
	            var /** @type {?} */ unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : '';
	            // mXSS protection. Repeatedly parse the document to make sure it stabilizes, so that a browser
	            // trying to auto-correct incorrect HTML cannot cause formerly inert HTML to become dangerous.
	            var /** @type {?} */ mXSSAttempts = 5;
	            var /** @type {?} */ parsedHtml = unsafeHtml;
	            do {
	                if (mXSSAttempts === 0) {
	                    throw new Error('Failed to sanitize html because the input is unstable');
	                }
	                mXSSAttempts--;
	                unsafeHtml = parsedHtml;
	                DOM.setInnerHTML(containerEl, unsafeHtml);
	                if (((DOM.defaultDoc())).documentMode) {
	                    // strip custom-namespaced attributes on IE<=11
	                    stripCustomNsAttrs(containerEl);
	                }
	                parsedHtml = DOM.getInnerHTML(containerEl);
	            } while (unsafeHtml !== parsedHtml);
	            var /** @type {?} */ sanitizer = new SanitizingHtmlSerializer();
	            var /** @type {?} */ safeHtml = sanitizer.sanitizeChildren(DOM.getTemplateContent(containerEl) || containerEl);
	            // Clear out the body element.
	            var /** @type {?} */ parent_1 = DOM.getTemplateContent(containerEl) || containerEl;
	            for (var _i = 0, _a = DOM.childNodesAsList(parent_1); _i < _a.length; _i++) {
	                var child = _a[_i];
	                DOM.removeChild(parent_1, child);
	            }
	            if (core.isDevMode() && sanitizer.sanitizedSomething) {
	                DOM.log('WARNING: sanitizing HTML stripped some content (see http://g.co/ng/security#xss).');
	            }
	            return safeHtml;
	        }
	        catch (e) {
	            // In case anything goes wrong, clear out inertElement to reset the entire DOM structure.
	            inertElement = null;
	            throw e;
	        }
	    }

	    /**
	     * Regular expression for safe style values.
	     *
	     * Quotes (" and ') are allowed, but a check must be done elsewhere to ensure they're balanced.
	     *
	     * ',' allows multiple values to be assigned to the same property (e.g. background-attachment or
	     * font-family) and hence could allow multiple values to get injected, but that should pose no risk
	     * of XSS.
	     *
	     * The function expression checks only for XSS safety, not for CSS validity.
	     *
	     * This regular expression was taken from the Closure sanitization library, and augmented for
	     * transformation values.
	     */
	    var /** @type {?} */ VALUES = '[-,."\'%_!# a-zA-Z0-9]+';
	    var /** @type {?} */ TRANSFORMATION_FNS = '(?:matrix|translate|scale|rotate|skew|perspective)(?:X|Y|3d)?';
	    var /** @type {?} */ COLOR_FNS = '(?:rgb|hsl)a?';
	    var /** @type {?} */ GRADIENTS = '(?:repeating-)?(?:linear|radial)-gradient';
	    var /** @type {?} */ CSS3_FNS = '(?:calc|attr)';
	    var /** @type {?} */ FN_ARGS = '\\([-0-9.%, #a-zA-Z]+\\)';
	    var /** @type {?} */ SAFE_STYLE_VALUE = new RegExp(("^(" + VALUES + "|") +
	        ("(?:" + TRANSFORMATION_FNS + "|" + COLOR_FNS + "|" + GRADIENTS + "|" + CSS3_FNS + ")") +
	        (FN_ARGS + ")$"), 'g');
	    /**
	     * Matches a `url(...)` value with an arbitrary argument as long as it does
	     * not contain parentheses.
	     *
	     * The URL value still needs to be sanitized separately.
	     *
	     * `url(...)` values are a very common use case, e.g. for `background-image`. With carefully crafted
	     * CSS style rules, it is possible to construct an information leak with `url` values in CSS, e.g.
	     * by observing whether scroll bars are displayed, or character ranges used by a font face
	     * definition.
	     *
	     * Angular only allows binding CSS values (as opposed to entire CSS rules), so it is unlikely that
	     * binding a URL value without further cooperation from the page will cause an information leak, and
	     * if so, it is just a leak, not a full blown XSS vulnerability.
	     *
	     * Given the common use case, low likelihood of attack vector, and low impact of an attack, this
	     * code is permissive and allows URLs that sanitize otherwise.
	     */
	    var /** @type {?} */ URL_RE = /^url\(([^)]+)\)$/;
	    /**
	     * Checks that quotes (" and ') are properly balanced inside a string. Assumes
	     * that neither escape (\) nor any other character that could result in
	     * breaking out of a string parsing context are allowed;
	     * see http://www.w3.org/TR/css3-syntax/#string-token-diagram.
	     *
	     * This code was taken from the Closure sanitization library.
	     * @param {?} value
	     * @return {?}
	     */
	    function hasBalancedQuotes(value) {
	        var /** @type {?} */ outsideSingle = true;
	        var /** @type {?} */ outsideDouble = true;
	        for (var /** @type {?} */ i = 0; i < value.length; i++) {
	            var /** @type {?} */ c = value.charAt(i);
	            if (c === '\'' && outsideDouble) {
	                outsideSingle = !outsideSingle;
	            }
	            else if (c === '"' && outsideSingle) {
	                outsideDouble = !outsideDouble;
	            }
	        }
	        return outsideSingle && outsideDouble;
	    }
	    /**
	     * Sanitizes the given untrusted CSS style property value (i.e. not an entire object, just a single
	     * value) and returns a value that is safe to use in a browser environment.
	     * @param {?} value
	     * @return {?}
	     */
	    function sanitizeStyle(value) {
	        value = String(value).trim(); // Make sure it's actually a string.
	        if (!value)
	            return '';
	        // Single url(...) values are supported, but only for URLs that sanitize cleanly. See above for
	        // reasoning behind this.
	        var /** @type {?} */ urlMatch = value.match(URL_RE);
	        if ((urlMatch && sanitizeUrl(urlMatch[1]) === urlMatch[1]) ||
	            value.match(SAFE_STYLE_VALUE) && hasBalancedQuotes(value)) {
	            return value; // Safe style values.
	        }
	        if (core.isDevMode()) {
	            getDOM().log("WARNING: sanitizing unsafe style value " + value + " (see http://g.co/ng/security#xss).");
	        }
	        return 'unsafe';
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$8 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * DomSanitizer helps preventing Cross Site Scripting Security bugs (XSS) by sanitizing
	     * values to be safe to use in the different DOM contexts.
	     *
	     * For example, when binding a URL in an `<a [href]="someValue">` hyperlink, `someValue` will be
	     * sanitized so that an attacker cannot inject e.g. a `javascript:` URL that would execute code on
	     * the website.
	     *
	     * In specific situations, it might be necessary to disable sanitization, for example if the
	     * application genuinely needs to produce a `javascript:` style link with a dynamic value in it.
	     * Users can bypass security by constructing a value with one of the `bypassSecurityTrust...`
	     * methods, and then binding to that value from the template.
	     *
	     * These situations should be very rare, and extraordinary care must be taken to avoid creating a
	     * Cross Site Scripting (XSS) security bug!
	     *
	     * When using `bypassSecurityTrust...`, make sure to call the method as early as possible and as
	     * close as possible to the source of the value, to make it easy to verify no security bug is
	     * created by its use.
	     *
	     * It is not required (and not recommended) to bypass security if the value is safe, e.g. a URL that
	     * does not start with a suspicious protocol, or an HTML snippet that does not contain dangerous
	     * code. The sanitizer leaves safe values intact.
	     *
	     * \@security Calling any of the `bypassSecurityTrust...` APIs disables Angular's built-in
	     * sanitization for the value passed in. Carefully check and audit all values and code paths going
	     * into this call. Make sure any user data is appropriately escaped for this security context.
	     * For more detail, see the [Security Guide](http://g.co/ng/security).
	     *
	     * \@stable
	     * @abstract
	     */
	    var DomSanitizer = (function () {
	        function DomSanitizer() {
	        }
	        /**
	         * Sanitizes a value for use in the given SecurityContext.
	         *
	         * If value is trusted for the context, this method will unwrap the contained safe value and use
	         * it directly. Otherwise, value will be sanitized to be safe in the given context, for example
	         * by replacing URLs that have an unsafe protocol part (such as `javascript:`). The implementation
	         * is responsible to make sure that the value can definitely be safely used in the given context.
	         * @abstract
	         * @param {?} context
	         * @param {?} value
	         * @return {?}
	         */
	        DomSanitizer.prototype.sanitize = function (context, value) { };
	        /**
	         * Bypass security and trust the given value to be safe HTML. Only use this when the bound HTML
	         * is unsafe (e.g. contains `<script>` tags) and the code should be executed. The sanitizer will
	         * leave safe HTML intact, so in most situations this method should not be used.
	         *
	         * **WARNING:** calling this method with untrusted user data exposes your application to XSS
	         * security risks!
	         * @abstract
	         * @param {?} value
	         * @return {?}
	         */
	        DomSanitizer.prototype.bypassSecurityTrustHtml = function (value) { };
	        /**
	         * Bypass security and trust the given value to be safe style value (CSS).
	         *
	         * **WARNING:** calling this method with untrusted user data exposes your application to XSS
	         * security risks!
	         * @abstract
	         * @param {?} value
	         * @return {?}
	         */
	        DomSanitizer.prototype.bypassSecurityTrustStyle = function (value) { };
	        /**
	         * Bypass security and trust the given value to be safe JavaScript.
	         *
	         * **WARNING:** calling this method with untrusted user data exposes your application to XSS
	         * security risks!
	         * @abstract
	         * @param {?} value
	         * @return {?}
	         */
	        DomSanitizer.prototype.bypassSecurityTrustScript = function (value) { };
	        /**
	         * Bypass security and trust the given value to be a safe style URL, i.e. a value that can be used
	         * in hyperlinks or `<img src>`.
	         *
	         * **WARNING:** calling this method with untrusted user data exposes your application to XSS
	         * security risks!
	         * @abstract
	         * @param {?} value
	         * @return {?}
	         */
	        DomSanitizer.prototype.bypassSecurityTrustUrl = function (value) { };
	        /**
	         * Bypass security and trust the given value to be a safe resource URL, i.e. a location that may
	         * be used to load executable code from, like `<script src>`, or `<iframe src>`.
	         *
	         * **WARNING:** calling this method with untrusted user data exposes your application to XSS
	         * security risks!
	         * @abstract
	         * @param {?} value
	         * @return {?}
	         */
	        DomSanitizer.prototype.bypassSecurityTrustResourceUrl = function (value) { };
	        return DomSanitizer;
	    }());
	    var DomSanitizerImpl = (function (_super) {
	        __extends$8(DomSanitizerImpl, _super);
	        function DomSanitizerImpl() {
	            _super.apply(this, arguments);
	        }
	        /**
	         * @param {?} ctx
	         * @param {?} value
	         * @return {?}
	         */
	        DomSanitizerImpl.prototype.sanitize = function (ctx, value) {
	            if (value == null)
	                return null;
	            switch (ctx) {
	                case core.SecurityContext.NONE:
	                    return value;
	                case core.SecurityContext.HTML:
	                    if (value instanceof SafeHtmlImpl)
	                        return value.changingThisBreaksApplicationSecurity;
	                    this.checkNotSafeValue(value, 'HTML');
	                    return sanitizeHtml(String(value));
	                case core.SecurityContext.STYLE:
	                    if (value instanceof SafeStyleImpl)
	                        return value.changingThisBreaksApplicationSecurity;
	                    this.checkNotSafeValue(value, 'Style');
	                    return sanitizeStyle(value);
	                case core.SecurityContext.SCRIPT:
	                    if (value instanceof SafeScriptImpl)
	                        return value.changingThisBreaksApplicationSecurity;
	                    this.checkNotSafeValue(value, 'Script');
	                    throw new Error('unsafe value used in a script context');
	                case core.SecurityContext.URL:
	                    if (value instanceof SafeResourceUrlImpl || value instanceof SafeUrlImpl) {
	                        // Allow resource URLs in URL contexts, they are strictly more trusted.
	                        return value.changingThisBreaksApplicationSecurity;
	                    }
	                    this.checkNotSafeValue(value, 'URL');
	                    return sanitizeUrl(String(value));
	                case core.SecurityContext.RESOURCE_URL:
	                    if (value instanceof SafeResourceUrlImpl) {
	                        return value.changingThisBreaksApplicationSecurity;
	                    }
	                    this.checkNotSafeValue(value, 'ResourceURL');
	                    throw new Error('unsafe value used in a resource URL context (see http://g.co/ng/security#xss)');
	                default:
	                    throw new Error("Unexpected SecurityContext " + ctx + " (see http://g.co/ng/security#xss)");
	            }
	        };
	        /**
	         * @param {?} value
	         * @param {?} expectedType
	         * @return {?}
	         */
	        DomSanitizerImpl.prototype.checkNotSafeValue = function (value, expectedType) {
	            if (value instanceof SafeValueImpl) {
	                throw new Error(("Required a safe " + expectedType + ", got a " + value.getTypeName() + " ") +
	                    "(see http://g.co/ng/security#xss)");
	            }
	        };
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        DomSanitizerImpl.prototype.bypassSecurityTrustHtml = function (value) { return new SafeHtmlImpl(value); };
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        DomSanitizerImpl.prototype.bypassSecurityTrustStyle = function (value) { return new SafeStyleImpl(value); };
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        DomSanitizerImpl.prototype.bypassSecurityTrustScript = function (value) { return new SafeScriptImpl(value); };
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        DomSanitizerImpl.prototype.bypassSecurityTrustUrl = function (value) { return new SafeUrlImpl(value); };
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        DomSanitizerImpl.prototype.bypassSecurityTrustResourceUrl = function (value) {
	            return new SafeResourceUrlImpl(value);
	        };
	        DomSanitizerImpl.decorators = [
	            { type: core.Injectable },
	        ];
	        /** @nocollapse */
	        DomSanitizerImpl.ctorParameters = function () { return []; };
	        return DomSanitizerImpl;
	    }(DomSanitizer));
	    /**
	     * @abstract
	     */
	    var SafeValueImpl = (function () {
	        /**
	         * @param {?} changingThisBreaksApplicationSecurity
	         */
	        function SafeValueImpl(changingThisBreaksApplicationSecurity) {
	            this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;
	            // empty
	        }
	        /**
	         * @abstract
	         * @return {?}
	         */
	        SafeValueImpl.prototype.getTypeName = function () { };
	        /**
	         * @return {?}
	         */
	        SafeValueImpl.prototype.toString = function () {
	            return ("SafeValue must use [property]=binding: " + this.changingThisBreaksApplicationSecurity) +
	                " (see http://g.co/ng/security#xss)";
	        };
	        return SafeValueImpl;
	    }());
	    var SafeHtmlImpl = (function (_super) {
	        __extends$8(SafeHtmlImpl, _super);
	        function SafeHtmlImpl() {
	            _super.apply(this, arguments);
	        }
	        /**
	         * @return {?}
	         */
	        SafeHtmlImpl.prototype.getTypeName = function () { return 'HTML'; };
	        return SafeHtmlImpl;
	    }(SafeValueImpl));
	    var SafeStyleImpl = (function (_super) {
	        __extends$8(SafeStyleImpl, _super);
	        function SafeStyleImpl() {
	            _super.apply(this, arguments);
	        }
	        /**
	         * @return {?}
	         */
	        SafeStyleImpl.prototype.getTypeName = function () { return 'Style'; };
	        return SafeStyleImpl;
	    }(SafeValueImpl));
	    var SafeScriptImpl = (function (_super) {
	        __extends$8(SafeScriptImpl, _super);
	        function SafeScriptImpl() {
	            _super.apply(this, arguments);
	        }
	        /**
	         * @return {?}
	         */
	        SafeScriptImpl.prototype.getTypeName = function () { return 'Script'; };
	        return SafeScriptImpl;
	    }(SafeValueImpl));
	    var SafeUrlImpl = (function (_super) {
	        __extends$8(SafeUrlImpl, _super);
	        function SafeUrlImpl() {
	            _super.apply(this, arguments);
	        }
	        /**
	         * @return {?}
	         */
	        SafeUrlImpl.prototype.getTypeName = function () { return 'URL'; };
	        return SafeUrlImpl;
	    }(SafeValueImpl));
	    var SafeResourceUrlImpl = (function (_super) {
	        __extends$8(SafeResourceUrlImpl, _super);
	        function SafeResourceUrlImpl() {
	            _super.apply(this, arguments);
	        }
	        /**
	         * @return {?}
	         */
	        SafeResourceUrlImpl.prototype.getTypeName = function () { return 'ResourceURL'; };
	        return SafeResourceUrlImpl;
	    }(SafeValueImpl));

	    var /** @type {?} */ INTERNAL_BROWSER_PLATFORM_PROVIDERS = [
	        { provide: core.PLATFORM_INITIALIZER, useValue: initDomAdapter, multi: true },
	        { provide: _angular_common.PlatformLocation, useClass: BrowserPlatformLocation }
	    ];
	    /**
	     * @security Replacing built-in sanitization providers exposes the application to XSS risks.
	     * Attacker-controlled data introduced by an unsanitized provider could expose your
	     * application to XSS risks. For more detail, see the [Security Guide](http://g.co/ng/security).
	     * @experimental
	     */
	    var /** @type {?} */ BROWSER_SANITIZATION_PROVIDERS = [
	        { provide: core.Sanitizer, useExisting: DomSanitizer },
	        { provide: DomSanitizer, useClass: DomSanitizerImpl },
	    ];
	    /**
	     * @stable
	     */
	    var /** @type {?} */ platformBrowser = core.createPlatformFactory(core.platformCore, 'browser', INTERNAL_BROWSER_PLATFORM_PROVIDERS);
	    /**
	     * @return {?}
	     */
	    function initDomAdapter() {
	        BrowserDomAdapter.makeCurrent();
	        BrowserGetTestability.init();
	    }
	    /**
	     * @return {?}
	     */
	    function errorHandler() {
	        return new core.ErrorHandler();
	    }
	    /**
	     * @return {?}
	     */
	    function _document() {
	        return getDOM().defaultDoc();
	    }
	    /**
	     * @return {?}
	     */
	    function _resolveDefaultAnimationDriver() {
	        if (getDOM().supportsWebAnimation()) {
	            return new WebAnimationsDriver();
	        }
	        return AnimationDriver.NOOP;
	    }
	    /**
	     * The ng module for the browser.
	     *
	     * \@stable
	     */
	    var BrowserModule = (function () {
	        /**
	         * @param {?} parentModule
	         */
	        function BrowserModule(parentModule) {
	            if (parentModule) {
	                throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.");
	            }
	        }
	        BrowserModule.decorators = [
	            { type: core.NgModule, args: [{
	                        providers: [
	                            BROWSER_SANITIZATION_PROVIDERS, { provide: core.ErrorHandler, useFactory: errorHandler, deps: [] },
	                            { provide: DOCUMENT, useFactory: _document, deps: [] },
	                            { provide: EVENT_MANAGER_PLUGINS, useClass: DomEventsPlugin, multi: true },
	                            { provide: EVENT_MANAGER_PLUGINS, useClass: KeyEventsPlugin, multi: true },
	                            { provide: EVENT_MANAGER_PLUGINS, useClass: HammerGesturesPlugin, multi: true },
	                            { provide: HAMMER_GESTURE_CONFIG, useClass: HammerGestureConfig },
	                            { provide: DomRootRenderer, useClass: DomRootRenderer_ },
	                            { provide: core.RootRenderer, useExisting: DomRootRenderer },
	                            { provide: SharedStylesHost, useExisting: DomSharedStylesHost },
	                            { provide: AnimationDriver, useFactory: _resolveDefaultAnimationDriver }, DomSharedStylesHost,
	                            core.Testability, EventManager, ELEMENT_PROBE_PROVIDERS, Title
	                        ],
	                        exports: [_angular_common.CommonModule, core.ApplicationModule]
	                    },] },
	        ];
	        /** @nocollapse */
	        BrowserModule.ctorParameters = function () { return [
	            { type: BrowserModule, decorators: [{ type: core.Optional }, { type: core.SkipSelf },] },
	        ]; };
	        return BrowserModule;
	    }());

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * JS version of browser APIs. This library can only run in the browser.
	     */
	    var /** @type {?} */ win = typeof window !== 'undefined' && window || ({});

	    var ChangeDetectionPerfRecord = (function () {
	        /**
	         * @param {?} msPerTick
	         * @param {?} numTicks
	         */
	        function ChangeDetectionPerfRecord(msPerTick, numTicks) {
	            this.msPerTick = msPerTick;
	            this.numTicks = numTicks;
	        }
	        return ChangeDetectionPerfRecord;
	    }());
	    /**
	     * Entry point for all Angular debug tools. This object corresponds to the `ng`
	     * global variable accessible in the dev console.
	     */
	    var AngularTools = (function () {
	        /**
	         * @param {?} ref
	         */
	        function AngularTools(ref) {
	            this.profiler = new AngularProfiler(ref);
	        }
	        return AngularTools;
	    }());
	    /**
	     * Entry point for all Angular profiling-related debug tools. This object
	     * corresponds to the `ng.profiler` in the dev console.
	     */
	    var AngularProfiler = (function () {
	        /**
	         * @param {?} ref
	         */
	        function AngularProfiler(ref) {
	            this.appRef = ref.injector.get(core.ApplicationRef);
	        }
	        /**
	         * Exercises change detection in a loop and then prints the average amount of
	         * time in milliseconds how long a single round of change detection takes for
	         * the current state of the UI. It runs a minimum of 5 rounds for a minimum
	         * of 500 milliseconds.
	         *
	         * Optionally, a user may pass a `config` parameter containing a map of
	         * options. Supported options are:
	         *
	         * `record` (boolean) - causes the profiler to record a CPU profile while
	         * it exercises the change detector. Example:
	         *
	         * ```
	         * ng.profiler.timeChangeDetection({record: true})
	         * ```
	         * @param {?} config
	         * @return {?}
	         */
	        AngularProfiler.prototype.timeChangeDetection = function (config) {
	            var /** @type {?} */ record = config && config['record'];
	            var /** @type {?} */ profileName = 'Change Detection';
	            // Profiler is not available in Android browsers, nor in IE 9 without dev tools opened
	            var /** @type {?} */ isProfilerAvailable = isPresent(win.console.profile);
	            if (record && isProfilerAvailable) {
	                win.console.profile(profileName);
	            }
	            var /** @type {?} */ start = getDOM().performanceNow();
	            var /** @type {?} */ numTicks = 0;
	            while (numTicks < 5 || (getDOM().performanceNow() - start) < 500) {
	                this.appRef.tick();
	                numTicks++;
	            }
	            var /** @type {?} */ end = getDOM().performanceNow();
	            if (record && isProfilerAvailable) {
	                // need to cast to <any> because type checker thinks there's no argument
	                // while in fact there is:
	                //
	                // https://developer.mozilla.org/en-US/docs/Web/API/Console/profileEnd
	                ((win.console.profileEnd))(profileName);
	            }
	            var /** @type {?} */ msPerTick = (end - start) / numTicks;
	            win.console.log("ran " + numTicks + " change detection cycles");
	            win.console.log(msPerTick.toFixed(2) + " ms per check");
	            return new ChangeDetectionPerfRecord(msPerTick, numTicks);
	        };
	        return AngularProfiler;
	    }());

	    var /** @type {?} */ context = (global$1);
	    /**
	     * Enabled Angular 2 debug tools that are accessible via your browser's
	     * developer console.
	     *
	     * Usage:
	     *
	     * 1. Open developer console (e.g. in Chrome Ctrl + Shift + j)
	     * 1. Type `ng.` (usually the console will show auto-complete suggestion)
	     * 1. Try the change detection profiler `ng.profiler.timeChangeDetection()`
	     *    then hit Enter.
	     *
	     * \@experimental All debugging apis are currently experimental.
	     * @param {?} ref
	     * @return {?}
	     */
	    function enableDebugTools(ref) {
	        ((Object)).assign(context.ng, new AngularTools(ref));
	        return ref;
	    }
	    /**
	     * Disables Angular 2 tools.
	     *
	     * \@experimental All debugging apis are currently experimental.
	     * @return {?}
	     */
	    function disableDebugTools() {
	        if (context.ng) {
	            delete context.ng.profiler;
	        }
	    }

	    /**
	     * Predicates for use with {\@link DebugElement}'s query functions.
	     *
	     * \@experimental All debugging apis are currently experimental.
	     */
	    var By = (function () {
	        function By() {
	        }
	        /**
	         * Match all elements.
	         *
	         * ## Example
	         *
	         * {\@example platform-browser/dom/debug/ts/by/by.ts region='by_all'}
	         * @return {?}
	         */
	        By.all = function () { return function (debugElement) { return true; }; };
	        /**
	         * Match elements by the given CSS selector.
	         *
	         * ## Example
	         *
	         * {\@example platform-browser/dom/debug/ts/by/by.ts region='by_css'}
	         * @param {?} selector
	         * @return {?}
	         */
	        By.css = function (selector) {
	            return function (debugElement) {
	                return isPresent(debugElement.nativeElement) ?
	                    getDOM().elementMatches(debugElement.nativeElement, selector) :
	                    false;
	            };
	        };
	        /**
	         * Match elements that have the given directive present.
	         *
	         * ## Example
	         *
	         * {\@example platform-browser/dom/debug/ts/by/by.ts region='by_directive'}
	         * @param {?} type
	         * @return {?}
	         */
	        By.directive = function (type) {
	            return function (debugElement) { return debugElement.providerTokens.indexOf(type) !== -1; };
	        };
	        return By;
	    }());

	    var /** @type {?} */ __platform_browser_private__ = {
	        BrowserPlatformLocation: BrowserPlatformLocation,
	        DomAdapter: DomAdapter,
	        BrowserDomAdapter: BrowserDomAdapter,
	        BrowserGetTestability: BrowserGetTestability,
	        getDOM: getDOM,
	        setRootDomAdapter: setRootDomAdapter,
	        DomRootRenderer_: DomRootRenderer_,
	        DomRootRenderer: DomRootRenderer,
	        NAMESPACE_URIS: NAMESPACE_URIS,
	        shimContentAttribute: shimContentAttribute,
	        shimHostAttribute: shimHostAttribute,
	        flattenStyles: flattenStyles,
	        splitNamespace: splitNamespace,
	        isNamespaced: isNamespaced,
	        DomSharedStylesHost: DomSharedStylesHost,
	        SharedStylesHost: SharedStylesHost,
	        ELEMENT_PROBE_PROVIDERS: ELEMENT_PROBE_PROVIDERS,
	        DomEventsPlugin: DomEventsPlugin,
	        KeyEventsPlugin: KeyEventsPlugin,
	        HammerGesturesPlugin: HammerGesturesPlugin,
	        initDomAdapter: initDomAdapter,
	        INTERNAL_BROWSER_PLATFORM_PROVIDERS: INTERNAL_BROWSER_PLATFORM_PROVIDERS,
	        BROWSER_SANITIZATION_PROVIDERS: BROWSER_SANITIZATION_PROVIDERS,
	        WebAnimationsDriver: WebAnimationsDriver
	    };

	    /**
	     * @stable
	     */
	    var /** @type {?} */ VERSION = new core.Version('2.4.4');

	    exports.BrowserModule = BrowserModule;
	    exports.platformBrowser = platformBrowser;
	    exports.Title = Title;
	    exports.disableDebugTools = disableDebugTools;
	    exports.enableDebugTools = enableDebugTools;
	    exports.AnimationDriver = AnimationDriver;
	    exports.By = By;
	    exports.NgProbeToken = NgProbeToken;
	    exports.DOCUMENT = DOCUMENT;
	    exports.EVENT_MANAGER_PLUGINS = EVENT_MANAGER_PLUGINS;
	    exports.EventManager = EventManager;
	    exports.HAMMER_GESTURE_CONFIG = HAMMER_GESTURE_CONFIG;
	    exports.HammerGestureConfig = HammerGestureConfig;
	    exports.DomSanitizer = DomSanitizer;
	    exports.VERSION = VERSION;
	    exports.__platform_browser_private__ = __platform_browser_private__;

	}));
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/**
	 * @license Angular v2.4.4
	 * (c) 2010-2016 Google, Inc. https://angular.io/
	 * License: MIT
	 */
	(function (global, factory) {
	     true ? factory(exports, __webpack_require__(28)) :
	    typeof define === 'function' && define.amd ? define(['exports', '@angular/core'], factory) :
	    (factory((global.ng = global.ng || {}, global.ng.common = global.ng.common || {}),global.ng.core));
	}(this, function (exports,_angular_core) { 'use strict';

	    /**
	     * This class should not be used directly by an application developer. Instead, use
	     * {\@link Location}.
	     *
	     * `PlatformLocation` encapsulates all calls to DOM apis, which allows the Router to be platform
	     * agnostic.
	     * This means that we can have different implementation of `PlatformLocation` for the different
	     * platforms
	     * that angular supports. For example, the default `PlatformLocation` is {\@link
	     * BrowserPlatformLocation},
	     * however when you run your app in a WebWorker you use {\@link WebWorkerPlatformLocation}.
	     *
	     * The `PlatformLocation` class is used directly by all implementations of {\@link LocationStrategy}
	     * when
	     * they need to interact with the DOM apis like pushState, popState, etc...
	     *
	     * {\@link LocationStrategy} in turn is used by the {\@link Location} service which is used directly
	     * by
	     * the {\@link Router} in order to navigate between routes. Since all interactions between {\@link
	     * Router} /
	     * {\@link Location} / {\@link LocationStrategy} and DOM apis flow through the `PlatformLocation`
	     * class
	     * they are all platform independent.
	     *
	     * \@stable
	     * @abstract
	     */
	    var PlatformLocation = (function () {
	        function PlatformLocation() {
	        }
	        /**
	         * @abstract
	         * @return {?}
	         */
	        PlatformLocation.prototype.getBaseHrefFromDOM = function () { };
	        /**
	         * @abstract
	         * @param {?} fn
	         * @return {?}
	         */
	        PlatformLocation.prototype.onPopState = function (fn) { };
	        /**
	         * @abstract
	         * @param {?} fn
	         * @return {?}
	         */
	        PlatformLocation.prototype.onHashChange = function (fn) { };
	        Object.defineProperty(PlatformLocation.prototype, "pathname", {
	            /**
	             * @return {?}
	             */
	            get: function () { return null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(PlatformLocation.prototype, "search", {
	            /**
	             * @return {?}
	             */
	            get: function () { return null; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(PlatformLocation.prototype, "hash", {
	            /**
	             * @return {?}
	             */
	            get: function () { return null; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @abstract
	         * @param {?} state
	         * @param {?} title
	         * @param {?} url
	         * @return {?}
	         */
	        PlatformLocation.prototype.replaceState = function (state, title, url) { };
	        /**
	         * @abstract
	         * @param {?} state
	         * @param {?} title
	         * @param {?} url
	         * @return {?}
	         */
	        PlatformLocation.prototype.pushState = function (state, title, url) { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        PlatformLocation.prototype.forward = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        PlatformLocation.prototype.back = function () { };
	        return PlatformLocation;
	    }());

	    /**
	     * `LocationStrategy` is responsible for representing and reading route state
	     * from the browser's URL. Angular provides two strategies:
	     * {\@link HashLocationStrategy} and {\@link PathLocationStrategy}.
	     *
	     * This is used under the hood of the {\@link Location} service.
	     *
	     * Applications should use the {\@link Router} or {\@link Location} services to
	     * interact with application route state.
	     *
	     * For instance, {\@link HashLocationStrategy} produces URLs like
	     * `http://example.com#/foo`, and {\@link PathLocationStrategy} produces
	     * `http://example.com/foo` as an equivalent URL.
	     *
	     * See these two classes for more.
	     *
	     * \@stable
	     * @abstract
	     */
	    var LocationStrategy = (function () {
	        function LocationStrategy() {
	        }
	        /**
	         * @abstract
	         * @param {?=} includeHash
	         * @return {?}
	         */
	        LocationStrategy.prototype.path = function (includeHash) { };
	        /**
	         * @abstract
	         * @param {?} internal
	         * @return {?}
	         */
	        LocationStrategy.prototype.prepareExternalUrl = function (internal) { };
	        /**
	         * @abstract
	         * @param {?} state
	         * @param {?} title
	         * @param {?} url
	         * @param {?} queryParams
	         * @return {?}
	         */
	        LocationStrategy.prototype.pushState = function (state, title, url, queryParams) { };
	        /**
	         * @abstract
	         * @param {?} state
	         * @param {?} title
	         * @param {?} url
	         * @param {?} queryParams
	         * @return {?}
	         */
	        LocationStrategy.prototype.replaceState = function (state, title, url, queryParams) { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        LocationStrategy.prototype.forward = function () { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        LocationStrategy.prototype.back = function () { };
	        /**
	         * @abstract
	         * @param {?} fn
	         * @return {?}
	         */
	        LocationStrategy.prototype.onPopState = function (fn) { };
	        /**
	         * @abstract
	         * @return {?}
	         */
	        LocationStrategy.prototype.getBaseHref = function () { };
	        return LocationStrategy;
	    }());
	    /**
	     * The `APP_BASE_HREF` token represents the base href to be used with the
	     * {@link PathLocationStrategy}.
	     *
	     * If you're using {@link PathLocationStrategy}, you must provide a provider to a string
	     * representing the URL prefix that should be preserved when generating and recognizing
	     * URLs.
	     *
	     * ### Example
	     *
	     * ```typescript
	     * import {Component, NgModule} from '@angular/core';
	     * import {APP_BASE_HREF} from '@angular/common';
	     *
	     * @NgModule({
	     *   providers: [{provide: APP_BASE_HREF, useValue: '/my/app'}]
	     * })
	     * class AppModule {}
	     * ```
	     *
	     * @stable
	     */
	    var /** @type {?} */ APP_BASE_HREF = new _angular_core.OpaqueToken('appBaseHref');

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var /** @type {?} */ globalScope;
	    if (typeof window === 'undefined') {
	        if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
	            // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
	            globalScope = (self);
	        }
	        else {
	            globalScope = (global);
	        }
	    }
	    else {
	        globalScope = (window);
	    }
	    // Need to declare a new variable for global here since TypeScript
	    // exports the original value of the symbol.
	    var /** @type {?} */ _global = globalScope;
	    /**
	     * @param {?} type
	     * @return {?}
	     */
	    function getTypeNameForDebugging(type) {
	        return type['name'] || typeof type;
	    }
	    // TODO: remove calls to assert in production environment
	    // Note: Can't just export this and import in in other files
	    // as `assert` is a reserved keyword in Dart
	    _global.assert = function assert(condition) {
	        // TODO: to be fixed properly via #2830, noop for now
	    };
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isPresent(obj) {
	        return obj != null;
	    }
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isBlank(obj) {
	        return obj == null;
	    }
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isDate(obj) {
	        return obj instanceof Date && !isNaN(obj.valueOf());
	    }
	    /**
	     * @param {?} token
	     * @return {?}
	     */
	    function stringify(token) {
	        if (typeof token === 'string') {
	            return token;
	        }
	        if (token == null) {
	            return '' + token;
	        }
	        if (token.overriddenName) {
	            return "" + token.overriddenName;
	        }
	        if (token.name) {
	            return "" + token.name;
	        }
	        var /** @type {?} */ res = token.toString();
	        var /** @type {?} */ newLineIndex = res.indexOf('\n');
	        return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
	    }
	    var NumberWrapper = (function () {
	        function NumberWrapper() {
	        }
	        /**
	         * @param {?} text
	         * @return {?}
	         */
	        NumberWrapper.parseIntAutoRadix = function (text) {
	            var /** @type {?} */ result = parseInt(text);
	            if (isNaN(result)) {
	                throw new Error('Invalid integer literal when parsing ' + text);
	            }
	            return result;
	        };
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        NumberWrapper.isNumeric = function (value) { return !isNaN(value - parseFloat(value)); };
	        return NumberWrapper;
	    }());
	    /**
	     * @param {?} o
	     * @return {?}
	     */
	    function isJsObject(o) {
	        return o !== null && (typeof o === 'function' || typeof o === 'object');
	    }
	    var /** @type {?} */ _symbolIterator = null;
	    /**
	     * @return {?}
	     */
	    function getSymbolIterator() {
	        if (!_symbolIterator) {
	            if (((globalScope)).Symbol && Symbol.iterator) {
	                _symbolIterator = Symbol.iterator;
	            }
	            else {
	                // es6-shim specific logic
	                var /** @type {?} */ keys = Object.getOwnPropertyNames(Map.prototype);
	                for (var /** @type {?} */ i = 0; i < keys.length; ++i) {
	                    var /** @type {?} */ key = keys[i];
	                    if (key !== 'entries' && key !== 'size' &&
	                        ((Map)).prototype[key] === Map.prototype['entries']) {
	                        _symbolIterator = key;
	                    }
	                }
	            }
	        }
	        return _symbolIterator;
	    }

	    /**
	     * \@whatItDoes `Location` is a service that applications can use to interact with a browser's URL.
	     * \@description
	     * Depending on which {\@link LocationStrategy} is used, `Location` will either persist
	     * to the URL's path or the URL's hash segment.
	     *
	     * Note: it's better to use {\@link Router#navigate} service to trigger route changes. Use
	     * `Location` only if you need to interact with or create normalized URLs outside of
	     * routing.
	     *
	     * `Location` is responsible for normalizing the URL against the application's base href.
	     * A normalized URL is absolute from the URL host, includes the application's base href, and has no
	     * trailing slash:
	     * - `/my/app/user/123` is normalized
	     * - `my/app/user/123` **is not** normalized
	     * - `/my/app/user/123/` **is not** normalized
	     *
	     * ### Example
	     * {\@example common/location/ts/path_location_component.ts region='LocationComponent'}
	     * \@stable
	     */
	    var Location = (function () {
	        /**
	         * @param {?} platformStrategy
	         */
	        function Location(platformStrategy) {
	            var _this = this;
	            /** @internal */
	            this._subject = new _angular_core.EventEmitter();
	            this._platformStrategy = platformStrategy;
	            var browserBaseHref = this._platformStrategy.getBaseHref();
	            this._baseHref = Location.stripTrailingSlash(_stripIndexHtml(browserBaseHref));
	            this._platformStrategy.onPopState(function (ev) {
	                _this._subject.emit({
	                    'url': _this.path(true),
	                    'pop': true,
	                    'type': ev.type,
	                });
	            });
	        }
	        /**
	         * @param {?=} includeHash
	         * @return {?}
	         */
	        Location.prototype.path = function (includeHash) {
	            if (includeHash === void 0) { includeHash = false; }
	            return this.normalize(this._platformStrategy.path(includeHash));
	        };
	        /**
	         * Normalizes the given path and compares to the current normalized path.
	         * @param {?} path
	         * @param {?=} query
	         * @return {?}
	         */
	        Location.prototype.isCurrentPathEqualTo = function (path, query) {
	            if (query === void 0) { query = ''; }
	            return this.path() == this.normalize(path + Location.normalizeQueryParams(query));
	        };
	        /**
	         * Given a string representing a URL, returns the normalized URL path without leading or
	         * trailing slashes.
	         * @param {?} url
	         * @return {?}
	         */
	        Location.prototype.normalize = function (url) {
	            return Location.stripTrailingSlash(_stripBaseHref(this._baseHref, _stripIndexHtml(url)));
	        };
	        /**
	         * Given a string representing a URL, returns the platform-specific external URL path.
	         * If the given URL doesn't begin with a leading slash (`'/'`), this method adds one
	         * before normalizing. This method will also add a hash if `HashLocationStrategy` is
	         * used, or the `APP_BASE_HREF` if the `PathLocationStrategy` is in use.
	         * @param {?} url
	         * @return {?}
	         */
	        Location.prototype.prepareExternalUrl = function (url) {
	            if (url && url[0] !== '/') {
	                url = '/' + url;
	            }
	            return this._platformStrategy.prepareExternalUrl(url);
	        };
	        /**
	         * Changes the browsers URL to the normalized version of the given URL, and pushes a
	         * new item onto the platform's history.
	         * @param {?} path
	         * @param {?=} query
	         * @return {?}
	         */
	        Location.prototype.go = function (path, query) {
	            if (query === void 0) { query = ''; }
	            this._platformStrategy.pushState(null, '', path, query);
	        };
	        /**
	         * Changes the browsers URL to the normalized version of the given URL, and replaces
	         * the top item on the platform's history stack.
	         * @param {?} path
	         * @param {?=} query
	         * @return {?}
	         */
	        Location.prototype.replaceState = function (path, query) {
	            if (query === void 0) { query = ''; }
	            this._platformStrategy.replaceState(null, '', path, query);
	        };
	        /**
	         * Navigates forward in the platform's history.
	         * @return {?}
	         */
	        Location.prototype.forward = function () { this._platformStrategy.forward(); };
	        /**
	         * Navigates back in the platform's history.
	         * @return {?}
	         */
	        Location.prototype.back = function () { this._platformStrategy.back(); };
	        /**
	         * Subscribe to the platform's `popState` events.
	         * @param {?} onNext
	         * @param {?=} onThrow
	         * @param {?=} onReturn
	         * @return {?}
	         */
	        Location.prototype.subscribe = function (onNext, onThrow, onReturn) {
	            if (onThrow === void 0) { onThrow = null; }
	            if (onReturn === void 0) { onReturn = null; }
	            return this._subject.subscribe({ next: onNext, error: onThrow, complete: onReturn });
	        };
	        /**
	         * Given a string of url parameters, prepend with '?' if needed, otherwise return parameters as
	         * is.
	         * @param {?} params
	         * @return {?}
	         */
	        Location.normalizeQueryParams = function (params) {
	            return params && params[0] !== '?' ? '?' + params : params;
	        };
	        /**
	         * Given 2 parts of a url, join them with a slash if needed.
	         * @param {?} start
	         * @param {?} end
	         * @return {?}
	         */
	        Location.joinWithSlash = function (start, end) {
	            if (start.length == 0) {
	                return end;
	            }
	            if (end.length == 0) {
	                return start;
	            }
	            var /** @type {?} */ slashes = 0;
	            if (start.endsWith('/')) {
	                slashes++;
	            }
	            if (end.startsWith('/')) {
	                slashes++;
	            }
	            if (slashes == 2) {
	                return start + end.substring(1);
	            }
	            if (slashes == 1) {
	                return start + end;
	            }
	            return start + '/' + end;
	        };
	        /**
	         * If url has a trailing slash, remove it, otherwise return url as is.
	         * @param {?} url
	         * @return {?}
	         */
	        Location.stripTrailingSlash = function (url) { return url.replace(/\/$/, ''); };
	        Location.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        Location.ctorParameters = function () { return [
	            { type: LocationStrategy, },
	        ]; };
	        return Location;
	    }());
	    /**
	     * @param {?} baseHref
	     * @param {?} url
	     * @return {?}
	     */
	    function _stripBaseHref(baseHref, url) {
	        return baseHref && url.startsWith(baseHref) ? url.substring(baseHref.length) : url;
	    }
	    /**
	     * @param {?} url
	     * @return {?}
	     */
	    function _stripIndexHtml(url) {
	        return url.replace(/\/index.html$/, '');
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * \@whatItDoes Use URL hash for storing application location data.
	     * \@description
	     * `HashLocationStrategy` is a {\@link LocationStrategy} used to configure the
	     * {\@link Location} service to represent its state in the
	     * [hash fragment](https://en.wikipedia.org/wiki/Uniform_Resource_Locator#Syntax)
	     * of the browser's URL.
	     *
	     * For instance, if you call `location.go('/foo')`, the browser's URL will become
	     * `example.com#/foo`.
	     *
	     * ### Example
	     *
	     * {\@example common/location/ts/hash_location_component.ts region='LocationComponent'}
	     *
	     * \@stable
	     */
	    var HashLocationStrategy = (function (_super) {
	        __extends(HashLocationStrategy, _super);
	        /**
	         * @param {?} _platformLocation
	         * @param {?=} _baseHref
	         */
	        function HashLocationStrategy(_platformLocation, _baseHref) {
	            _super.call(this);
	            this._platformLocation = _platformLocation;
	            this._baseHref = '';
	            if (isPresent(_baseHref)) {
	                this._baseHref = _baseHref;
	            }
	        }
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        HashLocationStrategy.prototype.onPopState = function (fn) {
	            this._platformLocation.onPopState(fn);
	            this._platformLocation.onHashChange(fn);
	        };
	        /**
	         * @return {?}
	         */
	        HashLocationStrategy.prototype.getBaseHref = function () { return this._baseHref; };
	        /**
	         * @param {?=} includeHash
	         * @return {?}
	         */
	        HashLocationStrategy.prototype.path = function (includeHash) {
	            if (includeHash === void 0) { includeHash = false; }
	            // the hash value is always prefixed with a `#`
	            // and if it is empty then it will stay empty
	            var /** @type {?} */ path = this._platformLocation.hash;
	            if (!isPresent(path))
	                path = '#';
	            return path.length > 0 ? path.substring(1) : path;
	        };
	        /**
	         * @param {?} internal
	         * @return {?}
	         */
	        HashLocationStrategy.prototype.prepareExternalUrl = function (internal) {
	            var /** @type {?} */ url = Location.joinWithSlash(this._baseHref, internal);
	            return url.length > 0 ? ('#' + url) : url;
	        };
	        /**
	         * @param {?} state
	         * @param {?} title
	         * @param {?} path
	         * @param {?} queryParams
	         * @return {?}
	         */
	        HashLocationStrategy.prototype.pushState = function (state, title, path, queryParams) {
	            var /** @type {?} */ url = this.prepareExternalUrl(path + Location.normalizeQueryParams(queryParams));
	            if (url.length == 0) {
	                url = this._platformLocation.pathname;
	            }
	            this._platformLocation.pushState(state, title, url);
	        };
	        /**
	         * @param {?} state
	         * @param {?} title
	         * @param {?} path
	         * @param {?} queryParams
	         * @return {?}
	         */
	        HashLocationStrategy.prototype.replaceState = function (state, title, path, queryParams) {
	            var /** @type {?} */ url = this.prepareExternalUrl(path + Location.normalizeQueryParams(queryParams));
	            if (url.length == 0) {
	                url = this._platformLocation.pathname;
	            }
	            this._platformLocation.replaceState(state, title, url);
	        };
	        /**
	         * @return {?}
	         */
	        HashLocationStrategy.prototype.forward = function () { this._platformLocation.forward(); };
	        /**
	         * @return {?}
	         */
	        HashLocationStrategy.prototype.back = function () { this._platformLocation.back(); };
	        HashLocationStrategy.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        HashLocationStrategy.ctorParameters = function () { return [
	            { type: PlatformLocation, },
	            { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [APP_BASE_HREF,] },] },
	        ]; };
	        return HashLocationStrategy;
	    }(LocationStrategy));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$1 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * \@whatItDoes Use URL for storing application location data.
	     * \@description
	     * `PathLocationStrategy` is a {\@link LocationStrategy} used to configure the
	     * {\@link Location} service to represent its state in the
	     * [path](https://en.wikipedia.org/wiki/Uniform_Resource_Locator#Syntax) of the
	     * browser's URL.
	     *
	     * If you're using `PathLocationStrategy`, you must provide a {\@link APP_BASE_HREF}
	     * or add a base element to the document. This URL prefix that will be preserved
	     * when generating and recognizing URLs.
	     *
	     * For instance, if you provide an `APP_BASE_HREF` of `'/my/app'` and call
	     * `location.go('/foo')`, the browser's URL will become
	     * `example.com/my/app/foo`.
	     *
	     * Similarly, if you add `<base href='/my/app'/>` to the document and call
	     * `location.go('/foo')`, the browser's URL will become
	     * `example.com/my/app/foo`.
	     *
	     * ### Example
	     *
	     * {\@example common/location/ts/path_location_component.ts region='LocationComponent'}
	     *
	     * \@stable
	     */
	    var PathLocationStrategy = (function (_super) {
	        __extends$1(PathLocationStrategy, _super);
	        /**
	         * @param {?} _platformLocation
	         * @param {?=} href
	         */
	        function PathLocationStrategy(_platformLocation, href) {
	            _super.call(this);
	            this._platformLocation = _platformLocation;
	            if (isBlank(href)) {
	                href = this._platformLocation.getBaseHrefFromDOM();
	            }
	            if (isBlank(href)) {
	                throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");
	            }
	            this._baseHref = href;
	        }
	        /**
	         * @param {?} fn
	         * @return {?}
	         */
	        PathLocationStrategy.prototype.onPopState = function (fn) {
	            this._platformLocation.onPopState(fn);
	            this._platformLocation.onHashChange(fn);
	        };
	        /**
	         * @return {?}
	         */
	        PathLocationStrategy.prototype.getBaseHref = function () { return this._baseHref; };
	        /**
	         * @param {?} internal
	         * @return {?}
	         */
	        PathLocationStrategy.prototype.prepareExternalUrl = function (internal) {
	            return Location.joinWithSlash(this._baseHref, internal);
	        };
	        /**
	         * @param {?=} includeHash
	         * @return {?}
	         */
	        PathLocationStrategy.prototype.path = function (includeHash) {
	            if (includeHash === void 0) { includeHash = false; }
	            var /** @type {?} */ pathname = this._platformLocation.pathname +
	                Location.normalizeQueryParams(this._platformLocation.search);
	            var /** @type {?} */ hash = this._platformLocation.hash;
	            return hash && includeHash ? "" + pathname + hash : pathname;
	        };
	        /**
	         * @param {?} state
	         * @param {?} title
	         * @param {?} url
	         * @param {?} queryParams
	         * @return {?}
	         */
	        PathLocationStrategy.prototype.pushState = function (state, title, url, queryParams) {
	            var /** @type {?} */ externalUrl = this.prepareExternalUrl(url + Location.normalizeQueryParams(queryParams));
	            this._platformLocation.pushState(state, title, externalUrl);
	        };
	        /**
	         * @param {?} state
	         * @param {?} title
	         * @param {?} url
	         * @param {?} queryParams
	         * @return {?}
	         */
	        PathLocationStrategy.prototype.replaceState = function (state, title, url, queryParams) {
	            var /** @type {?} */ externalUrl = this.prepareExternalUrl(url + Location.normalizeQueryParams(queryParams));
	            this._platformLocation.replaceState(state, title, externalUrl);
	        };
	        /**
	         * @return {?}
	         */
	        PathLocationStrategy.prototype.forward = function () { this._platformLocation.forward(); };
	        /**
	         * @return {?}
	         */
	        PathLocationStrategy.prototype.back = function () { this._platformLocation.back(); };
	        PathLocationStrategy.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        PathLocationStrategy.ctorParameters = function () { return [
	            { type: PlatformLocation, },
	            { type: undefined, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Inject, args: [APP_BASE_HREF,] },] },
	        ]; };
	        return PathLocationStrategy;
	    }(LocationStrategy));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$2 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * \@experimental
	     * @abstract
	     */
	    var NgLocalization = (function () {
	        function NgLocalization() {
	        }
	        /**
	         * @abstract
	         * @param {?} value
	         * @return {?}
	         */
	        NgLocalization.prototype.getPluralCategory = function (value) { };
	        return NgLocalization;
	    }());
	    /**
	     * Returns the plural category for a given value.
	     * - "=value" when the case exists,
	     * - the plural category otherwise
	     *
	     * \@internal
	     * @param {?} value
	     * @param {?} cases
	     * @param {?} ngLocalization
	     * @return {?}
	     */
	    function getPluralCategory(value, cases, ngLocalization) {
	        var /** @type {?} */ key = "=" + value;
	        if (cases.indexOf(key) > -1) {
	            return key;
	        }
	        key = ngLocalization.getPluralCategory(value);
	        if (cases.indexOf(key) > -1) {
	            return key;
	        }
	        if (cases.indexOf('other') > -1) {
	            return 'other';
	        }
	        throw new Error("No plural message found for value \"" + value + "\"");
	    }
	    /**
	     * Returns the plural case based on the locale
	     *
	     * \@experimental
	     */
	    var NgLocaleLocalization = (function (_super) {
	        __extends$2(NgLocaleLocalization, _super);
	        /**
	         * @param {?} _locale
	         */
	        function NgLocaleLocalization(_locale) {
	            _super.call(this);
	            this._locale = _locale;
	        }
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        NgLocaleLocalization.prototype.getPluralCategory = function (value) {
	            var /** @type {?} */ plural = getPluralCase(this._locale, value);
	            switch (plural) {
	                case Plural.Zero:
	                    return 'zero';
	                case Plural.One:
	                    return 'one';
	                case Plural.Two:
	                    return 'two';
	                case Plural.Few:
	                    return 'few';
	                case Plural.Many:
	                    return 'many';
	                default:
	                    return 'other';
	            }
	        };
	        NgLocaleLocalization.decorators = [
	            { type: _angular_core.Injectable },
	        ];
	        /** @nocollapse */
	        NgLocaleLocalization.ctorParameters = function () { return [
	            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
	        ]; };
	        return NgLocaleLocalization;
	    }(NgLocalization));
	    var Plural = {};
	    Plural.Zero = 0;
	    Plural.One = 1;
	    Plural.Two = 2;
	    Plural.Few = 3;
	    Plural.Many = 4;
	    Plural.Other = 5;
	    Plural[Plural.Zero] = "Zero";
	    Plural[Plural.One] = "One";
	    Plural[Plural.Two] = "Two";
	    Plural[Plural.Few] = "Few";
	    Plural[Plural.Many] = "Many";
	    Plural[Plural.Other] = "Other";
	    /**
	     * Returns the plural case based on the locale
	     *
	     * \@experimental
	     * @param {?} locale
	     * @param {?} nLike
	     * @return {?}
	     */
	    function getPluralCase(locale, nLike) {
	        // TODO(vicb): lazy compute
	        if (typeof nLike === 'string') {
	            nLike = parseInt(/** @type {?} */ (nLike), 10);
	        }
	        var /** @type {?} */ n = (nLike);
	        var /** @type {?} */ nDecimal = n.toString().replace(/^[^.]*\.?/, '');
	        var /** @type {?} */ i = Math.floor(Math.abs(n));
	        var /** @type {?} */ v = nDecimal.length;
	        var /** @type {?} */ f = parseInt(nDecimal, 10);
	        var /** @type {?} */ t = parseInt(n.toString().replace(/^[^.]*\.?|0+$/g, ''), 10) || 0;
	        var /** @type {?} */ lang = locale.split('-')[0].toLowerCase();
	        switch (lang) {
	            case 'af':
	            case 'asa':
	            case 'az':
	            case 'bem':
	            case 'bez':
	            case 'bg':
	            case 'brx':
	            case 'ce':
	            case 'cgg':
	            case 'chr':
	            case 'ckb':
	            case 'ee':
	            case 'el':
	            case 'eo':
	            case 'es':
	            case 'eu':
	            case 'fo':
	            case 'fur':
	            case 'gsw':
	            case 'ha':
	            case 'haw':
	            case 'hu':
	            case 'jgo':
	            case 'jmc':
	            case 'ka':
	            case 'kk':
	            case 'kkj':
	            case 'kl':
	            case 'ks':
	            case 'ksb':
	            case 'ky':
	            case 'lb':
	            case 'lg':
	            case 'mas':
	            case 'mgo':
	            case 'ml':
	            case 'mn':
	            case 'nb':
	            case 'nd':
	            case 'ne':
	            case 'nn':
	            case 'nnh':
	            case 'nyn':
	            case 'om':
	            case 'or':
	            case 'os':
	            case 'ps':
	            case 'rm':
	            case 'rof':
	            case 'rwk':
	            case 'saq':
	            case 'seh':
	            case 'sn':
	            case 'so':
	            case 'sq':
	            case 'ta':
	            case 'te':
	            case 'teo':
	            case 'tk':
	            case 'tr':
	            case 'ug':
	            case 'uz':
	            case 'vo':
	            case 'vun':
	            case 'wae':
	            case 'xog':
	                if (n === 1)
	                    return Plural.One;
	                return Plural.Other;
	            case 'agq':
	            case 'bas':
	            case 'cu':
	            case 'dav':
	            case 'dje':
	            case 'dua':
	            case 'dyo':
	            case 'ebu':
	            case 'ewo':
	            case 'guz':
	            case 'kam':
	            case 'khq':
	            case 'ki':
	            case 'kln':
	            case 'kok':
	            case 'ksf':
	            case 'lrc':
	            case 'lu':
	            case 'luo':
	            case 'luy':
	            case 'mer':
	            case 'mfe':
	            case 'mgh':
	            case 'mua':
	            case 'mzn':
	            case 'nmg':
	            case 'nus':
	            case 'qu':
	            case 'rn':
	            case 'rw':
	            case 'sbp':
	            case 'twq':
	            case 'vai':
	            case 'yav':
	            case 'yue':
	            case 'zgh':
	            case 'ak':
	            case 'ln':
	            case 'mg':
	            case 'pa':
	            case 'ti':
	                if (n === Math.floor(n) && n >= 0 && n <= 1)
	                    return Plural.One;
	                return Plural.Other;
	            case 'am':
	            case 'as':
	            case 'bn':
	            case 'fa':
	            case 'gu':
	            case 'hi':
	            case 'kn':
	            case 'mr':
	            case 'zu':
	                if (i === 0 || n === 1)
	                    return Plural.One;
	                return Plural.Other;
	            case 'ar':
	                if (n === 0)
	                    return Plural.Zero;
	                if (n === 1)
	                    return Plural.One;
	                if (n === 2)
	                    return Plural.Two;
	                if (n % 100 === Math.floor(n % 100) && n % 100 >= 3 && n % 100 <= 10)
	                    return Plural.Few;
	                if (n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 99)
	                    return Plural.Many;
	                return Plural.Other;
	            case 'ast':
	            case 'ca':
	            case 'de':
	            case 'en':
	            case 'et':
	            case 'fi':
	            case 'fy':
	            case 'gl':
	            case 'it':
	            case 'nl':
	            case 'sv':
	            case 'sw':
	            case 'ur':
	            case 'yi':
	                if (i === 1 && v === 0)
	                    return Plural.One;
	                return Plural.Other;
	            case 'be':
	                if (n % 10 === 1 && !(n % 100 === 11))
	                    return Plural.One;
	                if (n % 10 === Math.floor(n % 10) && n % 10 >= 2 && n % 10 <= 4 &&
	                    !(n % 100 >= 12 && n % 100 <= 14))
	                    return Plural.Few;
	                if (n % 10 === 0 || n % 10 === Math.floor(n % 10) && n % 10 >= 5 && n % 10 <= 9 ||
	                    n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 14)
	                    return Plural.Many;
	                return Plural.Other;
	            case 'br':
	                if (n % 10 === 1 && !(n % 100 === 11 || n % 100 === 71 || n % 100 === 91))
	                    return Plural.One;
	                if (n % 10 === 2 && !(n % 100 === 12 || n % 100 === 72 || n % 100 === 92))
	                    return Plural.Two;
	                if (n % 10 === Math.floor(n % 10) && (n % 10 >= 3 && n % 10 <= 4 || n % 10 === 9) &&
	                    !(n % 100 >= 10 && n % 100 <= 19 || n % 100 >= 70 && n % 100 <= 79 ||
	                        n % 100 >= 90 && n % 100 <= 99))
	                    return Plural.Few;
	                if (!(n === 0) && n % 1e6 === 0)
	                    return Plural.Many;
	                return Plural.Other;
	            case 'bs':
	            case 'hr':
	            case 'sr':
	                if (v === 0 && i % 10 === 1 && !(i % 100 === 11) || f % 10 === 1 && !(f % 100 === 11))
	                    return Plural.One;
	                if (v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 2 && i % 10 <= 4 &&
	                    !(i % 100 >= 12 && i % 100 <= 14) ||
	                    f % 10 === Math.floor(f % 10) && f % 10 >= 2 && f % 10 <= 4 &&
	                        !(f % 100 >= 12 && f % 100 <= 14))
	                    return Plural.Few;
	                return Plural.Other;
	            case 'cs':
	            case 'sk':
	                if (i === 1 && v === 0)
	                    return Plural.One;
	                if (i === Math.floor(i) && i >= 2 && i <= 4 && v === 0)
	                    return Plural.Few;
	                if (!(v === 0))
	                    return Plural.Many;
	                return Plural.Other;
	            case 'cy':
	                if (n === 0)
	                    return Plural.Zero;
	                if (n === 1)
	                    return Plural.One;
	                if (n === 2)
	                    return Plural.Two;
	                if (n === 3)
	                    return Plural.Few;
	                if (n === 6)
	                    return Plural.Many;
	                return Plural.Other;
	            case 'da':
	                if (n === 1 || !(t === 0) && (i === 0 || i === 1))
	                    return Plural.One;
	                return Plural.Other;
	            case 'dsb':
	            case 'hsb':
	                if (v === 0 && i % 100 === 1 || f % 100 === 1)
	                    return Plural.One;
	                if (v === 0 && i % 100 === 2 || f % 100 === 2)
	                    return Plural.Two;
	                if (v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 3 && i % 100 <= 4 ||
	                    f % 100 === Math.floor(f % 100) && f % 100 >= 3 && f % 100 <= 4)
	                    return Plural.Few;
	                return Plural.Other;
	            case 'ff':
	            case 'fr':
	            case 'hy':
	            case 'kab':
	                if (i === 0 || i === 1)
	                    return Plural.One;
	                return Plural.Other;
	            case 'fil':
	                if (v === 0 && (i === 1 || i === 2 || i === 3) ||
	                    v === 0 && !(i % 10 === 4 || i % 10 === 6 || i % 10 === 9) ||
	                    !(v === 0) && !(f % 10 === 4 || f % 10 === 6 || f % 10 === 9))
	                    return Plural.One;
	                return Plural.Other;
	            case 'ga':
	                if (n === 1)
	                    return Plural.One;
	                if (n === 2)
	                    return Plural.Two;
	                if (n === Math.floor(n) && n >= 3 && n <= 6)
	                    return Plural.Few;
	                if (n === Math.floor(n) && n >= 7 && n <= 10)
	                    return Plural.Many;
	                return Plural.Other;
	            case 'gd':
	                if (n === 1 || n === 11)
	                    return Plural.One;
	                if (n === 2 || n === 12)
	                    return Plural.Two;
	                if (n === Math.floor(n) && (n >= 3 && n <= 10 || n >= 13 && n <= 19))
	                    return Plural.Few;
	                return Plural.Other;
	            case 'gv':
	                if (v === 0 && i % 10 === 1)
	                    return Plural.One;
	                if (v === 0 && i % 10 === 2)
	                    return Plural.Two;
	                if (v === 0 &&
	                    (i % 100 === 0 || i % 100 === 20 || i % 100 === 40 || i % 100 === 60 || i % 100 === 80))
	                    return Plural.Few;
	                if (!(v === 0))
	                    return Plural.Many;
	                return Plural.Other;
	            case 'he':
	                if (i === 1 && v === 0)
	                    return Plural.One;
	                if (i === 2 && v === 0)
	                    return Plural.Two;
	                if (v === 0 && !(n >= 0 && n <= 10) && n % 10 === 0)
	                    return Plural.Many;
	                return Plural.Other;
	            case 'is':
	                if (t === 0 && i % 10 === 1 && !(i % 100 === 11) || !(t === 0))
	                    return Plural.One;
	                return Plural.Other;
	            case 'ksh':
	                if (n === 0)
	                    return Plural.Zero;
	                if (n === 1)
	                    return Plural.One;
	                return Plural.Other;
	            case 'kw':
	            case 'naq':
	            case 'se':
	            case 'smn':
	                if (n === 1)
	                    return Plural.One;
	                if (n === 2)
	                    return Plural.Two;
	                return Plural.Other;
	            case 'lag':
	                if (n === 0)
	                    return Plural.Zero;
	                if ((i === 0 || i === 1) && !(n === 0))
	                    return Plural.One;
	                return Plural.Other;
	            case 'lt':
	                if (n % 10 === 1 && !(n % 100 >= 11 && n % 100 <= 19))
	                    return Plural.One;
	                if (n % 10 === Math.floor(n % 10) && n % 10 >= 2 && n % 10 <= 9 &&
	                    !(n % 100 >= 11 && n % 100 <= 19))
	                    return Plural.Few;
	                if (!(f === 0))
	                    return Plural.Many;
	                return Plural.Other;
	            case 'lv':
	            case 'prg':
	                if (n % 10 === 0 || n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 19 ||
	                    v === 2 && f % 100 === Math.floor(f % 100) && f % 100 >= 11 && f % 100 <= 19)
	                    return Plural.Zero;
	                if (n % 10 === 1 && !(n % 100 === 11) || v === 2 && f % 10 === 1 && !(f % 100 === 11) ||
	                    !(v === 2) && f % 10 === 1)
	                    return Plural.One;
	                return Plural.Other;
	            case 'mk':
	                if (v === 0 && i % 10 === 1 || f % 10 === 1)
	                    return Plural.One;
	                return Plural.Other;
	            case 'mt':
	                if (n === 1)
	                    return Plural.One;
	                if (n === 0 || n % 100 === Math.floor(n % 100) && n % 100 >= 2 && n % 100 <= 10)
	                    return Plural.Few;
	                if (n % 100 === Math.floor(n % 100) && n % 100 >= 11 && n % 100 <= 19)
	                    return Plural.Many;
	                return Plural.Other;
	            case 'pl':
	                if (i === 1 && v === 0)
	                    return Plural.One;
	                if (v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 2 && i % 10 <= 4 &&
	                    !(i % 100 >= 12 && i % 100 <= 14))
	                    return Plural.Few;
	                if (v === 0 && !(i === 1) && i % 10 === Math.floor(i % 10) && i % 10 >= 0 && i % 10 <= 1 ||
	                    v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 5 && i % 10 <= 9 ||
	                    v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 12 && i % 100 <= 14)
	                    return Plural.Many;
	                return Plural.Other;
	            case 'pt':
	                if (n === Math.floor(n) && n >= 0 && n <= 2 && !(n === 2))
	                    return Plural.One;
	                return Plural.Other;
	            case 'ro':
	                if (i === 1 && v === 0)
	                    return Plural.One;
	                if (!(v === 0) || n === 0 ||
	                    !(n === 1) && n % 100 === Math.floor(n % 100) && n % 100 >= 1 && n % 100 <= 19)
	                    return Plural.Few;
	                return Plural.Other;
	            case 'ru':
	            case 'uk':
	                if (v === 0 && i % 10 === 1 && !(i % 100 === 11))
	                    return Plural.One;
	                if (v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 2 && i % 10 <= 4 &&
	                    !(i % 100 >= 12 && i % 100 <= 14))
	                    return Plural.Few;
	                if (v === 0 && i % 10 === 0 ||
	                    v === 0 && i % 10 === Math.floor(i % 10) && i % 10 >= 5 && i % 10 <= 9 ||
	                    v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 11 && i % 100 <= 14)
	                    return Plural.Many;
	                return Plural.Other;
	            case 'shi':
	                if (i === 0 || n === 1)
	                    return Plural.One;
	                if (n === Math.floor(n) && n >= 2 && n <= 10)
	                    return Plural.Few;
	                return Plural.Other;
	            case 'si':
	                if (n === 0 || n === 1 || i === 0 && f === 1)
	                    return Plural.One;
	                return Plural.Other;
	            case 'sl':
	                if (v === 0 && i % 100 === 1)
	                    return Plural.One;
	                if (v === 0 && i % 100 === 2)
	                    return Plural.Two;
	                if (v === 0 && i % 100 === Math.floor(i % 100) && i % 100 >= 3 && i % 100 <= 4 || !(v === 0))
	                    return Plural.Few;
	                return Plural.Other;
	            case 'tzm':
	                if (n === Math.floor(n) && n >= 0 && n <= 1 || n === Math.floor(n) && n >= 11 && n <= 99)
	                    return Plural.One;
	                return Plural.Other;
	            default:
	                return Plural.Other;
	        }
	    }

	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isListLikeIterable(obj) {
	        if (!isJsObject(obj))
	            return false;
	        return Array.isArray(obj) ||
	            (!(obj instanceof Map) &&
	                getSymbolIterator() in obj); // JS Iterable have a Symbol.iterator prop
	    }

	    /**
	     * \@ngModule CommonModule
	     *
	     * \@whatItDoes Adds and removes CSS classes on an HTML element.
	     *
	     * \@howToUse
	     * ```
	     *     <some-element [ngClass]="'first second'">...</some-element>
	     *
	     *     <some-element [ngClass]="['first', 'second']">...</some-element>
	     *
	     *     <some-element [ngClass]="{'first': true, 'second': true, 'third': false}">...</some-element>
	     *
	     *     <some-element [ngClass]="stringExp|arrayExp|objExp">...</some-element>
	     *
	     *     <some-element [ngClass]="{'class1 class2 class3' : true}">...</some-element>
	     * ```
	     *
	     * \@description
	     *
	     * The CSS classes are updated as follows, depending on the type of the expression evaluation:
	     * - `string` - the CSS classes listed in the string (space delimited) are added,
	     * - `Array` - the CSS classes declared as Array elements are added,
	     * - `Object` - keys are CSS classes that get added when the expression given in the value
	     *              evaluates to a truthy value, otherwise they are removed.
	     *
	     * \@stable
	     */
	    var NgClass = (function () {
	        /**
	         * @param {?} _iterableDiffers
	         * @param {?} _keyValueDiffers
	         * @param {?} _ngEl
	         * @param {?} _renderer
	         */
	        function NgClass(_iterableDiffers, _keyValueDiffers, _ngEl, _renderer) {
	            this._iterableDiffers = _iterableDiffers;
	            this._keyValueDiffers = _keyValueDiffers;
	            this._ngEl = _ngEl;
	            this._renderer = _renderer;
	            this._initialClasses = [];
	        }
	        Object.defineProperty(NgClass.prototype, "klass", {
	            /**
	             * @param {?} v
	             * @return {?}
	             */
	            set: function (v) {
	                this._applyInitialClasses(true);
	                this._initialClasses = typeof v === 'string' ? v.split(/\s+/) : [];
	                this._applyInitialClasses(false);
	                this._applyClasses(this._rawClass, false);
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgClass.prototype, "ngClass", {
	            /**
	             * @param {?} v
	             * @return {?}
	             */
	            set: function (v) {
	                this._cleanupClasses(this._rawClass);
	                this._iterableDiffer = null;
	                this._keyValueDiffer = null;
	                this._rawClass = typeof v === 'string' ? v.split(/\s+/) : v;
	                if (this._rawClass) {
	                    if (isListLikeIterable(this._rawClass)) {
	                        this._iterableDiffer = this._iterableDiffers.find(this._rawClass).create(null);
	                    }
	                    else {
	                        this._keyValueDiffer = this._keyValueDiffers.find(this._rawClass).create(null);
	                    }
	                }
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        NgClass.prototype.ngDoCheck = function () {
	            if (this._iterableDiffer) {
	                var /** @type {?} */ changes = this._iterableDiffer.diff(this._rawClass);
	                if (changes) {
	                    this._applyIterableChanges(changes);
	                }
	            }
	            else if (this._keyValueDiffer) {
	                var /** @type {?} */ changes = this._keyValueDiffer.diff(this._rawClass);
	                if (changes) {
	                    this._applyKeyValueChanges(changes);
	                }
	            }
	        };
	        /**
	         * @param {?} rawClassVal
	         * @return {?}
	         */
	        NgClass.prototype._cleanupClasses = function (rawClassVal) {
	            this._applyClasses(rawClassVal, true);
	            this._applyInitialClasses(false);
	        };
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        NgClass.prototype._applyKeyValueChanges = function (changes) {
	            var _this = this;
	            changes.forEachAddedItem(function (record) { return _this._toggleClass(record.key, record.currentValue); });
	            changes.forEachChangedItem(function (record) { return _this._toggleClass(record.key, record.currentValue); });
	            changes.forEachRemovedItem(function (record) {
	                if (record.previousValue) {
	                    _this._toggleClass(record.key, false);
	                }
	            });
	        };
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        NgClass.prototype._applyIterableChanges = function (changes) {
	            var _this = this;
	            changes.forEachAddedItem(function (record) {
	                if (typeof record.item === 'string') {
	                    _this._toggleClass(record.item, true);
	                }
	                else {
	                    throw new Error("NgClass can only toggle CSS classes expressed as strings, got " + stringify(record.item));
	                }
	            });
	            changes.forEachRemovedItem(function (record) { return _this._toggleClass(record.item, false); });
	        };
	        /**
	         * @param {?} isCleanup
	         * @return {?}
	         */
	        NgClass.prototype._applyInitialClasses = function (isCleanup) {
	            var _this = this;
	            this._initialClasses.forEach(function (klass) { return _this._toggleClass(klass, !isCleanup); });
	        };
	        /**
	         * @param {?} rawClassVal
	         * @param {?} isCleanup
	         * @return {?}
	         */
	        NgClass.prototype._applyClasses = function (rawClassVal, isCleanup) {
	            var _this = this;
	            if (rawClassVal) {
	                if (Array.isArray(rawClassVal) || rawClassVal instanceof Set) {
	                    ((rawClassVal)).forEach(function (klass) { return _this._toggleClass(klass, !isCleanup); });
	                }
	                else {
	                    Object.keys(rawClassVal).forEach(function (klass) {
	                        if (rawClassVal[klass] != null)
	                            _this._toggleClass(klass, !isCleanup);
	                    });
	                }
	            }
	        };
	        /**
	         * @param {?} klass
	         * @param {?} enabled
	         * @return {?}
	         */
	        NgClass.prototype._toggleClass = function (klass, enabled) {
	            var _this = this;
	            klass = klass.trim();
	            if (klass) {
	                klass.split(/\s+/g).forEach(function (klass) { _this._renderer.setElementClass(_this._ngEl.nativeElement, klass, enabled); });
	            }
	        };
	        NgClass.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngClass]' },] },
	        ];
	        /** @nocollapse */
	        NgClass.ctorParameters = function () { return [
	            { type: _angular_core.IterableDiffers, },
	            { type: _angular_core.KeyValueDiffers, },
	            { type: _angular_core.ElementRef, },
	            { type: _angular_core.Renderer, },
	        ]; };
	        NgClass.propDecorators = {
	            'klass': [{ type: _angular_core.Input, args: ['class',] },],
	            'ngClass': [{ type: _angular_core.Input },],
	        };
	        return NgClass;
	    }());

	    var NgForRow = (function () {
	        /**
	         * @param {?} $implicit
	         * @param {?} index
	         * @param {?} count
	         */
	        function NgForRow($implicit, index, count) {
	            this.$implicit = $implicit;
	            this.index = index;
	            this.count = count;
	        }
	        Object.defineProperty(NgForRow.prototype, "first", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.index === 0; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgForRow.prototype, "last", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.index === this.count - 1; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgForRow.prototype, "even", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this.index % 2 === 0; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgForRow.prototype, "odd", {
	            /**
	             * @return {?}
	             */
	            get: function () { return !this.even; },
	            enumerable: true,
	            configurable: true
	        });
	        return NgForRow;
	    }());
	    /**
	     * The `NgFor` directive instantiates a template once per item from an iterable. The context for
	     * each instantiated template inherits from the outer context with the given loop variable set
	     * to the current item from the iterable.
	     *
	     * ### Local Variables
	     *
	     * `NgFor` provides several exported values that can be aliased to local variables:
	     *
	     * * `index` will be set to the current loop iteration for each template context.
	     * * `first` will be set to a boolean value indicating whether the item is the first one in the
	     *   iteration.
	     * * `last` will be set to a boolean value indicating whether the item is the last one in the
	     *   iteration.
	     * * `even` will be set to a boolean value indicating whether this item has an even index.
	     * * `odd` will be set to a boolean value indicating whether this item has an odd index.
	     *
	     * ### Change Propagation
	     *
	     * When the contents of the iterator changes, `NgFor` makes the corresponding changes to the DOM:
	     *
	     * * When an item is added, a new instance of the template is added to the DOM.
	     * * When an item is removed, its template instance is removed from the DOM.
	     * * When items are reordered, their respective templates are reordered in the DOM.
	     * * Otherwise, the DOM element for that item will remain the same.
	     *
	     * Angular uses object identity to track insertions and deletions within the iterator and reproduce
	     * those changes in the DOM. This has important implications for animations and any stateful
	     * controls
	     * (such as `<input>` elements which accept user input) that are present. Inserted rows can be
	     * animated in, deleted rows can be animated out, and unchanged rows retain any unsaved state such
	     * as user input.
	     *
	     * It is possible for the identities of elements in the iterator to change while the data does not.
	     * This can happen, for example, if the iterator produced from an RPC to the server, and that
	     * RPC is re-run. Even if the data hasn't changed, the second response will produce objects with
	     * different identities, and Angular will tear down the entire DOM and rebuild it (as if all old
	     * elements were deleted and all new elements inserted). This is an expensive operation and should
	     * be avoided if possible.
	     *
	     * To customize the default tracking algorithm, `NgFor` supports `trackBy` option.
	     * `trackBy` takes a function which has two arguments: `index` and `item`.
	     * If `trackBy` is given, Angular tracks changes by the return value of the function.
	     *
	     * ### Syntax
	     *
	     * - `<li *ngFor="let item of items; let i = index; trackBy: trackByFn">...</li>`
	     * - `<li template="ngFor let item of items; let i = index; trackBy: trackByFn">...</li>`
	     *
	     * With `<template>` element:
	     *
	     * ```
	     * <template ngFor let-item [ngForOf]="items" let-i="index" [ngForTrackBy]="trackByFn">
	     *   <li>...</li>
	     * </template>
	     * ```
	     *
	     * ### Example
	     *
	     * See a [live demo](http://plnkr.co/edit/KVuXxDp0qinGDyo307QW?p=preview) for a more detailed
	     * example.
	     *
	     * \@stable
	     */
	    var NgFor = (function () {
	        /**
	         * @param {?} _viewContainer
	         * @param {?} _template
	         * @param {?} _differs
	         * @param {?} _cdr
	         */
	        function NgFor(_viewContainer, _template, _differs, _cdr) {
	            this._viewContainer = _viewContainer;
	            this._template = _template;
	            this._differs = _differs;
	            this._cdr = _cdr;
	            this._differ = null;
	        }
	        Object.defineProperty(NgFor.prototype, "ngForTrackBy", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._trackByFn; },
	            /**
	             * @param {?} fn
	             * @return {?}
	             */
	            set: function (fn) {
	                if (_angular_core.isDevMode() && fn != null && typeof fn !== 'function') {
	                    // TODO(vicb): use a log service once there is a public one available
	                    if ((console) && (console.warn)) {
	                        console.warn(("trackBy must be a function, but received " + JSON.stringify(fn) + ". ") +
	                            "See https://angular.io/docs/ts/latest/api/common/index/NgFor-directive.html#!#change-propagation for more information.");
	                    }
	                }
	                this._trackByFn = fn;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgFor.prototype, "ngForTemplate", {
	            /**
	             * @param {?} value
	             * @return {?}
	             */
	            set: function (value) {
	                if (value) {
	                    this._template = value;
	                }
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        NgFor.prototype.ngOnChanges = function (changes) {
	            if ('ngForOf' in changes) {
	                // React on ngForOf changes only once all inputs have been initialized
	                var /** @type {?} */ value = changes['ngForOf'].currentValue;
	                if (!this._differ && value) {
	                    try {
	                        this._differ = this._differs.find(value).create(this._cdr, this.ngForTrackBy);
	                    }
	                    catch (e) {
	                        throw new Error("Cannot find a differ supporting object '" + value + "' of type '" + getTypeNameForDebugging(value) + "'. NgFor only supports binding to Iterables such as Arrays.");
	                    }
	                }
	            }
	        };
	        /**
	         * @return {?}
	         */
	        NgFor.prototype.ngDoCheck = function () {
	            if (this._differ) {
	                var /** @type {?} */ changes = this._differ.diff(this.ngForOf);
	                if (changes)
	                    this._applyChanges(changes);
	            }
	        };
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        NgFor.prototype._applyChanges = function (changes) {
	            var _this = this;
	            var /** @type {?} */ insertTuples = [];
	            changes.forEachOperation(function (item, adjustedPreviousIndex, currentIndex) {
	                if (item.previousIndex == null) {
	                    var /** @type {?} */ view = _this._viewContainer.createEmbeddedView(_this._template, new NgForRow(null, null, null), currentIndex);
	                    var /** @type {?} */ tuple = new RecordViewTuple(item, view);
	                    insertTuples.push(tuple);
	                }
	                else if (currentIndex == null) {
	                    _this._viewContainer.remove(adjustedPreviousIndex);
	                }
	                else {
	                    var /** @type {?} */ view = _this._viewContainer.get(adjustedPreviousIndex);
	                    _this._viewContainer.move(view, currentIndex);
	                    var /** @type {?} */ tuple = new RecordViewTuple(item, /** @type {?} */ (view));
	                    insertTuples.push(tuple);
	                }
	            });
	            for (var /** @type {?} */ i = 0; i < insertTuples.length; i++) {
	                this._perViewChange(insertTuples[i].view, insertTuples[i].record);
	            }
	            for (var /** @type {?} */ i = 0, /** @type {?} */ ilen = this._viewContainer.length; i < ilen; i++) {
	                var /** @type {?} */ viewRef = (this._viewContainer.get(i));
	                viewRef.context.index = i;
	                viewRef.context.count = ilen;
	            }
	            changes.forEachIdentityChange(function (record) {
	                var /** @type {?} */ viewRef = (_this._viewContainer.get(record.currentIndex));
	                viewRef.context.$implicit = record.item;
	            });
	        };
	        /**
	         * @param {?} view
	         * @param {?} record
	         * @return {?}
	         */
	        NgFor.prototype._perViewChange = function (view, record) {
	            view.context.$implicit = record.item;
	        };
	        NgFor.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngFor][ngForOf]' },] },
	        ];
	        /** @nocollapse */
	        NgFor.ctorParameters = function () { return [
	            { type: _angular_core.ViewContainerRef, },
	            { type: _angular_core.TemplateRef, },
	            { type: _angular_core.IterableDiffers, },
	            { type: _angular_core.ChangeDetectorRef, },
	        ]; };
	        NgFor.propDecorators = {
	            'ngForOf': [{ type: _angular_core.Input },],
	            'ngForTrackBy': [{ type: _angular_core.Input },],
	            'ngForTemplate': [{ type: _angular_core.Input },],
	        };
	        return NgFor;
	    }());
	    var RecordViewTuple = (function () {
	        /**
	         * @param {?} record
	         * @param {?} view
	         */
	        function RecordViewTuple(record, view) {
	            this.record = record;
	            this.view = view;
	        }
	        return RecordViewTuple;
	    }());

	    /**
	     * Removes or recreates a portion of the DOM tree based on an {expression}.
	     *
	     * If the expression assigned to `ngIf` evaluates to a falsy value then the element
	     * is removed from the DOM, otherwise a clone of the element is reinserted into the DOM.
	     *
	     * ### Example ([live demo](http://plnkr.co/edit/fe0kgemFBtmQOY31b4tw?p=preview)):
	     *
	     * ```
	     * <div *ngIf="errorCount > 0" class="error">
	     *   <!-- Error message displayed when the errorCount property in the current context is greater
	     * than 0. -->
	     *   {{errorCount}} errors detected
	     * </div>
	     * ```
	     *
	     * ### Syntax
	     *
	     * - `<div *ngIf="condition">...</div>`
	     * - `<div template="ngIf condition">...</div>`
	     * - `<template [ngIf]="condition"><div>...</div></template>`
	     *
	     * \@stable
	     */
	    var NgIf = (function () {
	        /**
	         * @param {?} _viewContainer
	         * @param {?} _template
	         */
	        function NgIf(_viewContainer, _template) {
	            this._viewContainer = _viewContainer;
	            this._template = _template;
	            this._hasView = false;
	        }
	        Object.defineProperty(NgIf.prototype, "ngIf", {
	            /**
	             * @param {?} condition
	             * @return {?}
	             */
	            set: function (condition) {
	                if (condition && !this._hasView) {
	                    this._hasView = true;
	                    this._viewContainer.createEmbeddedView(this._template);
	                }
	                else if (!condition && this._hasView) {
	                    this._hasView = false;
	                    this._viewContainer.clear();
	                }
	            },
	            enumerable: true,
	            configurable: true
	        });
	        NgIf.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngIf]' },] },
	        ];
	        /** @nocollapse */
	        NgIf.ctorParameters = function () { return [
	            { type: _angular_core.ViewContainerRef, },
	            { type: _angular_core.TemplateRef, },
	        ]; };
	        NgIf.propDecorators = {
	            'ngIf': [{ type: _angular_core.Input },],
	        };
	        return NgIf;
	    }());

	    var SwitchView = (function () {
	        /**
	         * @param {?} _viewContainerRef
	         * @param {?} _templateRef
	         */
	        function SwitchView(_viewContainerRef, _templateRef) {
	            this._viewContainerRef = _viewContainerRef;
	            this._templateRef = _templateRef;
	            this._created = false;
	        }
	        /**
	         * @return {?}
	         */
	        SwitchView.prototype.create = function () {
	            this._created = true;
	            this._viewContainerRef.createEmbeddedView(this._templateRef);
	        };
	        /**
	         * @return {?}
	         */
	        SwitchView.prototype.destroy = function () {
	            this._created = false;
	            this._viewContainerRef.clear();
	        };
	        /**
	         * @param {?} created
	         * @return {?}
	         */
	        SwitchView.prototype.enforceState = function (created) {
	            if (created && !this._created) {
	                this.create();
	            }
	            else if (!created && this._created) {
	                this.destroy();
	            }
	        };
	        return SwitchView;
	    }());
	    /**
	     * \@ngModule CommonModule
	     *
	     * \@whatItDoes Adds / removes DOM sub-trees when the nest match expressions matches the switch
	     *             expression.
	     *
	     * \@howToUse
	     * ```
	     *     <container-element [ngSwitch]="switch_expression">
	     *       <some-element *ngSwitchCase="match_expression_1">...</some-element>
	     *       <some-element *ngSwitchCase="match_expression_2">...</some-element>
	     *       <some-other-element *ngSwitchCase="match_expression_3">...</some-other-element>
	     *       <ng-container *ngSwitchCase="match_expression_3">
	     *         <!-- use a ng-container to group multiple root nodes -->
	     *         <inner-element></inner-element>
	     *         <inner-other-element></inner-other-element>
	     *       </ng-container>
	     *       <some-element *ngSwitchDefault>...</some-element>
	     *     </container-element>
	     * ```
	     * \@description
	     *
	     * `NgSwitch` stamps out nested views when their match expression value matches the value of the
	     * switch expression.
	     *
	     * In other words:
	     * - you define a container element (where you place the directive with a switch expression on the
	     * `[ngSwitch]="..."` attribute)
	     * - you define inner views inside the `NgSwitch` and place a `*ngSwitchCase` attribute on the view
	     * root elements.
	     *
	     * Elements within `NgSwitch` but outside of a `NgSwitchCase` or `NgSwitchDefault` directives will
	     * be preserved at the location.
	     *
	     * The `ngSwitchCase` directive informs the parent `NgSwitch` of which view to display when the
	     * expression is evaluated.
	     * When no matching expression is found on a `ngSwitchCase` view, the `ngSwitchDefault` view is
	     * stamped out.
	     *
	     * \@stable
	     */
	    var NgSwitch = (function () {
	        function NgSwitch() {
	            this._defaultUsed = false;
	            this._caseCount = 0;
	            this._lastCaseCheckIndex = 0;
	            this._lastCasesMatched = false;
	        }
	        Object.defineProperty(NgSwitch.prototype, "ngSwitch", {
	            /**
	             * @param {?} newValue
	             * @return {?}
	             */
	            set: function (newValue) {
	                this._ngSwitch = newValue;
	                if (this._caseCount === 0) {
	                    this._updateDefaultCases(true);
	                }
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * \@internal
	         * @return {?}
	         */
	        NgSwitch.prototype._addCase = function () { return this._caseCount++; };
	        /**
	         * \@internal
	         * @param {?} view
	         * @return {?}
	         */
	        NgSwitch.prototype._addDefault = function (view) {
	            if (!this._defaultViews) {
	                this._defaultViews = [];
	            }
	            this._defaultViews.push(view);
	        };
	        /**
	         * \@internal
	         * @param {?} value
	         * @return {?}
	         */
	        NgSwitch.prototype._matchCase = function (value) {
	            var /** @type {?} */ matched = value == this._ngSwitch;
	            this._lastCasesMatched = this._lastCasesMatched || matched;
	            this._lastCaseCheckIndex++;
	            if (this._lastCaseCheckIndex === this._caseCount) {
	                this._updateDefaultCases(!this._lastCasesMatched);
	                this._lastCaseCheckIndex = 0;
	                this._lastCasesMatched = false;
	            }
	            return matched;
	        };
	        /**
	         * @param {?} useDefault
	         * @return {?}
	         */
	        NgSwitch.prototype._updateDefaultCases = function (useDefault) {
	            if (this._defaultViews && useDefault !== this._defaultUsed) {
	                this._defaultUsed = useDefault;
	                for (var /** @type {?} */ i = 0; i < this._defaultViews.length; i++) {
	                    var /** @type {?} */ defaultView = this._defaultViews[i];
	                    defaultView.enforceState(useDefault);
	                }
	            }
	        };
	        NgSwitch.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngSwitch]' },] },
	        ];
	        /** @nocollapse */
	        NgSwitch.ctorParameters = function () { return []; };
	        NgSwitch.propDecorators = {
	            'ngSwitch': [{ type: _angular_core.Input },],
	        };
	        return NgSwitch;
	    }());
	    /**
	     * \@ngModule CommonModule
	     *
	     * \@whatItDoes Creates a view that will be added/removed from the parent {\@link NgSwitch} when the
	     *             given expression evaluate to respectively the same/different value as the switch
	     *             expression.
	     *
	     * \@howToUse
	     * ```
	     * <container-element [ngSwitch]="switch_expression">
	     *   <some-element *ngSwitchCase="match_expression_1">...</some-element>
	     * </container-element>
	     * ```
	     * \@description
	     *
	     * Insert the sub-tree when the expression evaluates to the same value as the enclosing switch
	     * expression.
	     *
	     * If multiple match expressions match the switch expression value, all of them are displayed.
	     *
	     * See {\@link NgSwitch} for more details and example.
	     *
	     * \@stable
	     */
	    var NgSwitchCase = (function () {
	        /**
	         * @param {?} viewContainer
	         * @param {?} templateRef
	         * @param {?} ngSwitch
	         */
	        function NgSwitchCase(viewContainer, templateRef, ngSwitch) {
	            this.ngSwitch = ngSwitch;
	            ngSwitch._addCase();
	            this._view = new SwitchView(viewContainer, templateRef);
	        }
	        /**
	         * @return {?}
	         */
	        NgSwitchCase.prototype.ngDoCheck = function () { this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase)); };
	        NgSwitchCase.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngSwitchCase]' },] },
	        ];
	        /** @nocollapse */
	        NgSwitchCase.ctorParameters = function () { return [
	            { type: _angular_core.ViewContainerRef, },
	            { type: _angular_core.TemplateRef, },
	            { type: NgSwitch, decorators: [{ type: _angular_core.Host },] },
	        ]; };
	        NgSwitchCase.propDecorators = {
	            'ngSwitchCase': [{ type: _angular_core.Input },],
	        };
	        return NgSwitchCase;
	    }());
	    /**
	     * \@ngModule CommonModule
	     * \@whatItDoes Creates a view that is added to the parent {\@link NgSwitch} when no case expressions
	     * match the
	     *             switch expression.
	     *
	     * \@howToUse
	     * ```
	     * <container-element [ngSwitch]="switch_expression">
	     *   <some-element *ngSwitchCase="match_expression_1">...</some-element>
	     *   <some-other-element *ngSwitchDefault>...</some-other-element>
	     * </container-element>
	     * ```
	     *
	     * \@description
	     *
	     * Insert the sub-tree when no case expressions evaluate to the same value as the enclosing switch
	     * expression.
	     *
	     * See {\@link NgSwitch} for more details and example.
	     *
	     * \@stable
	     */
	    var NgSwitchDefault = (function () {
	        /**
	         * @param {?} viewContainer
	         * @param {?} templateRef
	         * @param {?} ngSwitch
	         */
	        function NgSwitchDefault(viewContainer, templateRef, ngSwitch) {
	            ngSwitch._addDefault(new SwitchView(viewContainer, templateRef));
	        }
	        NgSwitchDefault.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngSwitchDefault]' },] },
	        ];
	        /** @nocollapse */
	        NgSwitchDefault.ctorParameters = function () { return [
	            { type: _angular_core.ViewContainerRef, },
	            { type: _angular_core.TemplateRef, },
	            { type: NgSwitch, decorators: [{ type: _angular_core.Host },] },
	        ]; };
	        return NgSwitchDefault;
	    }());

	    /**
	     * \@ngModule CommonModule
	     *
	     * \@whatItDoes Adds / removes DOM sub-trees based on a numeric value. Tailored for pluralization.
	     *
	     * \@howToUse
	     * ```
	     * <some-element [ngPlural]="value">
	     *   <template ngPluralCase="=0">there is nothing</template>
	     *   <template ngPluralCase="=1">there is one</template>
	     *   <template ngPluralCase="few">there are a few</template>
	     * </some-element>
	     * ```
	     *
	     * \@description
	     *
	     * Displays DOM sub-trees that match the switch expression value, or failing that, DOM sub-trees
	     * that match the switch expression's pluralization category.
	     *
	     * To use this directive you must provide a container element that sets the `[ngPlural]` attribute
	     * to a switch expression. Inner elements with a `[ngPluralCase]` will display based on their
	     * expression:
	     * - if `[ngPluralCase]` is set to a value starting with `=`, it will only display if the value
	     *   matches the switch expression exactly,
	     * - otherwise, the view will be treated as a "category match", and will only display if exact
	     *   value matches aren't found and the value maps to its category for the defined locale.
	     *
	     * See http://cldr.unicode.org/index/cldr-spec/plural-rules
	     *
	     * \@experimental
	     */
	    var NgPlural = (function () {
	        /**
	         * @param {?} _localization
	         */
	        function NgPlural(_localization) {
	            this._localization = _localization;
	            this._caseViews = {};
	        }
	        Object.defineProperty(NgPlural.prototype, "ngPlural", {
	            /**
	             * @param {?} value
	             * @return {?}
	             */
	            set: function (value) {
	                this._switchValue = value;
	                this._updateView();
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} value
	         * @param {?} switchView
	         * @return {?}
	         */
	        NgPlural.prototype.addCase = function (value, switchView) { this._caseViews[value] = switchView; };
	        /**
	         * @return {?}
	         */
	        NgPlural.prototype._updateView = function () {
	            this._clearViews();
	            var /** @type {?} */ cases = Object.keys(this._caseViews);
	            var /** @type {?} */ key = getPluralCategory(this._switchValue, cases, this._localization);
	            this._activateView(this._caseViews[key]);
	        };
	        /**
	         * @return {?}
	         */
	        NgPlural.prototype._clearViews = function () {
	            if (this._activeView)
	                this._activeView.destroy();
	        };
	        /**
	         * @param {?} view
	         * @return {?}
	         */
	        NgPlural.prototype._activateView = function (view) {
	            if (view) {
	                this._activeView = view;
	                this._activeView.create();
	            }
	        };
	        NgPlural.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngPlural]' },] },
	        ];
	        /** @nocollapse */
	        NgPlural.ctorParameters = function () { return [
	            { type: NgLocalization, },
	        ]; };
	        NgPlural.propDecorators = {
	            'ngPlural': [{ type: _angular_core.Input },],
	        };
	        return NgPlural;
	    }());
	    /**
	     * \@ngModule CommonModule
	     *
	     * \@whatItDoes Creates a view that will be added/removed from the parent {\@link NgPlural} when the
	     *             given expression matches the plural expression according to CLDR rules.
	     *
	     * \@howToUse
	     * ```
	     * <some-element [ngPlural]="value">
	     *   <template ngPluralCase="=0">...</template>
	     *   <template ngPluralCase="other">...</template>
	     * </some-element>
	     * ```
	     *
	     * See {\@link NgPlural} for more details and example.
	     *
	     * \@experimental
	     */
	    var NgPluralCase = (function () {
	        /**
	         * @param {?} value
	         * @param {?} template
	         * @param {?} viewContainer
	         * @param {?} ngPlural
	         */
	        function NgPluralCase(value, template, viewContainer, ngPlural) {
	            this.value = value;
	            var isANumber = !isNaN(Number(value));
	            ngPlural.addCase(isANumber ? "=" + value : value, new SwitchView(viewContainer, template));
	        }
	        NgPluralCase.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngPluralCase]' },] },
	        ];
	        /** @nocollapse */
	        NgPluralCase.ctorParameters = function () { return [
	            { type: undefined, decorators: [{ type: _angular_core.Attribute, args: ['ngPluralCase',] },] },
	            { type: _angular_core.TemplateRef, },
	            { type: _angular_core.ViewContainerRef, },
	            { type: NgPlural, decorators: [{ type: _angular_core.Host },] },
	        ]; };
	        return NgPluralCase;
	    }());

	    /**
	     * \@ngModule CommonModule
	     *
	     * \@whatItDoes Update an HTML element styles.
	     *
	     * \@howToUse
	     * ```
	     * <some-element [ngStyle]="{'font-style': styleExp}">...</some-element>
	     *
	     * <some-element [ngStyle]="{'max-width.px': widthExp}">...</some-element>
	     *
	     * <some-element [ngStyle]="objExp">...</some-element>
	     * ```
	     *
	     * \@description
	     *
	     * The styles are updated according to the value of the expression evaluation:
	     * - keys are style names with an optional `.<unit>` suffix (ie 'top.px', 'font-style.em'),
	     * - values are the values assigned to those properties (expressed in the given unit).
	     *
	     * \@stable
	     */
	    var NgStyle = (function () {
	        /**
	         * @param {?} _differs
	         * @param {?} _ngEl
	         * @param {?} _renderer
	         */
	        function NgStyle(_differs, _ngEl, _renderer) {
	            this._differs = _differs;
	            this._ngEl = _ngEl;
	            this._renderer = _renderer;
	        }
	        Object.defineProperty(NgStyle.prototype, "ngStyle", {
	            /**
	             * @param {?} v
	             * @return {?}
	             */
	            set: function (v) {
	                this._ngStyle = v;
	                if (!this._differ && v) {
	                    this._differ = this._differs.find(v).create(null);
	                }
	            },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        NgStyle.prototype.ngDoCheck = function () {
	            if (this._differ) {
	                var /** @type {?} */ changes = this._differ.diff(this._ngStyle);
	                if (changes) {
	                    this._applyChanges(changes);
	                }
	            }
	        };
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        NgStyle.prototype._applyChanges = function (changes) {
	            var _this = this;
	            changes.forEachRemovedItem(function (record) { return _this._setStyle(record.key, null); });
	            changes.forEachAddedItem(function (record) { return _this._setStyle(record.key, record.currentValue); });
	            changes.forEachChangedItem(function (record) { return _this._setStyle(record.key, record.currentValue); });
	        };
	        /**
	         * @param {?} nameAndUnit
	         * @param {?} value
	         * @return {?}
	         */
	        NgStyle.prototype._setStyle = function (nameAndUnit, value) {
	            var _a = nameAndUnit.split('.'), name = _a[0], unit = _a[1];
	            value = value && unit ? "" + value + unit : value;
	            this._renderer.setElementStyle(this._ngEl.nativeElement, name, value);
	        };
	        NgStyle.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngStyle]' },] },
	        ];
	        /** @nocollapse */
	        NgStyle.ctorParameters = function () { return [
	            { type: _angular_core.KeyValueDiffers, },
	            { type: _angular_core.ElementRef, },
	            { type: _angular_core.Renderer, },
	        ]; };
	        NgStyle.propDecorators = {
	            'ngStyle': [{ type: _angular_core.Input },],
	        };
	        return NgStyle;
	    }());

	    /**
	     * \@ngModule CommonModule
	     *
	     * \@whatItDoes Inserts an embedded view from a prepared `TemplateRef`
	     *
	     * \@howToUse
	     * ```
	     * <template [ngTemplateOutlet]="templateRefExpression"
	     *           [ngOutletContext]="objectExpression">
	     * </template>
	     * ```
	     *
	     * \@description
	     *
	     * You can attach a context object to the `EmbeddedViewRef` by setting `[ngOutletContext]`.
	     * `[ngOutletContext]` should be an object, the object's keys will be the local template variables
	     * available within the `TemplateRef`.
	     *
	     * Note: using the key `$implicit` in the context object will set it's value as default.
	     *
	     * \@experimental
	     */
	    var NgTemplateOutlet = (function () {
	        /**
	         * @param {?} _viewContainerRef
	         */
	        function NgTemplateOutlet(_viewContainerRef) {
	            this._viewContainerRef = _viewContainerRef;
	        }
	        Object.defineProperty(NgTemplateOutlet.prototype, "ngOutletContext", {
	            /**
	             * @param {?} context
	             * @return {?}
	             */
	            set: function (context) { this._context = context; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(NgTemplateOutlet.prototype, "ngTemplateOutlet", {
	            /**
	             * @param {?} templateRef
	             * @return {?}
	             */
	            set: function (templateRef) { this._templateRef = templateRef; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        NgTemplateOutlet.prototype.ngOnChanges = function (changes) {
	            if (this._viewRef) {
	                this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._viewRef));
	            }
	            if (this._templateRef) {
	                this._viewRef = this._viewContainerRef.createEmbeddedView(this._templateRef, this._context);
	            }
	        };
	        NgTemplateOutlet.decorators = [
	            { type: _angular_core.Directive, args: [{ selector: '[ngTemplateOutlet]' },] },
	        ];
	        /** @nocollapse */
	        NgTemplateOutlet.ctorParameters = function () { return [
	            { type: _angular_core.ViewContainerRef, },
	        ]; };
	        NgTemplateOutlet.propDecorators = {
	            'ngOutletContext': [{ type: _angular_core.Input },],
	            'ngTemplateOutlet': [{ type: _angular_core.Input },],
	        };
	        return NgTemplateOutlet;
	    }());

	    /**
	     * A collection of Angular directives that are likely to be used in each and every Angular
	     * application.
	     */
	    var /** @type {?} */ COMMON_DIRECTIVES = [
	        NgClass,
	        NgFor,
	        NgIf,
	        NgTemplateOutlet,
	        NgStyle,
	        NgSwitch,
	        NgSwitchCase,
	        NgSwitchDefault,
	        NgPlural,
	        NgPluralCase,
	    ];

	    var /** @type {?} */ isPromise = _angular_core.__core_private__.isPromise;

	    var __extends$4 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    /**
	     * \@stable
	     */
	    var BaseError = (function (_super) {
	        __extends$4(BaseError, _super);
	        /**
	         * @param {?} message
	         */
	        function BaseError(message) {
	            _super.call(this, message);
	            // Errors don't use current this, instead they create a new instance.
	            // We have to do forward all of our api to the nativeInstance.
	            // TODO(bradfordcsmith): Remove this hack when
	            //     google/closure-compiler/issues/2102 is fixed.
	            var nativeError = new Error(message);
	            this._nativeError = nativeError;
	        }
	        Object.defineProperty(BaseError.prototype, "message", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._nativeError.message; },
	            /**
	             * @param {?} message
	             * @return {?}
	             */
	            set: function (message) { this._nativeError.message = message; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(BaseError.prototype, "name", {
	            /**
	             * @return {?}
	             */
	            get: function () { return this._nativeError.name; },
	            enumerable: true,
	            configurable: true
	        });
	        Object.defineProperty(BaseError.prototype, "stack", {
	            /**
	             * @return {?}
	             */
	            get: function () { return ((this._nativeError)).stack; },
	            /**
	             * @param {?} value
	             * @return {?}
	             */
	            set: function (value) { ((this._nativeError)).stack = value; },
	            enumerable: true,
	            configurable: true
	        });
	        /**
	         * @return {?}
	         */
	        BaseError.prototype.toString = function () { return this._nativeError.toString(); };
	        return BaseError;
	    }(Error));
	    /**
	     * \@stable
	     */
	    var WrappedError = (function (_super) {
	        __extends$4(WrappedError, _super);
	        /**
	         * @param {?} message
	         * @param {?} error
	         */
	        function WrappedError(message, error) {
	            _super.call(this, message + " caused by: " + (error instanceof Error ? error.message : error));
	            this.originalError = error;
	        }
	        Object.defineProperty(WrappedError.prototype, "stack", {
	            /**
	             * @return {?}
	             */
	            get: function () {
	                return (((this.originalError instanceof Error ? this.originalError : this._nativeError)))
	                    .stack;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        return WrappedError;
	    }(BaseError));

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var __extends$3 = (this && this.__extends) || function (d, b) {
	        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	    var InvalidPipeArgumentError = (function (_super) {
	        __extends$3(InvalidPipeArgumentError, _super);
	        /**
	         * @param {?} type
	         * @param {?} value
	         */
	        function InvalidPipeArgumentError(type, value) {
	            _super.call(this, "Invalid argument '" + value + "' for pipe '" + stringify(type) + "'");
	        }
	        return InvalidPipeArgumentError;
	    }(BaseError));

	    var ObservableStrategy = (function () {
	        function ObservableStrategy() {
	        }
	        /**
	         * @param {?} async
	         * @param {?} updateLatestValue
	         * @return {?}
	         */
	        ObservableStrategy.prototype.createSubscription = function (async, updateLatestValue) {
	            return async.subscribe({ next: updateLatestValue, error: function (e) { throw e; } });
	        };
	        /**
	         * @param {?} subscription
	         * @return {?}
	         */
	        ObservableStrategy.prototype.dispose = function (subscription) { subscription.unsubscribe(); };
	        /**
	         * @param {?} subscription
	         * @return {?}
	         */
	        ObservableStrategy.prototype.onDestroy = function (subscription) { subscription.unsubscribe(); };
	        return ObservableStrategy;
	    }());
	    var PromiseStrategy = (function () {
	        function PromiseStrategy() {
	        }
	        /**
	         * @param {?} async
	         * @param {?} updateLatestValue
	         * @return {?}
	         */
	        PromiseStrategy.prototype.createSubscription = function (async, updateLatestValue) {
	            return async.then(updateLatestValue, function (e) { throw e; });
	        };
	        /**
	         * @param {?} subscription
	         * @return {?}
	         */
	        PromiseStrategy.prototype.dispose = function (subscription) { };
	        /**
	         * @param {?} subscription
	         * @return {?}
	         */
	        PromiseStrategy.prototype.onDestroy = function (subscription) { };
	        return PromiseStrategy;
	    }());
	    var /** @type {?} */ _promiseStrategy = new PromiseStrategy();
	    var /** @type {?} */ _observableStrategy = new ObservableStrategy();
	    /**
	     * \@ngModule CommonModule
	     * \@whatItDoes Unwraps a value from an asynchronous primitive.
	     * \@howToUse `observable_or_promise_expression | async`
	     * \@description
	     * The `async` pipe subscribes to an `Observable` or `Promise` and returns the latest value it has
	     * emitted. When a new value is emitted, the `async` pipe marks the component to be checked for
	     * changes. When the component gets destroyed, the `async` pipe unsubscribes automatically to avoid
	     * potential memory leaks.
	     *
	     *
	     * ## Examples
	     *
	     * This example binds a `Promise` to the view. Clicking the `Resolve` button resolves the
	     * promise.
	     *
	     * {\@example common/pipes/ts/async_pipe.ts region='AsyncPipePromise'}
	     *
	     * It's also possible to use `async` with Observables. The example below binds the `time` Observable
	     * to the view. The Observable continuously updates the view with the current time.
	     *
	     * {\@example common/pipes/ts/async_pipe.ts region='AsyncPipeObservable'}
	     *
	     * \@stable
	     */
	    var AsyncPipe = (function () {
	        /**
	         * @param {?} _ref
	         */
	        function AsyncPipe(_ref) {
	            this._ref = _ref;
	            this._latestValue = null;
	            this._latestReturnedValue = null;
	            this._subscription = null;
	            this._obj = null;
	            this._strategy = null;
	        }
	        /**
	         * @return {?}
	         */
	        AsyncPipe.prototype.ngOnDestroy = function () {
	            if (this._subscription) {
	                this._dispose();
	            }
	        };
	        /**
	         * @param {?} obj
	         * @return {?}
	         */
	        AsyncPipe.prototype.transform = function (obj) {
	            if (!this._obj) {
	                if (obj) {
	                    this._subscribe(obj);
	                }
	                this._latestReturnedValue = this._latestValue;
	                return this._latestValue;
	            }
	            if (obj !== this._obj) {
	                this._dispose();
	                return this.transform(obj);
	            }
	            if (this._latestValue === this._latestReturnedValue) {
	                return this._latestReturnedValue;
	            }
	            this._latestReturnedValue = this._latestValue;
	            return _angular_core.WrappedValue.wrap(this._latestValue);
	        };
	        /**
	         * @param {?} obj
	         * @return {?}
	         */
	        AsyncPipe.prototype._subscribe = function (obj) {
	            var _this = this;
	            this._obj = obj;
	            this._strategy = this._selectStrategy(obj);
	            this._subscription = this._strategy.createSubscription(obj, function (value) { return _this._updateLatestValue(obj, value); });
	        };
	        /**
	         * @param {?} obj
	         * @return {?}
	         */
	        AsyncPipe.prototype._selectStrategy = function (obj) {
	            if (isPromise(obj)) {
	                return _promiseStrategy;
	            }
	            if (((obj)).subscribe) {
	                return _observableStrategy;
	            }
	            throw new InvalidPipeArgumentError(AsyncPipe, obj);
	        };
	        /**
	         * @return {?}
	         */
	        AsyncPipe.prototype._dispose = function () {
	            this._strategy.dispose(this._subscription);
	            this._latestValue = null;
	            this._latestReturnedValue = null;
	            this._subscription = null;
	            this._obj = null;
	        };
	        /**
	         * @param {?} async
	         * @param {?} value
	         * @return {?}
	         */
	        AsyncPipe.prototype._updateLatestValue = function (async, value) {
	            if (async === this._obj) {
	                this._latestValue = value;
	                this._ref.markForCheck();
	            }
	        };
	        AsyncPipe.decorators = [
	            { type: _angular_core.Pipe, args: [{ name: 'async', pure: false },] },
	        ];
	        /** @nocollapse */
	        AsyncPipe.ctorParameters = function () { return [
	            { type: _angular_core.ChangeDetectorRef, },
	        ]; };
	        return AsyncPipe;
	    }());

	    var NumberFormatStyle = {};
	    NumberFormatStyle.Decimal = 0;
	    NumberFormatStyle.Percent = 1;
	    NumberFormatStyle.Currency = 2;
	    NumberFormatStyle[NumberFormatStyle.Decimal] = "Decimal";
	    NumberFormatStyle[NumberFormatStyle.Percent] = "Percent";
	    NumberFormatStyle[NumberFormatStyle.Currency] = "Currency";
	    var NumberFormatter = (function () {
	        function NumberFormatter() {
	        }
	        /**
	         * @param {?} num
	         * @param {?} locale
	         * @param {?} style
	         * @param {?=} __3
	         * @return {?}
	         */
	        NumberFormatter.format = function (num, locale, style, _a) {
	            var _b = _a === void 0 ? {} : _a, minimumIntegerDigits = _b.minimumIntegerDigits, minimumFractionDigits = _b.minimumFractionDigits, maximumFractionDigits = _b.maximumFractionDigits, currency = _b.currency, _c = _b.currencyAsSymbol, currencyAsSymbol = _c === void 0 ? false : _c;
	            var /** @type {?} */ options = {
	                minimumIntegerDigits: minimumIntegerDigits,
	                minimumFractionDigits: minimumFractionDigits,
	                maximumFractionDigits: maximumFractionDigits,
	                style: NumberFormatStyle[style].toLowerCase()
	            };
	            if (style == NumberFormatStyle.Currency) {
	                options.currency = currency;
	                options.currencyDisplay = currencyAsSymbol ? 'symbol' : 'code';
	            }
	            return new Intl.NumberFormat(locale, options).format(num);
	        };
	        return NumberFormatter;
	    }());
	    var /** @type {?} */ DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsazZEwGjJ']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|J+|j+|m+|s+|a|z|Z|G+|w+))(.*)/;
	    var /** @type {?} */ PATTERN_ALIASES = {
	        // Keys are quoted so they do not get renamed during closure compilation.
	        'yMMMdjms': datePartGetterFactory(combine([
	            digitCondition('year', 1),
	            nameCondition('month', 3),
	            digitCondition('day', 1),
	            digitCondition('hour', 1),
	            digitCondition('minute', 1),
	            digitCondition('second', 1),
	        ])),
	        'yMdjm': datePartGetterFactory(combine([
	            digitCondition('year', 1), digitCondition('month', 1), digitCondition('day', 1),
	            digitCondition('hour', 1), digitCondition('minute', 1)
	        ])),
	        'yMMMMEEEEd': datePartGetterFactory(combine([
	            digitCondition('year', 1), nameCondition('month', 4), nameCondition('weekday', 4),
	            digitCondition('day', 1)
	        ])),
	        'yMMMMd': datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 4), digitCondition('day', 1)])),
	        'yMMMd': datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 3), digitCondition('day', 1)])),
	        'yMd': datePartGetterFactory(combine([digitCondition('year', 1), digitCondition('month', 1), digitCondition('day', 1)])),
	        'jms': datePartGetterFactory(combine([digitCondition('hour', 1), digitCondition('second', 1), digitCondition('minute', 1)])),
	        'jm': datePartGetterFactory(combine([digitCondition('hour', 1), digitCondition('minute', 1)]))
	    };
	    var /** @type {?} */ DATE_FORMATS = {
	        // Keys are quoted so they do not get renamed.
	        'yyyy': datePartGetterFactory(digitCondition('year', 4)),
	        'yy': datePartGetterFactory(digitCondition('year', 2)),
	        'y': datePartGetterFactory(digitCondition('year', 1)),
	        'MMMM': datePartGetterFactory(nameCondition('month', 4)),
	        'MMM': datePartGetterFactory(nameCondition('month', 3)),
	        'MM': datePartGetterFactory(digitCondition('month', 2)),
	        'M': datePartGetterFactory(digitCondition('month', 1)),
	        'LLLL': datePartGetterFactory(nameCondition('month', 4)),
	        'L': datePartGetterFactory(nameCondition('month', 1)),
	        'dd': datePartGetterFactory(digitCondition('day', 2)),
	        'd': datePartGetterFactory(digitCondition('day', 1)),
	        'HH': digitModifier(hourExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 2), false)))),
	        'H': hourExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), false))),
	        'hh': digitModifier(hourExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 2), true)))),
	        'h': hourExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), true))),
	        'jj': datePartGetterFactory(digitCondition('hour', 2)),
	        'j': datePartGetterFactory(digitCondition('hour', 1)),
	        'mm': digitModifier(datePartGetterFactory(digitCondition('minute', 2))),
	        'm': datePartGetterFactory(digitCondition('minute', 1)),
	        'ss': digitModifier(datePartGetterFactory(digitCondition('second', 2))),
	        's': datePartGetterFactory(digitCondition('second', 1)),
	        // while ISO 8601 requires fractions to be prefixed with `.` or `,`
	        // we can be just safely rely on using `sss` since we currently don't support single or two digit
	        // fractions
	        'sss': datePartGetterFactory(digitCondition('second', 3)),
	        'EEEE': datePartGetterFactory(nameCondition('weekday', 4)),
	        'EEE': datePartGetterFactory(nameCondition('weekday', 3)),
	        'EE': datePartGetterFactory(nameCondition('weekday', 2)),
	        'E': datePartGetterFactory(nameCondition('weekday', 1)),
	        'a': hourClockExtractor(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), true))),
	        'Z': timeZoneGetter('short'),
	        'z': timeZoneGetter('long'),
	        'ww': datePartGetterFactory({}),
	        // first Thursday of the year. not support ?
	        'w': datePartGetterFactory({}),
	        // of the year not support ?
	        'G': datePartGetterFactory(nameCondition('era', 1)),
	        'GG': datePartGetterFactory(nameCondition('era', 2)),
	        'GGG': datePartGetterFactory(nameCondition('era', 3)),
	        'GGGG': datePartGetterFactory(nameCondition('era', 4))
	    };
	    /**
	     * @param {?} inner
	     * @return {?}
	     */
	    function digitModifier(inner) {
	        return function (date, locale) {
	            var /** @type {?} */ result = inner(date, locale);
	            return result.length == 1 ? '0' + result : result;
	        };
	    }
	    /**
	     * @param {?} inner
	     * @return {?}
	     */
	    function hourClockExtractor(inner) {
	        return function (date, locale) { return inner(date, locale).split(' ')[1]; };
	    }
	    /**
	     * @param {?} inner
	     * @return {?}
	     */
	    function hourExtractor(inner) {
	        return function (date, locale) { return inner(date, locale).split(' ')[0]; };
	    }
	    /**
	     * @param {?} date
	     * @param {?} locale
	     * @param {?} options
	     * @return {?}
	     */
	    function intlDateFormat(date, locale, options) {
	        return new Intl.DateTimeFormat(locale, options).format(date).replace(/[\u200e\u200f]/g, '');
	    }
	    /**
	     * @param {?} timezone
	     * @return {?}
	     */
	    function timeZoneGetter(timezone) {
	        // To workaround `Intl` API restriction for single timezone let format with 24 hours
	        var /** @type {?} */ options = { hour: '2-digit', hour12: false, timeZoneName: timezone };
	        return function (date, locale) {
	            var /** @type {?} */ result = intlDateFormat(date, locale, options);
	            // Then extract first 3 letters that related to hours
	            return result ? result.substring(3) : '';
	        };
	    }
	    /**
	     * @param {?} options
	     * @param {?} value
	     * @return {?}
	     */
	    function hour12Modify(options, value) {
	        options.hour12 = value;
	        return options;
	    }
	    /**
	     * @param {?} prop
	     * @param {?} len
	     * @return {?}
	     */
	    function digitCondition(prop, len) {
	        var /** @type {?} */ result = {};
	        result[prop] = len === 2 ? '2-digit' : 'numeric';
	        return result;
	    }
	    /**
	     * @param {?} prop
	     * @param {?} len
	     * @return {?}
	     */
	    function nameCondition(prop, len) {
	        var /** @type {?} */ result = {};
	        if (len < 4) {
	            result[prop] = len > 1 ? 'short' : 'narrow';
	        }
	        else {
	            result[prop] = 'long';
	        }
	        return result;
	    }
	    /**
	     * @param {?} options
	     * @return {?}
	     */
	    function combine(options) {
	        return (_a = ((Object))).assign.apply(_a, [{}].concat(options));
	        var _a;
	    }
	    /**
	     * @param {?} ret
	     * @return {?}
	     */
	    function datePartGetterFactory(ret) {
	        return function (date, locale) { return intlDateFormat(date, locale, ret); };
	    }
	    var /** @type {?} */ DATE_FORMATTER_CACHE = new Map();
	    /**
	     * @param {?} format
	     * @param {?} date
	     * @param {?} locale
	     * @return {?}
	     */
	    function dateFormatter(format, date, locale) {
	        var /** @type {?} */ fn = PATTERN_ALIASES[format];
	        if (fn)
	            return fn(date, locale);
	        var /** @type {?} */ cacheKey = format;
	        var /** @type {?} */ parts = DATE_FORMATTER_CACHE.get(cacheKey);
	        if (!parts) {
	            parts = [];
	            var /** @type {?} */ match = void 0;
	            DATE_FORMATS_SPLIT.exec(format);
	            while (format) {
	                match = DATE_FORMATS_SPLIT.exec(format);
	                if (match) {
	                    parts = parts.concat(match.slice(1));
	                    format = parts.pop();
	                }
	                else {
	                    parts.push(format);
	                    format = null;
	                }
	            }
	            DATE_FORMATTER_CACHE.set(cacheKey, parts);
	        }
	        return parts.reduce(function (text, part) {
	            var /** @type {?} */ fn = DATE_FORMATS[part];
	            return text + (fn ? fn(date, locale) : partToTime(part));
	        }, '');
	    }
	    /**
	     * @param {?} part
	     * @return {?}
	     */
	    function partToTime(part) {
	        return part === '\'\'' ? '\'' : part.replace(/(^'|'$)/g, '').replace(/''/g, '\'');
	    }
	    var DateFormatter = (function () {
	        function DateFormatter() {
	        }
	        /**
	         * @param {?} date
	         * @param {?} locale
	         * @param {?} pattern
	         * @return {?}
	         */
	        DateFormatter.format = function (date, locale, pattern) {
	            return dateFormatter(pattern, date, locale);
	        };
	        return DateFormatter;
	    }());

	    /**
	     * \@ngModule CommonModule
	     * \@whatItDoes Formats a date according to locale rules.
	     * \@howToUse `date_expression | date[:format]`
	     * \@description
	     *
	     * Where:
	     * - `expression` is a date object or a number (milliseconds since UTC epoch) or an ISO string
	     * (https://www.w3.org/TR/NOTE-datetime).
	     * - `format` indicates which date/time components to include. The format can be predifined as
	     *   shown below or custom as shown in the table.
	     *   - `'medium'`: equivalent to `'yMMMdjms'` (e.g. `Sep 3, 2010, 12:05:08 PM` for `en-US`)
	     *   - `'short'`: equivalent to `'yMdjm'` (e.g. `9/3/2010, 12:05 PM` for `en-US`)
	     *   - `'fullDate'`: equivalent to `'yMMMMEEEEd'` (e.g. `Friday, September 3, 2010` for `en-US`)
	     *   - `'longDate'`: equivalent to `'yMMMMd'` (e.g. `September 3, 2010` for `en-US`)
	     *   - `'mediumDate'`: equivalent to `'yMMMd'` (e.g. `Sep 3, 2010` for `en-US`)
	     *   - `'shortDate'`: equivalent to `'yMd'` (e.g. `9/3/2010` for `en-US`)
	     *   - `'mediumTime'`: equivalent to `'jms'` (e.g. `12:05:08 PM` for `en-US`)
	     *   - `'shortTime'`: equivalent to `'jm'` (e.g. `12:05 PM` for `en-US`)
	     *
	     *
	     *  | Component | Symbol | Narrow | Short Form   | Long Form         | Numeric   | 2-digit   |
	     *  |-----------|:------:|--------|--------------|-------------------|-----------|-----------|
	     *  | era       |   G    | G (A)  | GGG (AD)     | GGGG (Anno Domini)| -         | -         |
	     *  | year      |   y    | -      | -            | -                 | y (2015)  | yy (15)   |
	     *  | month     |   M    | L (S)  | MMM (Sep)    | MMMM (September)  | M (9)     | MM (09)   |
	     *  | day       |   d    | -      | -            | -                 | d (3)     | dd (03)   |
	     *  | weekday   |   E    | E (S)  | EEE (Sun)    | EEEE (Sunday)     | -         | -         |
	     *  | hour      |   j    | -      | -            | -                 | j (13)    | jj (13)   |
	     *  | hour12    |   h    | -      | -            | -                 | h (1 PM)  | hh (01 PM)|
	     *  | hour24    |   H    | -      | -            | -                 | H (13)    | HH (13)   |
	     *  | minute    |   m    | -      | -            | -                 | m (5)     | mm (05)   |
	     *  | second    |   s    | -      | -            | -                 | s (9)     | ss (09)   |
	     *  | timezone  |   z    | -      | -            | z (Pacific Standard Time)| -  | -         |
	     *  | timezone  |   Z    | -      | Z (GMT-8:00) | -                 | -         | -         |
	     *  | timezone  |   a    | -      | a (PM)       | -                 | -         | -         |
	     *
	     * In javascript, only the components specified will be respected (not the ordering,
	     * punctuations, ...) and details of the formatting will be dependent on the locale.
	     *
	     * Timezone of the formatted text will be the local system timezone of the end-user's machine.
	     *
	     * When the expression is a ISO string without time (e.g. 2016-09-19) the time zone offset is not
	     * applied and the formatted text will have the same day, month and year of the expression.
	     *
	     * WARNINGS:
	     * - this pipe is marked as pure hence it will not be re-evaluated when the input is mutated.
	     *   Instead users should treat the date as an immutable object and change the reference when the
	     *   pipe needs to re-run (this is to avoid reformatting the date on every change detection run
	     *   which would be an expensive operation).
	     * - this pipe uses the Internationalization API. Therefore it is only reliable in Chrome and Opera
	     *   browsers.
	     *
	     * ### Examples
	     *
	     * Assuming `dateObj` is (year: 2015, month: 6, day: 15, hour: 21, minute: 43, second: 11)
	     * in the _local_ time and locale is 'en-US':
	     *
	     * ```
	     *     {{ dateObj | date }}               // output is 'Jun 15, 2015'
	     *     {{ dateObj | date:'medium' }}      // output is 'Jun 15, 2015, 9:43:11 PM'
	     *     {{ dateObj | date:'shortTime' }}   // output is '9:43 PM'
	     *     {{ dateObj | date:'mmss' }}        // output is '43:11'
	     * ```
	     *
	     * {\@example common/pipes/ts/date_pipe.ts region='DatePipe'}
	     *
	     * \@stable
	     */
	    var DatePipe = (function () {
	        /**
	         * @param {?} _locale
	         */
	        function DatePipe(_locale) {
	            this._locale = _locale;
	        }
	        /**
	         * @param {?} value
	         * @param {?=} pattern
	         * @return {?}
	         */
	        DatePipe.prototype.transform = function (value, pattern) {
	            if (pattern === void 0) { pattern = 'mediumDate'; }
	            var /** @type {?} */ date;
	            if (isBlank$1(value))
	                return null;
	            if (typeof value === 'string') {
	                value = value.trim();
	            }
	            if (isDate(value)) {
	                date = value;
	            }
	            else if (NumberWrapper.isNumeric(value)) {
	                date = new Date(parseFloat(value));
	            }
	            else if (typeof value === 'string' && /^(\d{4}-\d{1,2}-\d{1,2})$/.test(value)) {
	                /**
	                * For ISO Strings without time the day, month and year must be extracted from the ISO String
	                * before Date creation to avoid time offset and errors in the new Date.
	                * If we only replace '-' with ',' in the ISO String ("2015,01,01"), and try to create a new
	                * date, some browsers (e.g. IE 9) will throw an invalid Date error
	                * If we leave the '-' ("2015-01-01") and try to create a new Date("2015-01-01") the timeoffset
	                * is applied
	                * Note: ISO months are 0 for January, 1 for February, ...
	                */
	                var _a = value.split('-').map(function (val) { return parseInt(val, 10); }), y = _a[0], m = _a[1], d = _a[2];
	                date = new Date(y, m - 1, d);
	            }
	            else {
	                date = new Date(value);
	            }
	            if (!isDate(date)) {
	                throw new InvalidPipeArgumentError(DatePipe, value);
	            }
	            return DateFormatter.format(date, this._locale, DatePipe._ALIASES[pattern] || pattern);
	        };
	        /** @internal */
	        DatePipe._ALIASES = {
	            'medium': 'yMMMdjms',
	            'short': 'yMdjm',
	            'fullDate': 'yMMMMEEEEd',
	            'longDate': 'yMMMMd',
	            'mediumDate': 'yMMMd',
	            'shortDate': 'yMd',
	            'mediumTime': 'jms',
	            'shortTime': 'jm'
	        };
	        DatePipe.decorators = [
	            { type: _angular_core.Pipe, args: [{ name: 'date', pure: true },] },
	        ];
	        /** @nocollapse */
	        DatePipe.ctorParameters = function () { return [
	            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
	        ]; };
	        return DatePipe;
	    }());
	    /**
	     * @param {?} obj
	     * @return {?}
	     */
	    function isBlank$1(obj) {
	        return obj == null || obj === '';
	    }

	    var /** @type {?} */ _INTERPOLATION_REGEXP = /#/g;
	    /**
	     * \@ngModule CommonModule
	     * \@whatItDoes Maps a value to a string that pluralizes the value according to locale rules.
	     * \@howToUse `expression | i18nPlural:mapping`
	     * \@description
	     *
	     *  Where:
	     *  - `expression` is a number.
	     *  - `mapping` is an object that mimics the ICU format, see
	     *    http://userguide.icu-project.org/formatparse/messages
	     *
	     *  ## Example
	     *
	     * {\@example common/pipes/ts/i18n_pipe.ts region='I18nPluralPipeComponent'}
	     *
	     * \@experimental
	     */
	    var I18nPluralPipe = (function () {
	        /**
	         * @param {?} _localization
	         */
	        function I18nPluralPipe(_localization) {
	            this._localization = _localization;
	        }
	        /**
	         * @param {?} value
	         * @param {?} pluralMap
	         * @return {?}
	         */
	        I18nPluralPipe.prototype.transform = function (value, pluralMap) {
	            if (value == null)
	                return '';
	            if (typeof pluralMap !== 'object' || pluralMap === null) {
	                throw new InvalidPipeArgumentError(I18nPluralPipe, pluralMap);
	            }
	            var /** @type {?} */ key = getPluralCategory(value, Object.keys(pluralMap), this._localization);
	            return pluralMap[key].replace(_INTERPOLATION_REGEXP, value.toString());
	        };
	        I18nPluralPipe.decorators = [
	            { type: _angular_core.Pipe, args: [{ name: 'i18nPlural', pure: true },] },
	        ];
	        /** @nocollapse */
	        I18nPluralPipe.ctorParameters = function () { return [
	            { type: NgLocalization, },
	        ]; };
	        return I18nPluralPipe;
	    }());

	    /**
	     * \@ngModule CommonModule
	     * \@whatItDoes Generic selector that displays the string that matches the current value.
	     * \@howToUse `expression | i18nSelect:mapping`
	     * \@description
	     *
	     *  Where `mapping` is an object that indicates the text that should be displayed
	     *  for different values of the provided `expression`.
	     *  If none of the keys of the mapping match the value of the `expression`, then the content
	     *  of the `other` key is returned when present, otherwise an empty string is returned.
	     *
	     *  ## Example
	     *
	     * {\@example common/pipes/ts/i18n_pipe.ts region='I18nSelectPipeComponent'}
	     *
	     *  \@experimental
	     */
	    var I18nSelectPipe = (function () {
	        function I18nSelectPipe() {
	        }
	        /**
	         * @param {?} value
	         * @param {?} mapping
	         * @return {?}
	         */
	        I18nSelectPipe.prototype.transform = function (value, mapping) {
	            if (value == null)
	                return '';
	            if (typeof mapping !== 'object' || typeof value !== 'string') {
	                throw new InvalidPipeArgumentError(I18nSelectPipe, mapping);
	            }
	            if (mapping.hasOwnProperty(value)) {
	                return mapping[value];
	            }
	            if (mapping.hasOwnProperty('other')) {
	                return mapping['other'];
	            }
	            return '';
	        };
	        I18nSelectPipe.decorators = [
	            { type: _angular_core.Pipe, args: [{ name: 'i18nSelect', pure: true },] },
	        ];
	        /** @nocollapse */
	        I18nSelectPipe.ctorParameters = function () { return []; };
	        return I18nSelectPipe;
	    }());

	    /**
	     * \@ngModule CommonModule
	     * \@whatItDoes Converts value into JSON string.
	     * \@howToUse `expression | json`
	     * \@description
	     *
	     * Converts value into string using `JSON.stringify`. Useful for debugging.
	     *
	     * ### Example
	     * {\@example common/pipes/ts/json_pipe.ts region='JsonPipe'}
	     *
	     * \@stable
	     */
	    var JsonPipe = (function () {
	        function JsonPipe() {
	        }
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        JsonPipe.prototype.transform = function (value) { return JSON.stringify(value, null, 2); };
	        JsonPipe.decorators = [
	            { type: _angular_core.Pipe, args: [{ name: 'json', pure: false },] },
	        ];
	        /** @nocollapse */
	        JsonPipe.ctorParameters = function () { return []; };
	        return JsonPipe;
	    }());

	    /**
	     * \@ngModule CommonModule
	     * \@whatItDoes Transforms string to lowercase.
	     * \@howToUse `expression | lowercase`
	     * \@description
	     *
	     * Converts value into a lowercase string using `String.prototype.toLowerCase()`.
	     *
	     * ### Example
	     *
	     * {\@example common/pipes/ts/lowerupper_pipe.ts region='LowerUpperPipe'}
	     *
	     * \@stable
	     */
	    var LowerCasePipe = (function () {
	        function LowerCasePipe() {
	        }
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        LowerCasePipe.prototype.transform = function (value) {
	            if (isBlank(value))
	                return value;
	            if (typeof value !== 'string') {
	                throw new InvalidPipeArgumentError(LowerCasePipe, value);
	            }
	            return value.toLowerCase();
	        };
	        LowerCasePipe.decorators = [
	            { type: _angular_core.Pipe, args: [{ name: 'lowercase' },] },
	        ];
	        /** @nocollapse */
	        LowerCasePipe.ctorParameters = function () { return []; };
	        return LowerCasePipe;
	    }());

	    var /** @type {?} */ _NUMBER_FORMAT_REGEXP = /^(\d+)?\.((\d+)(-(\d+))?)?$/;
	    /**
	     * @param {?} pipe
	     * @param {?} locale
	     * @param {?} value
	     * @param {?} style
	     * @param {?} digits
	     * @param {?=} currency
	     * @param {?=} currencyAsSymbol
	     * @return {?}
	     */
	    function formatNumber(pipe, locale, value, style, digits, currency, currencyAsSymbol) {
	        if (currency === void 0) { currency = null; }
	        if (currencyAsSymbol === void 0) { currencyAsSymbol = false; }
	        if (value == null)
	            return null;
	        // Convert strings to numbers
	        value = typeof value === 'string' && NumberWrapper.isNumeric(value) ? +value : value;
	        if (typeof value !== 'number') {
	            throw new InvalidPipeArgumentError(pipe, value);
	        }
	        var /** @type {?} */ minInt;
	        var /** @type {?} */ minFraction;
	        var /** @type {?} */ maxFraction;
	        if (style !== NumberFormatStyle.Currency) {
	            // rely on Intl default for currency
	            minInt = 1;
	            minFraction = 0;
	            maxFraction = 3;
	        }
	        if (digits) {
	            var /** @type {?} */ parts = digits.match(_NUMBER_FORMAT_REGEXP);
	            if (parts === null) {
	                throw new Error(digits + " is not a valid digit info for number pipes");
	            }
	            if (parts[1] != null) {
	                minInt = NumberWrapper.parseIntAutoRadix(parts[1]);
	            }
	            if (parts[3] != null) {
	                minFraction = NumberWrapper.parseIntAutoRadix(parts[3]);
	            }
	            if (parts[5] != null) {
	                maxFraction = NumberWrapper.parseIntAutoRadix(parts[5]);
	            }
	        }
	        return NumberFormatter.format(/** @type {?} */ (value), locale, style, {
	            minimumIntegerDigits: minInt,
	            minimumFractionDigits: minFraction,
	            maximumFractionDigits: maxFraction,
	            currency: currency,
	            currencyAsSymbol: currencyAsSymbol,
	        });
	    }
	    /**
	     * \@ngModule CommonModule
	     * \@whatItDoes Formats a number according to locale rules.
	     * \@howToUse `number_expression | number[:digitInfo]`
	     *
	     * Formats a number as text. Group sizing and separator and other locale-specific
	     * configurations are based on the active locale.
	     *
	     * where `expression` is a number:
	     *  - `digitInfo` is a `string` which has a following format: <br>
	     *     <code>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}</code>
	     *   - `minIntegerDigits` is the minimum number of integer digits to use. Defaults to `1`.
	     *   - `minFractionDigits` is the minimum number of digits after fraction. Defaults to `0`.
	     *   - `maxFractionDigits` is the maximum number of digits after fraction. Defaults to `3`.
	     *
	     * For more information on the acceptable range for each of these numbers and other
	     * details see your native internationalization library.
	     *
	     * WARNING: this pipe uses the Internationalization API which is not yet available in all browsers
	     * and may require a polyfill. See {\@linkDocs guide/browser-support} for details.
	     *
	     * ### Example
	     *
	     * {\@example common/pipes/ts/number_pipe.ts region='NumberPipe'}
	     *
	     * \@stable
	     */
	    var DecimalPipe = (function () {
	        /**
	         * @param {?} _locale
	         */
	        function DecimalPipe(_locale) {
	            this._locale = _locale;
	        }
	        /**
	         * @param {?} value
	         * @param {?=} digits
	         * @return {?}
	         */
	        DecimalPipe.prototype.transform = function (value, digits) {
	            if (digits === void 0) { digits = null; }
	            return formatNumber(DecimalPipe, this._locale, value, NumberFormatStyle.Decimal, digits);
	        };
	        DecimalPipe.decorators = [
	            { type: _angular_core.Pipe, args: [{ name: 'number' },] },
	        ];
	        /** @nocollapse */
	        DecimalPipe.ctorParameters = function () { return [
	            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
	        ]; };
	        return DecimalPipe;
	    }());
	    /**
	     * \@ngModule CommonModule
	     * \@whatItDoes Formats a number as a percentage according to locale rules.
	     * \@howToUse `number_expression | percent[:digitInfo]`
	     *
	     * \@description
	     *
	     * Formats a number as percentage.
	     *
	     * - `digitInfo` See {\@link DecimalPipe} for detailed description.
	     *
	     * WARNING: this pipe uses the Internationalization API which is not yet available in all browsers
	     * and may require a polyfill. See {\@linkDocs guide/browser-support} for details.
	     *
	     * ### Example
	     *
	     * {\@example common/pipes/ts/number_pipe.ts region='PercentPipe'}
	     *
	     * \@stable
	     */
	    var PercentPipe = (function () {
	        /**
	         * @param {?} _locale
	         */
	        function PercentPipe(_locale) {
	            this._locale = _locale;
	        }
	        /**
	         * @param {?} value
	         * @param {?=} digits
	         * @return {?}
	         */
	        PercentPipe.prototype.transform = function (value, digits) {
	            if (digits === void 0) { digits = null; }
	            return formatNumber(PercentPipe, this._locale, value, NumberFormatStyle.Percent, digits);
	        };
	        PercentPipe.decorators = [
	            { type: _angular_core.Pipe, args: [{ name: 'percent' },] },
	        ];
	        /** @nocollapse */
	        PercentPipe.ctorParameters = function () { return [
	            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
	        ]; };
	        return PercentPipe;
	    }());
	    /**
	     * \@ngModule CommonModule
	     * \@whatItDoes Formats a number as currency using locale rules.
	     * \@howToUse `number_expression | currency[:currencyCode[:symbolDisplay[:digitInfo]]]`
	     * \@description
	     *
	     * Use `currency` to format a number as currency.
	     *
	     * - `currencyCode` is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, such
	     *    as `USD` for the US dollar and `EUR` for the euro.
	     * - `symbolDisplay` is a boolean indicating whether to use the currency symbol or code.
	     *   - `true`: use symbol (e.g. `$`).
	     *   - `false`(default): use code (e.g. `USD`).
	     * - `digitInfo` See {\@link DecimalPipe} for detailed description.
	     *
	     * WARNING: this pipe uses the Internationalization API which is not yet available in all browsers
	     * and may require a polyfill. See {\@linkDocs guide/browser-support} for details.
	     *
	     * ### Example
	     *
	     * {\@example common/pipes/ts/number_pipe.ts region='CurrencyPipe'}
	     *
	     * \@stable
	     */
	    var CurrencyPipe = (function () {
	        /**
	         * @param {?} _locale
	         */
	        function CurrencyPipe(_locale) {
	            this._locale = _locale;
	        }
	        /**
	         * @param {?} value
	         * @param {?=} currencyCode
	         * @param {?=} symbolDisplay
	         * @param {?=} digits
	         * @return {?}
	         */
	        CurrencyPipe.prototype.transform = function (value, currencyCode, symbolDisplay, digits) {
	            if (currencyCode === void 0) { currencyCode = 'USD'; }
	            if (symbolDisplay === void 0) { symbolDisplay = false; }
	            if (digits === void 0) { digits = null; }
	            return formatNumber(CurrencyPipe, this._locale, value, NumberFormatStyle.Currency, digits, currencyCode, symbolDisplay);
	        };
	        CurrencyPipe.decorators = [
	            { type: _angular_core.Pipe, args: [{ name: 'currency' },] },
	        ];
	        /** @nocollapse */
	        CurrencyPipe.ctorParameters = function () { return [
	            { type: undefined, decorators: [{ type: _angular_core.Inject, args: [_angular_core.LOCALE_ID,] },] },
	        ]; };
	        return CurrencyPipe;
	    }());

	    /**
	     * \@ngModule CommonModule
	     * \@whatItDoes Creates a new List or String containing a subset (slice) of the elements.
	     * \@howToUse `array_or_string_expression | slice:start[:end]`
	     * \@description
	     *
	     * Where the input expression is a `List` or `String`, and:
	     * - `start`: The starting index of the subset to return.
	     *   - **a positive integer**: return the item at `start` index and all items after
	     *     in the list or string expression.
	     *   - **a negative integer**: return the item at `start` index from the end and all items after
	     *     in the list or string expression.
	     *   - **if positive and greater than the size of the expression**: return an empty list or string.
	     *   - **if negative and greater than the size of the expression**: return entire list or string.
	     * - `end`: The ending index of the subset to return.
	     *   - **omitted**: return all items until the end.
	     *   - **if positive**: return all items before `end` index of the list or string.
	     *   - **if negative**: return all items before `end` index from the end of the list or string.
	     *
	     * All behavior is based on the expected behavior of the JavaScript API `Array.prototype.slice()`
	     * and `String.prototype.slice()`.
	     *
	     * When operating on a [List], the returned list is always a copy even when all
	     * the elements are being returned.
	     *
	     * When operating on a blank value, the pipe returns the blank value.
	     *
	     * ## List Example
	     *
	     * This `ngFor` example:
	     *
	     * {\@example common/pipes/ts/slice_pipe.ts region='SlicePipe_list'}
	     *
	     * produces the following:
	     *
	     *     <li>b</li>
	     *     <li>c</li>
	     *
	     * ## String Examples
	     *
	     * {\@example common/pipes/ts/slice_pipe.ts region='SlicePipe_string'}
	     *
	     * \@stable
	     */
	    var SlicePipe = (function () {
	        function SlicePipe() {
	        }
	        /**
	         * @param {?} value
	         * @param {?} start
	         * @param {?=} end
	         * @return {?}
	         */
	        SlicePipe.prototype.transform = function (value, start, end) {
	            if (value == null)
	                return value;
	            if (!this.supports(value)) {
	                throw new InvalidPipeArgumentError(SlicePipe, value);
	            }
	            return value.slice(start, end);
	        };
	        /**
	         * @param {?} obj
	         * @return {?}
	         */
	        SlicePipe.prototype.supports = function (obj) { return typeof obj === 'string' || Array.isArray(obj); };
	        SlicePipe.decorators = [
	            { type: _angular_core.Pipe, args: [{ name: 'slice', pure: false },] },
	        ];
	        /** @nocollapse */
	        SlicePipe.ctorParameters = function () { return []; };
	        return SlicePipe;
	    }());

	    /**
	     * \@ngModule CommonModule
	     * \@whatItDoes Transforms string to uppercase.
	     * \@howToUse `expression | uppercase`
	     * \@description
	     *
	     * Converts value into an uppercase string using `String.prototype.toUpperCase()`.
	     *
	     * ### Example
	     *
	     * {\@example common/pipes/ts/lowerupper_pipe.ts region='LowerUpperPipe'}
	     *
	     * \@stable
	     */
	    var UpperCasePipe = (function () {
	        function UpperCasePipe() {
	        }
	        /**
	         * @param {?} value
	         * @return {?}
	         */
	        UpperCasePipe.prototype.transform = function (value) {
	            if (isBlank(value))
	                return value;
	            if (typeof value !== 'string') {
	                throw new InvalidPipeArgumentError(UpperCasePipe, value);
	            }
	            return value.toUpperCase();
	        };
	        UpperCasePipe.decorators = [
	            { type: _angular_core.Pipe, args: [{ name: 'uppercase' },] },
	        ];
	        /** @nocollapse */
	        UpperCasePipe.ctorParameters = function () { return []; };
	        return UpperCasePipe;
	    }());

	    /**
	     * A collection of Angular pipes that are likely to be used in each and every application.
	     */
	    var /** @type {?} */ COMMON_PIPES = [
	        AsyncPipe,
	        UpperCasePipe,
	        LowerCasePipe,
	        JsonPipe,
	        SlicePipe,
	        DecimalPipe,
	        PercentPipe,
	        CurrencyPipe,
	        DatePipe,
	        I18nPluralPipe,
	        I18nSelectPipe,
	    ];

	    /**
	     * The module that includes all the basic Angular directives like {\@link NgIf}, {\@link NgFor}, ...
	     *
	     * \@stable
	     */
	    var CommonModule = (function () {
	        function CommonModule() {
	        }
	        CommonModule.decorators = [
	            { type: _angular_core.NgModule, args: [{
	                        declarations: [COMMON_DIRECTIVES, COMMON_PIPES],
	                        exports: [COMMON_DIRECTIVES, COMMON_PIPES],
	                        providers: [
	                            { provide: NgLocalization, useClass: NgLocaleLocalization },
	                        ],
	                    },] },
	        ];
	        /** @nocollapse */
	        CommonModule.ctorParameters = function () { return []; };
	        return CommonModule;
	    }());

	    /**
	     * @stable
	     */
	    var /** @type {?} */ VERSION = new _angular_core.Version('2.4.4');

	    exports.NgLocalization = NgLocalization;
	    exports.CommonModule = CommonModule;
	    exports.NgClass = NgClass;
	    exports.NgFor = NgFor;
	    exports.NgIf = NgIf;
	    exports.NgPlural = NgPlural;
	    exports.NgPluralCase = NgPluralCase;
	    exports.NgStyle = NgStyle;
	    exports.NgSwitch = NgSwitch;
	    exports.NgSwitchCase = NgSwitchCase;
	    exports.NgSwitchDefault = NgSwitchDefault;
	    exports.NgTemplateOutlet = NgTemplateOutlet;
	    exports.AsyncPipe = AsyncPipe;
	    exports.DatePipe = DatePipe;
	    exports.I18nPluralPipe = I18nPluralPipe;
	    exports.I18nSelectPipe = I18nSelectPipe;
	    exports.JsonPipe = JsonPipe;
	    exports.LowerCasePipe = LowerCasePipe;
	    exports.CurrencyPipe = CurrencyPipe;
	    exports.DecimalPipe = DecimalPipe;
	    exports.PercentPipe = PercentPipe;
	    exports.SlicePipe = SlicePipe;
	    exports.UpperCasePipe = UpperCasePipe;
	    exports.VERSION = VERSION;
	    exports.Version = _angular_core.Version;
	    exports.PlatformLocation = PlatformLocation;
	    exports.LocationStrategy = LocationStrategy;
	    exports.APP_BASE_HREF = APP_BASE_HREF;
	    exports.HashLocationStrategy = HashLocationStrategy;
	    exports.PathLocationStrategy = PathLocationStrategy;
	    exports.Location = Location;

	}));
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @license Angular v2.4.4
	 * (c) 2010-2016 Google, Inc. https://angular.io/
	 * License: MIT
	 */
	(function (global, factory) {
	     true ? factory(exports, __webpack_require__(28)) :
	    typeof define === 'function' && define.amd ? define(['exports', '@angular/core'], factory) :
	    (factory((global.ng = global.ng || {}, global.ng.upgrade = global.ng.upgrade || {}, global.ng.upgrade.static = global.ng.upgrade.static || {}),global.ng.core));
	}(this, function (exports,_angular_core) { 'use strict';

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    var /** @type {?} */ UPGRADE_MODULE_NAME = '$$UpgradeModule';
	    var /** @type {?} */ INJECTOR_KEY = '$$angularInjector';
	    var /** @type {?} */ $INJECTOR = '$injector';
	    var /** @type {?} */ $PARSE = '$parse';
	    var /** @type {?} */ $SCOPE = '$scope';
	    var /** @type {?} */ $PROVIDE = '$provide';
	    var /** @type {?} */ $DELEGATE = '$delegate';
	    var /** @type {?} */ $$TESTABILITY = '$$testability';
	    var /** @type {?} */ $COMPILE = '$compile';
	    var /** @type {?} */ $TEMPLATE_CACHE = '$templateCache';
	    var /** @type {?} */ $HTTP_BACKEND = '$httpBackend';
	    var /** @type {?} */ $CONTROLLER = '$controller';

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * A `PropertyBinding` represents a mapping between a property name
	     * and an attribute name. It is parsed from a string of the form
	     * `"prop: attr"`; or simply `"propAndAttr" where the property
	     * and attribute have the same identifier.
	     */
	    var PropertyBinding = (function () {
	        /**
	         * @param {?} binding
	         */
	        function PropertyBinding(binding) {
	            this.binding = binding;
	            this.parseBinding();
	        }
	        /**
	         * @return {?}
	         */
	        PropertyBinding.prototype.parseBinding = function () {
	            var /** @type {?} */ parts = this.binding.split(':');
	            this.prop = parts[0].trim();
	            this.attr = (parts[1] || this.prop).trim();
	            this.bracketAttr = "[" + this.attr + "]";
	            this.parenAttr = "(" + this.attr + ")";
	            this.bracketParenAttr = "[(" + this.attr + ")]";
	            var /** @type {?} */ capitalAttr = this.attr.charAt(0).toUpperCase() + this.attr.substr(1);
	            this.onAttr = "on" + capitalAttr;
	            this.bindAttr = "bind" + capitalAttr;
	            this.bindonAttr = "bindon" + capitalAttr;
	        };
	        return PropertyBinding;
	    }());

	    var /** @type {?} */ INITIAL_VALUE = {
	        __UNINITIALIZED__: true
	    };
	    var DowngradeComponentAdapter = (function () {
	        /**
	         * @param {?} id
	         * @param {?} info
	         * @param {?} element
	         * @param {?} attrs
	         * @param {?} scope
	         * @param {?} parentInjector
	         * @param {?} parse
	         * @param {?} componentFactory
	         */
	        function DowngradeComponentAdapter(id, info, element, attrs, scope, parentInjector, parse, componentFactory) {
	            this.id = id;
	            this.info = info;
	            this.element = element;
	            this.attrs = attrs;
	            this.scope = scope;
	            this.parentInjector = parentInjector;
	            this.parse = parse;
	            this.componentFactory = componentFactory;
	            this.component = null;
	            this.inputChangeCount = 0;
	            this.inputChanges = null;
	            this.componentRef = null;
	            this.changeDetector = null;
	            this.contentInsertionPoint = null;
	            this.element[0].id = id;
	            this.componentScope = scope.$new();
	            this.childNodes = element.contents();
	        }
	        /**
	         * @return {?}
	         */
	        DowngradeComponentAdapter.prototype.createComponent = function () {
	            var /** @type {?} */ childInjector = _angular_core.ReflectiveInjector.resolveAndCreate([{ provide: $SCOPE, useValue: this.componentScope }], this.parentInjector);
	            this.contentInsertionPoint = document.createComment('ng1 insertion point');
	            this.componentRef = this.componentFactory.create(childInjector, [[this.contentInsertionPoint]], this.element[0]);
	            this.changeDetector = this.componentRef.changeDetectorRef;
	            this.component = this.componentRef.instance;
	        };
	        /**
	         * @return {?}
	         */
	        DowngradeComponentAdapter.prototype.setupInputs = function () {
	            var _this = this;
	            var /** @type {?} */ attrs = this.attrs;
	            var /** @type {?} */ inputs = this.info.inputs || [];
	            for (var /** @type {?} */ i = 0; i < inputs.length; i++) {
	                var /** @type {?} */ input = new PropertyBinding(inputs[i]);
	                var /** @type {?} */ expr = null;
	                if (attrs.hasOwnProperty(input.attr)) {
	                    var /** @type {?} */ observeFn = (function (prop /** TODO #9100 */) {
	                        var /** @type {?} */ prevValue = INITIAL_VALUE;
	                        return function (value /** TODO #9100 */) {
	                            if (_this.inputChanges !== null) {
	                                _this.inputChangeCount++;
	                                _this.inputChanges[prop] =
	                                    new Ng1Change(value, prevValue === INITIAL_VALUE ? value : prevValue);
	                                prevValue = value;
	                            }
	                            _this.component[prop] = value;
	                        };
	                    })(input.prop);
	                    attrs.$observe(input.attr, observeFn);
	                }
	                else if (attrs.hasOwnProperty(input.bindAttr)) {
	                    expr = ((attrs) /** TODO #9100 */)[input.bindAttr];
	                }
	                else if (attrs.hasOwnProperty(input.bracketAttr)) {
	                    expr = ((attrs) /** TODO #9100 */)[input.bracketAttr];
	                }
	                else if (attrs.hasOwnProperty(input.bindonAttr)) {
	                    expr = ((attrs) /** TODO #9100 */)[input.bindonAttr];
	                }
	                else if (attrs.hasOwnProperty(input.bracketParenAttr)) {
	                    expr = ((attrs) /** TODO #9100 */)[input.bracketParenAttr];
	                }
	                if (expr != null) {
	                    var /** @type {?} */ watchFn = (function (prop /** TODO #9100 */) {
	                        return function (value /** TODO #9100 */, prevValue /** TODO #9100 */) {
	                            if (_this.inputChanges != null) {
	                                _this.inputChangeCount++;
	                                _this.inputChanges[prop] = new Ng1Change(prevValue, value);
	                            }
	                            _this.component[prop] = value;
	                        };
	                    })(input.prop);
	                    this.componentScope.$watch(expr, watchFn);
	                }
	            }
	            var /** @type {?} */ prototype = this.info.component.prototype;
	            if (prototype && ((prototype)).ngOnChanges) {
	                // Detect: OnChanges interface
	                this.inputChanges = {};
	                this.componentScope.$watch(function () { return _this.inputChangeCount; }, function () {
	                    var /** @type {?} */ inputChanges = _this.inputChanges;
	                    _this.inputChanges = {};
	                    ((_this.component)).ngOnChanges(inputChanges);
	                });
	            }
	            this.componentScope.$watch(function () { return _this.changeDetector && _this.changeDetector.detectChanges(); });
	        };
	        /**
	         * @return {?}
	         */
	        DowngradeComponentAdapter.prototype.projectContent = function () {
	            var /** @type {?} */ childNodes = this.childNodes;
	            var /** @type {?} */ parent = this.contentInsertionPoint.parentNode;
	            if (parent) {
	                for (var /** @type {?} */ i = 0, /** @type {?} */ ii = childNodes.length; i < ii; i++) {
	                    parent.insertBefore(childNodes[i], this.contentInsertionPoint);
	                }
	            }
	        };
	        /**
	         * @return {?}
	         */
	        DowngradeComponentAdapter.prototype.setupOutputs = function () {
	            var _this = this;
	            var /** @type {?} */ attrs = this.attrs;
	            var /** @type {?} */ outputs = this.info.outputs || [];
	            for (var /** @type {?} */ j = 0; j < outputs.length; j++) {
	                var /** @type {?} */ output = new PropertyBinding(outputs[j]);
	                var /** @type {?} */ expr = null;
	                var /** @type {?} */ assignExpr = false;
	                var /** @type {?} */ bindonAttr = output.bindonAttr ? output.bindonAttr.substring(0, output.bindonAttr.length - 6) : null;
	                var /** @type {?} */ bracketParenAttr = output.bracketParenAttr ?
	                    "[(" + output.bracketParenAttr.substring(2, output.bracketParenAttr.length - 8) + ")]" :
	                    null;
	                if (attrs.hasOwnProperty(output.onAttr)) {
	                    expr = ((attrs) /** TODO #9100 */)[output.onAttr];
	                }
	                else if (attrs.hasOwnProperty(output.parenAttr)) {
	                    expr = ((attrs) /** TODO #9100 */)[output.parenAttr];
	                }
	                else if (attrs.hasOwnProperty(bindonAttr)) {
	                    expr = ((attrs) /** TODO #9100 */)[bindonAttr];
	                    assignExpr = true;
	                }
	                else if (attrs.hasOwnProperty(bracketParenAttr)) {
	                    expr = ((attrs) /** TODO #9100 */)[bracketParenAttr];
	                    assignExpr = true;
	                }
	                if (expr != null && assignExpr != null) {
	                    var /** @type {?} */ getter = this.parse(expr);
	                    var /** @type {?} */ setter = getter.assign;
	                    if (assignExpr && !setter) {
	                        throw new Error("Expression '" + expr + "' is not assignable!");
	                    }
	                    var /** @type {?} */ emitter = (this.component[output.prop]);
	                    if (emitter) {
	                        emitter.subscribe({
	                            next: assignExpr ?
	                                (function (setter) { return function (v /** TODO #9100 */) { return setter(_this.scope, v); }; })(setter) :
	                                (function (getter) { return function (v /** TODO #9100 */) {
	                                    return getter(_this.scope, { $event: v });
	                                }; })(getter)
	                        });
	                    }
	                    else {
	                        throw new Error("Missing emitter '" + output.prop + "' on component '" + this.info.component + "'!");
	                    }
	                }
	            }
	        };
	        /**
	         * @return {?}
	         */
	        DowngradeComponentAdapter.prototype.registerCleanup = function () {
	            var _this = this;
	            this.element.bind('$destroy', function () {
	                _this.componentScope.$destroy();
	                _this.componentRef.destroy();
	            });
	        };
	        return DowngradeComponentAdapter;
	    }());
	    var Ng1Change = (function () {
	        /**
	         * @param {?} previousValue
	         * @param {?} currentValue
	         */
	        function Ng1Change(previousValue, currentValue) {
	            this.previousValue = previousValue;
	            this.currentValue = currentValue;
	        }
	        /**
	         * @return {?}
	         */
	        Ng1Change.prototype.isFirstChange = function () { return this.previousValue === this.currentValue; };
	        return Ng1Change;
	    }());

	    var /** @type {?} */ downgradeCount = 0;
	    /**
	     * \@whatItDoes
	     *
	     * *Part of the [upgrade/static](/docs/ts/latest/api/#!?query=upgrade%2Fstatic)
	     * library for hybrid upgrade apps that support AoT compilation*
	     *
	     * Allows an Angular 2+ component to be used from Angular 1.
	     *
	     * \@howToUse
	     *
	     * Let's assume that you have an Angular 2+ component called `ng2Heroes` that needs
	     * to be made available in Angular 1 templates.
	     *
	     * {\@example upgrade/static/ts/module.ts region="ng2-heroes"}
	     *
	     * We must create an Angular 1 [directive](https://docs.angularjs.org/guide/directive)
	     * that will make this Angular 2+ component available inside Angular 1 templates.
	     * The `downgradeComponent()` function returns a factory function that we
	     * can use to define the Angular 1 directive that wraps the "downgraded" component.
	     *
	     * {\@example upgrade/static/ts/module.ts region="ng2-heroes-wrapper"}
	     *
	     * In this example you can see that we must provide information about the component being
	     * "downgraded". This is because once the AoT compiler has run, all metadata about the
	     * component has been removed from the code, and so cannot be inferred.
	     *
	     * We must do the following:
	     * * specify the Angular 2+ component class that is to be downgraded
	     * * specify all inputs and outputs that the Angular 1 component expects
	     *
	     * \@description
	     *
	     * A helper function that returns a factory function to be used for registering an
	     * Angular 1 wrapper directive for "downgrading" an Angular 2+ component.
	     *
	     * The parameter contains information about the Component that is being downgraded:
	     *
	     * * `component: Type<any>`: The type of the Component that will be downgraded
	     * * `inputs: string[]`: A collection of strings that specify what inputs the component accepts.
	     * * `outputs: string[]`: A collection of strings that specify what outputs the component emits.
	     *
	     * The `inputs` and `outputs` are strings that map the names of properties to camelCased
	     * attribute names. They are of the form `"prop: attr"`; or simply `"propAndAttr" where the
	     * property and attribute have the same identifier.
	     *
	     * \@experimental
	     * @param {?} info
	     * @return {?}
	     */
	    function downgradeComponent(info) {
	        var /** @type {?} */ idPrefix = "NG2_UPGRADE_" + downgradeCount++ + "_";
	        var /** @type {?} */ idCount = 0;
	        var /** @type {?} */ directiveFactory = function ($injector, $parse) {
	            return {
	                restrict: 'E',
	                require: '?^' + INJECTOR_KEY,
	                link: function (scope, element, attrs, parentInjector, transclude) {
	                    if (parentInjector === null) {
	                        parentInjector = $injector.get(INJECTOR_KEY);
	                    }
	                    var /** @type {?} */ componentFactoryResolver = parentInjector.get(_angular_core.ComponentFactoryResolver);
	                    var /** @type {?} */ componentFactory = componentFactoryResolver.resolveComponentFactory(info.component);
	                    if (!componentFactory) {
	                        throw new Error('Expecting ComponentFactory for: ' + info.component);
	                    }
	                    var /** @type {?} */ facade = new DowngradeComponentAdapter(idPrefix + (idCount++), info, element, attrs, scope, parentInjector, $parse, componentFactory);
	                    facade.setupInputs();
	                    facade.createComponent();
	                    facade.projectContent();
	                    facade.setupOutputs();
	                    facade.registerCleanup();
	                }
	            };
	        };
	        directiveFactory.$inject = [$INJECTOR, $PARSE];
	        return directiveFactory;
	    }

	    /**
	     * \@whatItDoes
	     *
	     * *Part of the [upgrade/static](/docs/ts/latest/api/#!?query=upgrade%2Fstatic)
	     * library for hybrid upgrade apps that support AoT compilation*
	     *
	     * Allow an Angular 2+ service to be accessible from Angular 1.
	     *
	     * \@howToUse
	     *
	     * First ensure that the service to be downgraded is provided in an {\@link NgModule}
	     * that will be part of the upgrade application. For example, let's assume we have
	     * defined `HeroesService`
	     *
	     * {\@example upgrade/static/ts/module.ts region="ng2-heroes-service"}
	     *
	     * and that we have included this in our upgrade app {\@link NgModule}
	     *
	     * {\@example upgrade/static/ts/module.ts region="ng2-module"}
	     *
	     * Now we can register the `downgradeInjectable` factory function for the service
	     * on an Angular 1 module.
	     *
	     * {\@example upgrade/static/ts/module.ts region="downgrade-ng2-heroes-service"}
	     *
	     * Inside an Angular 1 component's controller we can get hold of the
	     * downgraded service via the name we gave when downgrading.
	     *
	     * {\@example upgrade/static/ts/module.ts region="example-app"}
	     *
	     * \@description
	     *
	     * Takes a `token` that identifies a service provided from Angular 2+.
	     *
	     * Returns a [factory function](https://docs.angularjs.org/guide/di) that can be
	     * used to register the service on an Angular 1 module.
	     *
	     * The factory function provides access to the Angular 2+ service that
	     * is identified by the `token` parameter.
	     *
	     * \@experimental
	     * @param {?} token
	     * @return {?}
	     */
	    function downgradeInjectable(token) {
	        return [INJECTOR_KEY, function (i) { return i.get(token); }];
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    /**
	     * @return {?}
	     */
	    function noNg() {
	        throw new Error('AngularJS v1.x is not loaded!');
	    }
	    var /** @type {?} */ angular = ({
	        bootstrap: noNg,
	        module: noNg,
	        element: noNg,
	        version: noNg,
	        resumeBootstrap: noNg,
	        getTestability: noNg
	    });
	    try {
	        if (window.hasOwnProperty('angular')) {
	            angular = ((window)).angular;
	        }
	    }
	    catch (e) {
	    }
	    var /** @type {?} */ bootstrap = angular.bootstrap;
	    var /** @type {?} */ module$1 = angular.module;
	    var /** @type {?} */ element = angular.element;

	    /**
	     * @param {?} a
	     * @param {?} b
	     * @return {?}
	     */
	    function looseIdentical(a, b) {
	        return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);
	    }

	    /**
	     * @param {?} name
	     * @return {?}
	     */
	    function controllerKey(name) {
	        return '$' + name + 'Controller';
	    }

	    var /** @type {?} */ REQUIRE_PREFIX_RE = /^(\^\^?)?(\?)?(\^\^?)?/;
	    var /** @type {?} */ NOT_SUPPORTED = 'NOT_SUPPORTED';
	    var /** @type {?} */ INITIAL_VALUE$1 = {
	        __UNINITIALIZED__: true
	    };
	    var Bindings = (function () {
	        function Bindings() {
	            this.twoWayBoundProperties = [];
	            this.twoWayBoundLastValues = [];
	            this.expressionBoundProperties = [];
	            this.propertyToOutputMap = {};
	        }
	        return Bindings;
	    }());
	    /**
	     * \@whatItDoes
	     *
	     * *Part of the [upgrade/static](/docs/ts/latest/api/#!?query=upgrade%2Fstatic)
	     * library for hybrid upgrade apps that support AoT compilation*
	     *
	     * Allows an Angular 1 component to be used from Angular 2+.
	     *
	     * \@howToUse
	     *
	     * Let's assume that you have an Angular 1 component called `ng1Hero` that needs
	     * to be made available in Angular 2+ templates.
	     *
	     * {\@example upgrade/static/ts/module.ts region="ng1-hero"}
	     *
	     * We must create a {\@link Directive} that will make this Angular 1 component
	     * available inside Angular 2+ templates.
	     *
	     * {\@example upgrade/static/ts/module.ts region="ng1-hero-wrapper"}
	     *
	     * In this example you can see that we must derive from the {\@link UpgradeComponent}
	     * base class but also provide an {\@link Directive `\@Directive`} decorator. This is
	     * because the AoT compiler requires that this information is statically available at
	     * compile time.
	     *
	     * Note that we must do the following:
	     * * specify the directive's selector (`ng1-hero`)
	     * * specify all inputs and outputs that the Angular 1 component expects
	     * * derive from `UpgradeComponent`
	     * * call the base class from the constructor, passing
	     *   * the Angular 1 name of the component (`ng1Hero`)
	     *   * the {\@link ElementRef} and {\@link Injector} for the component wrapper
	     *
	     * \@description
	     *
	     * A helper class that should be used as a base class for creating Angular directives
	     * that wrap Angular 1 components that need to be "upgraded".
	     *
	     * \@experimental
	     */
	    var UpgradeComponent = (function () {
	        /**
	         * Create a new `UpgradeComponent` instance. You should not normally need to do this.
	         * Instead you should derive a new class from this one and call the super constructor
	         * from the base class.
	         *
	         * {\@example upgrade/static/ts/module.ts region="ng1-hero-wrapper" }
	         *
	         * * The `name` parameter should be the name of the Angular 1 directive.
	         * * The `elementRef` and `injector` parameters should be acquired from Angular by dependency
	         *   injection into the base class constructor.
	         *
	         * Note that we must manually implement lifecycle hooks that call through to the super class.
	         * This is because, at the moment, the AoT compiler is not able to tell that the
	         * `UpgradeComponent`
	         * already implements them and so does not wire up calls to them at runtime.
	         * @param {?} name
	         * @param {?} elementRef
	         * @param {?} injector
	         */
	        function UpgradeComponent(name, elementRef, injector) {
	            this.name = name;
	            this.elementRef = elementRef;
	            this.injector = injector;
	            this.controllerInstance = null;
	            this.bindingDestination = null;
	            this.$injector = injector.get($INJECTOR);
	            this.$compile = this.$injector.get($COMPILE);
	            this.$templateCache = this.$injector.get($TEMPLATE_CACHE);
	            this.$httpBackend = this.$injector.get($HTTP_BACKEND);
	            this.$controller = this.$injector.get($CONTROLLER);
	            this.element = elementRef.nativeElement;
	            this.$element = element(this.element);
	            this.directive = this.getDirective(name);
	            this.bindings = this.initializeBindings(this.directive);
	            this.linkFn = this.compileTemplate(this.directive);
	            // We ask for the Angular 1 scope from the Angular 2+ injector, since
	            // we will put the new component scope onto the new injector for each component
	            var $parentScope = injector.get($SCOPE);
	            // QUESTION 1: Should we create an isolated scope if the scope is only true?
	            // QUESTION 2: Should we make the scope accessible through `$element.scope()/isolateScope()`?
	            this.$componentScope = $parentScope.$new(!!this.directive.scope);
	            var controllerType = this.directive.controller;
	            var bindToController = this.directive.bindToController;
	            if (controllerType) {
	                this.controllerInstance = this.buildController(controllerType, this.$componentScope, this.$element, this.directive.controllerAs);
	            }
	            else if (bindToController) {
	                throw new Error("Upgraded directive '" + name + "' specifies 'bindToController' but no controller.");
	            }
	            this.bindingDestination = bindToController ? this.controllerInstance : this.$componentScope;
	            this.setupOutputs();
	        }
	        /**
	         * @return {?}
	         */
	        UpgradeComponent.prototype.ngOnInit = function () {
	            var _this = this;
	            var /** @type {?} */ attrs = NOT_SUPPORTED;
	            var /** @type {?} */ transcludeFn = NOT_SUPPORTED;
	            var /** @type {?} */ directiveRequire = this.getDirectiveRequire(this.directive);
	            var /** @type {?} */ requiredControllers = this.resolveRequire(this.directive.name, this.$element, directiveRequire);
	            if (this.directive.bindToController && isMap(directiveRequire)) {
	                var /** @type {?} */ requiredControllersMap_1 = (requiredControllers);
	                Object.keys(requiredControllersMap_1).forEach(function (key) {
	                    _this.controllerInstance[key] = requiredControllersMap_1[key];
	                });
	            }
	            this.callLifecycleHook('$onInit', this.controllerInstance);
	            var /** @type {?} */ link = this.directive.link;
	            var /** @type {?} */ preLink = (typeof link == 'object') && ((link)).pre;
	            var /** @type {?} */ postLink = (typeof link == 'object') ? ((link)).post : link;
	            if (preLink) {
	                preLink(this.$componentScope, this.$element, attrs, requiredControllers, transcludeFn);
	            }
	            var /** @type {?} */ childNodes = [];
	            var /** @type {?} */ childNode;
	            while (childNode = this.element.firstChild) {
	                this.element.removeChild(childNode);
	                childNodes.push(childNode);
	            }
	            var /** @type {?} */ attachElement = function (clonedElements, scope) { _this.$element.append(clonedElements); };
	            var /** @type {?} */ attachChildNodes = function (scope, cloneAttach) { return cloneAttach(childNodes); };
	            this.linkFn(this.$componentScope, attachElement, { parentBoundTranscludeFn: attachChildNodes });
	            if (postLink) {
	                postLink(this.$componentScope, this.$element, attrs, requiredControllers, transcludeFn);
	            }
	            this.callLifecycleHook('$postLink', this.controllerInstance);
	        };
	        /**
	         * @param {?} changes
	         * @return {?}
	         */
	        UpgradeComponent.prototype.ngOnChanges = function (changes) {
	            var _this = this;
	            // Forward input changes to `bindingDestination`
	            Object.keys(changes).forEach(function (propName) { return _this.bindingDestination[propName] = changes[propName].currentValue; });
	            this.callLifecycleHook('$onChanges', this.bindingDestination, changes);
	        };
	        /**
	         * @return {?}
	         */
	        UpgradeComponent.prototype.ngDoCheck = function () {
	            var _this = this;
	            var /** @type {?} */ twoWayBoundProperties = this.bindings.twoWayBoundProperties;
	            var /** @type {?} */ twoWayBoundLastValues = this.bindings.twoWayBoundLastValues;
	            var /** @type {?} */ propertyToOutputMap = this.bindings.propertyToOutputMap;
	            twoWayBoundProperties.forEach(function (propName, idx) {
	                var /** @type {?} */ newValue = _this.bindingDestination[propName];
	                var /** @type {?} */ oldValue = twoWayBoundLastValues[idx];
	                if (!looseIdentical(newValue, oldValue)) {
	                    var /** @type {?} */ outputName = propertyToOutputMap[propName];
	                    var /** @type {?} */ eventEmitter = ((_this))[outputName];
	                    eventEmitter.emit(newValue);
	                    twoWayBoundLastValues[idx] = newValue;
	                }
	            });
	        };
	        /**
	         * @return {?}
	         */
	        UpgradeComponent.prototype.ngOnDestroy = function () {
	            this.callLifecycleHook('$onDestroy', this.controllerInstance);
	            this.$componentScope.$destroy();
	        };
	        /**
	         * @param {?} method
	         * @param {?} context
	         * @param {?=} arg
	         * @return {?}
	         */
	        UpgradeComponent.prototype.callLifecycleHook = function (method, context, arg) {
	            if (context && typeof context[method] === 'function') {
	                context[method](arg);
	            }
	        };
	        /**
	         * @param {?} name
	         * @return {?}
	         */
	        UpgradeComponent.prototype.getDirective = function (name) {
	            var /** @type {?} */ directives = this.$injector.get(name + 'Directive');
	            if (directives.length > 1) {
	                throw new Error('Only support single directive definition for: ' + this.name);
	            }
	            var /** @type {?} */ directive = directives[0];
	            if (directive.replace)
	                this.notSupported('replace');
	            if (directive.terminal)
	                this.notSupported('terminal');
	            if (directive.compile)
	                this.notSupported('compile');
	            var /** @type {?} */ link = directive.link;
	            // QUESTION: why not support link.post?
	            if (typeof link == 'object') {
	                if (((link)).post)
	                    this.notSupported('link.post');
	            }
	            return directive;
	        };
	        /**
	         * @param {?} directive
	         * @return {?}
	         */
	        UpgradeComponent.prototype.getDirectiveRequire = function (directive) {
	            var /** @type {?} */ require = directive.require || (directive.controller && directive.name);
	            if (isMap(require)) {
	                Object.keys(require).forEach(function (key) {
	                    var /** @type {?} */ value = require[key];
	                    var /** @type {?} */ match = value.match(REQUIRE_PREFIX_RE);
	                    var /** @type {?} */ name = value.substring(match[0].length);
	                    if (!name) {
	                        require[key] = match[0] + key;
	                    }
	                });
	            }
	            return require;
	        };
	        /**
	         * @param {?} directive
	         * @return {?}
	         */
	        UpgradeComponent.prototype.initializeBindings = function (directive) {
	            var _this = this;
	            var /** @type {?} */ btcIsObject = typeof directive.bindToController === 'object';
	            if (btcIsObject && Object.keys(directive.scope).length) {
	                throw new Error("Binding definitions on scope and controller at the same time is not supported.");
	            }
	            var /** @type {?} */ context = (btcIsObject) ? directive.bindToController : directive.scope;
	            var /** @type {?} */ bindings = new Bindings();
	            if (typeof context == 'object') {
	                Object.keys(context).forEach(function (propName) {
	                    var /** @type {?} */ definition = context[propName];
	                    var /** @type {?} */ bindingType = definition.charAt(0);
	                    // QUESTION: What about `=*`? Ignore? Throw? Support?
	                    switch (bindingType) {
	                        case '@':
	                        case '<':
	                            // We don't need to do anything special. They will be defined as inputs on the
	                            // upgraded component facade and the change propagation will be handled by
	                            // `ngOnChanges()`.
	                            break;
	                        case '=':
	                            bindings.twoWayBoundProperties.push(propName);
	                            bindings.twoWayBoundLastValues.push(INITIAL_VALUE$1);
	                            bindings.propertyToOutputMap[propName] = propName + 'Change';
	                            break;
	                        case '&':
	                            bindings.expressionBoundProperties.push(propName);
	                            bindings.propertyToOutputMap[propName] = propName;
	                            break;
	                        default:
	                            var /** @type {?} */ json = JSON.stringify(context);
	                            throw new Error("Unexpected mapping '" + bindingType + "' in '" + json + "' in '" + _this.name + "' directive.");
	                    }
	                });
	            }
	            return bindings;
	        };
	        /**
	         * @param {?} directive
	         * @return {?}
	         */
	        UpgradeComponent.prototype.compileTemplate = function (directive) {
	            if (this.directive.template !== undefined) {
	                return this.compileHtml(getOrCall(this.directive.template));
	            }
	            else if (this.directive.templateUrl) {
	                var /** @type {?} */ url = getOrCall(this.directive.templateUrl);
	                var /** @type {?} */ html = (this.$templateCache.get(url));
	                if (html !== undefined) {
	                    return this.compileHtml(html);
	                }
	                else {
	                    throw new Error('loading directive templates asynchronously is not supported');
	                }
	            }
	            else {
	                throw new Error("Directive '" + this.name + "' is not a component, it is missing template.");
	            }
	        };
	        /**
	         * @param {?} controllerType
	         * @param {?} $scope
	         * @param {?} $element
	         * @param {?} controllerAs
	         * @return {?}
	         */
	        UpgradeComponent.prototype.buildController = function (controllerType, $scope, $element, controllerAs) {
	            // TODO: Document that we do not pre-assign bindings on the controller instance
	            var /** @type {?} */ locals = { $scope: $scope, $element: $element };
	            var /** @type {?} */ controller = this.$controller(controllerType, locals, null, controllerAs);
	            $element.data(controllerKey(this.directive.name), controller);
	            return controller;
	        };
	        /**
	         * @param {?} directiveName
	         * @param {?} $element
	         * @param {?} require
	         * @return {?}
	         */
	        UpgradeComponent.prototype.resolveRequire = function (directiveName, $element, require) {
	            var _this = this;
	            if (!require) {
	                return null;
	            }
	            else if (Array.isArray(require)) {
	                return require.map(function (req) { return _this.resolveRequire(directiveName, $element, req); });
	            }
	            else if (typeof require === 'object') {
	                var /** @type {?} */ value_1 = {};
	                Object.keys(require).forEach(function (key) { return value_1[key] = _this.resolveRequire(directiveName, $element, require[key]); });
	                return value_1;
	            }
	            else if (typeof require === 'string') {
	                var /** @type {?} */ match = require.match(REQUIRE_PREFIX_RE);
	                var /** @type {?} */ inheritType = match[1] || match[3];
	                var /** @type {?} */ name_1 = require.substring(match[0].length);
	                var /** @type {?} */ isOptional = !!match[2];
	                var /** @type {?} */ searchParents = !!inheritType;
	                var /** @type {?} */ startOnParent = inheritType === '^^';
	                var /** @type {?} */ ctrlKey = controllerKey(name_1);
	                if (startOnParent) {
	                    $element = $element.parent();
	                }
	                var /** @type {?} */ value = searchParents ? $element.inheritedData(ctrlKey) : $element.data(ctrlKey);
	                if (!value && !isOptional) {
	                    throw new Error("Unable to find required '" + require + "' in upgraded directive '" + directiveName + "'.");
	                }
	                return value;
	            }
	            else {
	                throw new Error("Unrecognized require syntax on upgraded directive '" + directiveName + "': " + require);
	            }
	        };
	        /**
	         * @return {?}
	         */
	        UpgradeComponent.prototype.setupOutputs = function () {
	            var _this = this;
	            // Set up the outputs for `=` bindings
	            this.bindings.twoWayBoundProperties.forEach(function (propName) {
	                var /** @type {?} */ outputName = _this.bindings.propertyToOutputMap[propName];
	                ((_this))[outputName] = new _angular_core.EventEmitter();
	            });
	            // Set up the outputs for `&` bindings
	            this.bindings.expressionBoundProperties.forEach(function (propName) {
	                var /** @type {?} */ outputName = _this.bindings.propertyToOutputMap[propName];
	                var /** @type {?} */ emitter = ((_this))[outputName] = new _angular_core.EventEmitter();
	                // QUESTION: Do we want the ng1 component to call the function with `<value>` or with
	                //           `{$event: <value>}`. The former is closer to ng2, the latter to ng1.
	                _this.bindingDestination[propName] = function (value) { return emitter.emit(value); };
	            });
	        };
	        /**
	         * @param {?} feature
	         * @return {?}
	         */
	        UpgradeComponent.prototype.notSupported = function (feature) {
	            throw new Error("Upgraded directive '" + this.name + "' contains unsupported feature: '" + feature + "'.");
	        };
	        /**
	         * @param {?} html
	         * @return {?}
	         */
	        UpgradeComponent.prototype.compileHtml = function (html) {
	            var /** @type {?} */ div = document.createElement('div');
	            div.innerHTML = html;
	            return this.$compile(div.childNodes);
	        };
	        return UpgradeComponent;
	    }());
	    /**
	     * @param {?} property
	     * @return {?}
	     */
	    function getOrCall(property) {
	        return typeof (property) === 'function' ? property() : property;
	    }
	    /**
	     * @param {?} value
	     * @return {?}
	     */
	    function isMap(value) {
	        return value && !Array.isArray(value) && typeof value === 'object';
	    }

	    /**
	     * @license
	     * Copyright Google Inc. All Rights Reserved.
	     *
	     * Use of this source code is governed by an MIT-style license that can be
	     * found in the LICENSE file at https://angular.io/license
	     */
	    // We have to do a little dance to get the ng1 injector into the module injector.
	    // We store the ng1 injector so that the provider in the module injector can access it
	    // Then we "get" the ng1 injector from the module injector, which triggers the provider to read
	    // the stored injector and release the reference to it.
	    var /** @type {?} */ tempInjectorRef;
	    /**
	     * @param {?} injector
	     * @return {?}
	     */
	    function setTempInjectorRef(injector) {
	        tempInjectorRef = injector;
	    }
	    /**
	     * @return {?}
	     */
	    function injectorFactory() {
	        var /** @type {?} */ injector = tempInjectorRef;
	        tempInjectorRef = null; // clear the value to prevent memory leaks
	        return injector;
	    }
	    /**
	     * @param {?} i
	     * @return {?}
	     */
	    function rootScopeFactory(i) {
	        return i.get('$rootScope');
	    }
	    /**
	     * @param {?} i
	     * @return {?}
	     */
	    function compileFactory(i) {
	        return i.get('$compile');
	    }
	    /**
	     * @param {?} i
	     * @return {?}
	     */
	    function parseFactory(i) {
	        return i.get('$parse');
	    }
	    var /** @type {?} */ angular1Providers = [
	        // We must use exported named functions for the ng2 factories to keep the compiler happy:
	        // > Metadata collected contains an error that will be reported at runtime:
	        // >   Function calls are not supported.
	        // >   Consider replacing the function or lambda with a reference to an exported function
	        { provide: '$injector', useFactory: injectorFactory },
	        { provide: '$rootScope', useFactory: rootScopeFactory, deps: ['$injector'] },
	        { provide: '$compile', useFactory: compileFactory, deps: ['$injector'] },
	        { provide: '$parse', useFactory: parseFactory, deps: ['$injector'] }
	    ];

	    /**
	     * \@whatItDoes
	     *
	     * *Part of the [upgrade/static](/docs/ts/latest/api/#!?query=upgrade%2Fstatic)
	     * library for hybrid upgrade apps that support AoT compilation*
	     *
	     * Allows Angular 1 and Angular 2+ components to be used together inside a hybrid upgrade
	     * application, which supports AoT compilation.
	     *
	     * Specifically, the classes and functions in the `upgrade/static` module allow the following:
	     * 1. Creation of an Angular 2+ directive that wraps and exposes an Angular 1 component so
	     *    that it can be used in an Angular 2 template. See {\@link UpgradeComponent}.
	     * 2. Creation of an Angular 1 directive that wraps and exposes an Angular 2+ component so
	     *    that it can be used in an Angular 1 template. See {\@link downgradeComponent}.
	     * 3. Creation of an Angular 2+ root injector provider that wraps and exposes an Angular 1
	     *    service so that it can be injected into an Angular 2+ context. See
	     *    {\@link UpgradeModule#upgrading-an-angular-1-service Upgrading an Angular 1 service} below.
	     * 4. Creation of an Angular 1 service that wraps and exposes an Angular 2+ injectable
	     *    so that it can be injected into an Angular 1 context. See {\@link downgradeInjectable}.
	     * 3. Bootstrapping of a hybrid Angular application which contains both of the frameworks
	     *    coexisting in a single application. See the
	     *    {\@link UpgradeModule#example example} below.
	     *
	     * ## Mental Model
	     *
	     * When reasoning about how a hybrid application works it is useful to have a mental model which
	     * describes what is happening and explains what is happening at the lowest level.
	     *
	     * 1. There are two independent frameworks running in a single application, each framework treats
	     *    the other as a black box.
	     * 2. Each DOM element on the page is owned exactly by one framework. Whichever framework
	     *    instantiated the element is the owner. Each framework only updates/interacts with its own
	     *    DOM elements and ignores others.
	     * 3. Angular 1 directives always execute inside the Angular 1 framework codebase regardless of
	     *    where they are instantiated.
	     * 4. Angular 2+ components always execute inside the Angular 2+ framework codebase regardless of
	     *    where they are instantiated.
	     * 5. An Angular 1 component can be "upgraded"" to an Angular 2+ component. This is achieved by
	     *    defining an Angular 2+ directive, which bootstraps the Angular 1 component at its location
	     *    in the DOM. See {\@link UpgradeComponent}.
	     * 6. An Angular 2+ component can be "downgraded"" to an Angular 1 component. This is achieved by
	     *    defining an Angular 1 directive, which bootstraps the Angular 2+ component at its location
	     *    in the DOM. See {\@link downgradeComponent}.
	     * 7. Whenever an "upgraded"/"downgraded" component is instantiated the host element is owned by
	     *    the framework doing the instantiation. The other framework then instantiates and owns the
	     *    view for that component.
	     *    a. This implies that the component bindings will always follow the semantics of the
	     *       instantiation framework.
	     *    b. The DOM attributes are parsed by the framework that owns the current template. So
	     * attributes
	     *       in Angular 1 templates must use kebab-case, while Angular 1 templates must use camelCase.
	     *    c. However the template binding syntax will always use the Angular 2+ style, e.g. square
	     *       brackets (`[...]`) for property binding.
	     * 8. Angular 1 is always bootstrapped first and owns the root component.
	     * 9. The new application is running in an Angular 2+ zone, and therefore it no longer needs calls
	     * to
	     *    `$apply()`.
	     *
	     * \@howToUse
	     *
	     * `import {UpgradeModule} from '\@angular/upgrade/static';`
	     *
	     * ## Example
	     * Import the {\@link UpgradeModule} into your top level {\@link NgModule Angular 2+ `NgModule`}.
	     *
	     * {\@example upgrade/static/ts/module.ts region='ng2-module'}
	     *
	     * Then bootstrap the hybrid upgrade app's module, get hold of the {\@link UpgradeModule} instance
	     * and use it to bootstrap the top level [Angular 1
	     * module](https://docs.angularjs.org/api/ng/type/angular.Module).
	     *
	     * {\@example upgrade/static/ts/module.ts region='bootstrap'}
	     *
	     *
	     * ## Upgrading an Angular 1 service
	     *
	     * There is no specific API for upgrading an Angular 1 service. Instead you should just follow the
	     * following recipe:
	     *
	     * Let's say you have an Angular 1 service:
	     *
	     * {\@example upgrade/static/ts/module.ts region="ng1-title-case-service"}
	     *
	     * Then you should define an Angular 2+ provider to be included in your {\@link NgModule} `providers`
	     * property.
	     *
	     * {\@example upgrade/static/ts/module.ts region="upgrade-ng1-service"}
	     *
	     * Then you can use the "upgraded" Angular 1 service by injecting it into an Angular 2 component
	     * or service.
	     *
	     * {\@example upgrade/static/ts/module.ts region="use-ng1-upgraded-service"}
	     *
	     * \@description
	     *
	     * This class is an `NgModule`, which you import to provide Angular 1 core services,
	     * and has an instance method used to bootstrap the hybrid upgrade application.
	     *
	     * ## Core Angular 1 services
	     * Importing this {\@link NgModule} will add providers for the core
	     * [Angular 1 services](https://docs.angularjs.org/api/ng/service) to the root injector.
	     *
	     * ## Bootstrap
	     * The runtime instance of this class contains a {\@link UpgradeModule#bootstrap `bootstrap()`}
	     * method, which you use to bootstrap the top level Angular 1 module onto an element in the
	     * DOM for the hybrid upgrade app.
	     *
	     * It also contains properties to access the {\@link UpgradeModule#injector root injector}, the
	     * bootstrap {\@link NgZone} and the
	     * [Angular 1 $injector](https://docs.angularjs.org/api/auto/service/$injector).
	     *
	     * \@experimental
	     */
	    var UpgradeModule = (function () {
	        /**
	         * @param {?} injector
	         * @param {?} ngZone
	         */
	        function UpgradeModule(injector, ngZone) {
	            this.injector = injector;
	            this.ngZone = ngZone;
	        }
	        /**
	         * Bootstrap an Angular 1 application from this NgModule
	         * @param {?} element the element on which to bootstrap the Angular 1 application
	         * @param {?=} modules
	         * @param {?=} config
	         * @return {?}
	         */
	        UpgradeModule.prototype.bootstrap = function (element$$, modules, config /*angular.IAngularBootstrapConfig*/) {
	            var _this = this;
	            if (modules === void 0) { modules = []; }
	            // Create an ng1 module to bootstrap
	            var /** @type {?} */ upgradeModule = module$1(UPGRADE_MODULE_NAME, modules)
	                .value(INJECTOR_KEY, this.injector)
	                .config([
	                $PROVIDE, $INJECTOR,
	                function ($provide, $injector) {
	                    if ($injector.has($$TESTABILITY)) {
	                        $provide.decorator($$TESTABILITY, [
	                            $DELEGATE,
	                            function (testabilityDelegate) {
	                                var /** @type {?} */ originalWhenStable = testabilityDelegate.whenStable;
	                                var /** @type {?} */ injector = _this.injector;
	                                // Cannot use arrow function below because we need the context
	                                var /** @type {?} */ newWhenStable = function (callback) {
	                                    originalWhenStable.call(this, function () {
	                                        var /** @type {?} */ ng2Testability = injector.get(_angular_core.Testability);
	                                        if (ng2Testability.isStable()) {
	                                            callback.apply(this, arguments);
	                                        }
	                                        else {
	                                            ng2Testability.whenStable(newWhenStable.bind(this, callback));
	                                        }
	                                    });
	                                };
	                                testabilityDelegate.whenStable = newWhenStable;
	                                return testabilityDelegate;
	                            }
	                        ]);
	                    }
	                }
	            ])
	                .run([
	                $INJECTOR,
	                function ($injector) {
	                    _this.$injector = $injector;
	                    // Initialize the ng1 $injector provider
	                    setTempInjectorRef($injector);
	                    _this.injector.get($INJECTOR);
	                    // Put the injector on the DOM, so that it can be "required"
	                    element(element$$).data(controllerKey(INJECTOR_KEY), _this.injector);
	                    // Wire up the ng1 rootScope to run a digest cycle whenever the zone settles
	                    var /** @type {?} */ $rootScope = $injector.get('$rootScope');
	                    _this.ngZone.onMicrotaskEmpty.subscribe(function () { return _this.ngZone.runOutsideAngular(function () { return $rootScope.$evalAsync(); }); });
	                }
	            ]);
	            // Make sure resumeBootstrap() only exists if the current bootstrap is deferred
	            var /** @type {?} */ windowAngular = ((window) /** TODO #???? */)['angular'];
	            windowAngular.resumeBootstrap = undefined;
	            // Bootstrap the angular 1 application inside our zone
	            this.ngZone.run(function () { bootstrap(element$$, [upgradeModule.name], config); });
	            // Patch resumeBootstrap() to run inside the ngZone
	            if (windowAngular.resumeBootstrap) {
	                var /** @type {?} */ originalResumeBootstrap_1 = windowAngular.resumeBootstrap;
	                var /** @type {?} */ ngZone_1 = this.ngZone;
	                windowAngular.resumeBootstrap = function () {
	                    var _this = this;
	                    var /** @type {?} */ args = arguments;
	                    windowAngular.resumeBootstrap = originalResumeBootstrap_1;
	                    ngZone_1.run(function () { windowAngular.resumeBootstrap.apply(_this, args); });
	                };
	            }
	        };
	        UpgradeModule.decorators = [
	            { type: _angular_core.NgModule, args: [{ providers: angular1Providers },] },
	        ];
	        /** @nocollapse */
	        UpgradeModule.ctorParameters = function () { return [
	            { type: _angular_core.Injector, },
	            { type: _angular_core.NgZone, },
	        ]; };
	        return UpgradeModule;
	    }());

	    exports.downgradeComponent = downgradeComponent;
	    exports.downgradeInjectable = downgradeInjectable;
	    exports.UpgradeComponent = UpgradeComponent;
	    exports.UpgradeModule = UpgradeModule;

	}));

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./actBulkSrvc.js": 50,
		"./affiliationsSrvc.js": 51,
		"./bioBulkSrvc.js": 52,
		"./commonSrvc.js": 53,
		"./fundingSrvc.js": 54,
		"./groupedActivitiesService.js": 55,
		"./groupedActivitiesUtil.js": 56,
		"./initialConfigService.js": 57,
		"./notificationsSrvc.js": 58,
		"./utilsService.js": 59,
		"./workspaceSrvc.js": 60
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 49;


/***/ },
/* 50 */
/***/ function(module, exports) {

	angular.module('orcidApp').factory("actBulkSrvc", ['$rootScope', function ($rootScope) {
	    var actBulkSrvc = {
	        initScope: function($scope) {
	            $scope.bulkEditShow = false;
	            $scope.bulkEditMap = {};
	            $scope.bulkChecked = false;
	            $scope.bulkDisplayToggle = false;
	            $scope.toggleSelectMenu = function(){                   
	                $scope.bulkDisplayToggle = !$scope.bulkDisplayToggle;                    
	            };
	        }
	    };
	    return actBulkSrvc;
	}]);

/***/ },
/* 51 */
/***/ function(module, exports) {

	angular.module('orcidApp').factory("affiliationsSrvc", ['$rootScope', function ($rootScope) {
	    var serv = {
	        educations: new Array(),
	        employments: new Array(),
	        loading: false,
	        affiliationsToAddIds: null,
	        
	        addAffiliationToScope: function(path) {
	            if( serv.affiliationsToAddIds.length != 0 ) {
	                var affiliationIds = serv.affiliationsToAddIds.splice(0,20).join();
	                var url = getBaseUri() + '/' + path + '?affiliationIds=' + affiliationIds;                
	                $.ajax({
	                    url: url,                        
	                    headers : {'Content-Type': 'application/json'},
	                    method: 'GET',
	                    success: function(data) {
	                        for (i in data) {
	                            if (data[i].affiliationType != null && data[i].affiliationType.value != null
	                                    && data[i].affiliationType.value == 'education'){
	                                groupedActivitiesUtil.group(data[i],GroupedActivities.AFFILIATION,serv.educations);
	                            }
	                            else if (data[i].affiliationType != null && data[i].affiliationType.value != null
	                                    && data[i].affiliationType.value == 'employment'){
	                                groupedActivitiesUtil.group(data[i],GroupedActivities.AFFILIATION,serv.employments);
	                            }
	                        };
	                        if (serv.affiliationsToAddIds.length == 0) {
	                            serv.loading = false;
	                            $rootScope.$apply();
	                        } else {
	                            $rootScope.$apply();
	                            setTimeout(
	                                function () {
	                                    serv.addAffiliationToScope(path);
	                                },
	                                50
	                            );
	                        }
	                    }
	                }).fail(function(e) {
	                    console.log("Error adding affiliations to scope")
	                    logAjaxError(e);
	                });
	            } else {
	                serv.loading = false;
	            };
	        },
	        setIdsToAdd: function(ids) {
	            serv.affiliationsToAddIds = ids;
	        },
	        getAffiliations: function(path) {
	            //clear out current affiliations
	            serv.loading = true;
	            serv.affiliationsToAddIds = null;
	            serv.educations.length = 0;
	            serv.employments.length = 0;
	            //get affiliation ids
	            $.ajax({
	                url: getBaseUri() + '/' + path,
	                dataType: 'json',
	                success: function(data) {
	                    serv.affiliationsToAddIds = data;
	                    serv.addAffiliationToScope('affiliations/affiliations.json');
	                    $rootScope.$apply();
	                }
	            }).fail(function(e){
	                // something bad is happening!
	                console.log("error fetching affiliations");
	                logAjaxError(e);
	            });
	        },
	        updateProfileAffiliation: function(aff) {
	            $.ajax({
	                url: getBaseUri() + '/affiliations/affiliation.json',
	                type: 'PUT',
	                data: angular.toJson(aff),
	                contentType: 'application/json;charset=UTF-8',
	                dataType: 'json',
	                success: function(data) {
	                    if(data.errors.length != 0){
	                        console.log("Unable to update profile affiliation.");
	                    }
	                    $rootScope.$apply();
	                }
	            }).fail(function() {
	                console.log("Error updating profile affiliation.");
	            });
	        },
	        deleteAffiliation: function(affiliation) {
	            var arr = null;
	            var idx;
	            if (affiliation.affiliationType != null && affiliation.affiliationType.value != null
	                    && affiliation.affiliationType.value == 'education'){
	                arr = serv.educations;
	            }
	            if (affiliation.affiliationType != null && affiliation.affiliationType.value != null
	                    && affiliation.affiliationType.value == 'employment'){
	                arr = serv.employments;
	            }
	            for (idx in arr) {
	                if (arr[idx].activePutCode == affiliation.putCode.value) {
	                    break;
	                }
	            }
	            arr.splice(idx, 1);
	            $.ajax({
	                url: getBaseUri() + '/affiliations/affiliations.json',
	                type: 'DELETE',
	                data: angular.toJson(affiliation),
	                contentType: 'application/json;charset=UTF-8',
	                dataType: 'json',
	                success: function(data) {
	                    if(data.errors.length != 0){
	                        console.log("Unable to delete affiliation.");
	                    }
	                    $rootScope.$apply();
	                }
	            }).fail(function() {
	                console.log("Error deleting affiliation.");
	            });
	        }
	    };
	    return serv;
	}]);

/***/ },
/* 52 */
/***/ function(module, exports) {

	angular.module('orcidApp').factory("bioBulkSrvc", ['$rootScope', function ($rootScope) {
	    var bioBulkSrvc = {
	        initScope: function($scope) {
	            $scope.bioModel = null; //Dummy model to avoid bulk privacy selector fail
	            $scope.bulkEditShow = false;
	            $scope.bulkEditMap = {};
	            $scope.bulkChecked = false;
	            $scope.bulkDisplayToggle = false;
	            $scope.toggleSelectMenu = function(){               
	                $scope.bulkDisplayToggle = !$scope.bulkDisplayToggle;                    
	            };
	        }
	    };
	    return bioBulkSrvc;
	}]);

/***/ },
/* 53 */
/***/ function(module, exports) {

	angular.module('orcidApp').factory("commonSrvc", ['$rootScope', '$window', function ($rootScope, $window) {
	    var commonSrvc = {
	        copyErrorsLeft: function (data1, data2) {
	            for (var key in data1) {
	                if (key == 'errors') {
	                    data1.errors = data2.errors;
	                } else {
	                    if (data1[key] != null && data1[key].errors !== undefined) {
	                        data1[key].errors = data2[key].errors;
	                    }
	                };
	            };
	        },
	        shownElement: [],        
	        showPrivacyHelp: function(elem, event, offsetArrow){
	            var top = angular.element(event.target.parentNode).parent().prop('offsetTop');
	            var left = angular.element(event.target.parentNode).parent().prop('offsetLeft');
	            var scrollTop = angular.element('.fixed-area').scrollTop();
	            
	            if (elem === '-privacy'){
	                angular.element('.edit-record .bulk-privacy-bar .popover-help-container').css({
	                    top: -75,
	                    left: 512
	                });
	            }else{
	                if (elem.indexOf('@') > -1) {
	                    left = 530; //Emails modal fix
	                }
	                angular.element('.edit-record .record-settings .popover-help-container').css({
	                    top: top - scrollTop - 160,
	                    left: left + 25
	                });             
	            }
	            angular.element('.edit-record .record-settings .popover-help-container .arrow').css({                    
	                left: offsetArrow
	            }); 
	            commonSrvc.shownElement[elem] = true;
	        },
	        showTooltip: function(elem, event, topOffset, leftOffset, arrowOffset){
	            var top = angular.element(event.target.parentNode).parent().prop('offsetTop');
	            var left = angular.element(event.target.parentNode).parent().prop('offsetLeft');    
	            var scrollTop = angular.element('.fixed-area').scrollTop();
	            
	            angular.element('.edit-record .popover-tooltip').css({
	                top: top - scrollTop - topOffset,
	                left: left + leftOffset
	            });
	            
	            angular.element('.edit-record .popover-tooltip .arrow').css({                
	                left: arrowOffset
	            });            
	            
	            commonSrvc.shownElement[elem] = true;
	       },
	       hideTooltip: function(elem){
	           commonSrvc.shownElement[elem] = false;
	       }
	    };
	    return commonSrvc;
	}]);

/***/ },
/* 54 */
/***/ function(module, exports) {

	/**
	 * Fundings Service
	 * */
	angular.module('orcidApp').factory("fundingSrvc", ['$rootScope', function ($rootScope) {
	    var fundingSrvc = {
	        constants: { 'access_type': { 'USER': 'user', 'ANONYMOUS': 'anonymous'}},
	        fundings: new Array(),
	        fundingToAddIds: null,
	        groups: new Array(),
	        loading: false,
	        moreDetailsActive: false,
	        
	        addFundingToScope: function(path) {
	            if( fundingSrvc.fundingToAddIds.length != 0 ) {
	                var fundingIds = fundingSrvc.fundingToAddIds.splice(0,20).join();
	                $.ajax({
	                    url: getBaseUri() + '/' + path + '?fundingIds=' + fundingIds,
	                    dataType: 'json',
	                    success: function(data) {
	                        for (var i in data) {
	                            var funding = data[i];
	                            groupedActivitiesUtil.group(funding,GroupedActivities.FUNDING,fundingSrvc.groups);
	                        };
	                        if (fundingSrvc.fundingToAddIds.length == 0) {
	                            fundingSrvc.loading = false;
	                            $rootScope.$apply();
	                        } else {
	                            $rootScope.$apply();
	                            setTimeout(function () {
	                                fundingSrvc.addFundingToScope(path);
	                            },50);
	                        }
	                    }
	                }).fail(function(e) {
	                    console.log("Error fetching fundings");
	                    logAjaxError(e);
	                });
	            } else {
	                fundingSrvc.loading = false;
	            };
	        },
	        createNew: function(work) {
	            var cloneF = JSON.parse(JSON.stringify(work));
	            cloneF.source = null;
	            cloneF.putCode = null;
	            for (var idx in cloneF.externalIdentifiers){
	                cloneF.externalIdentifiers[idx].putCode = null;
	            }
	            return cloneF;
	        },
	        getEditable: function(putCode, callback) {
	            // first check if they are the current source
	            var funding = fundingSrvc.getFunding(putCode);
	            if (funding.source == orcidVar.orcidId){
	                callback(funding);
	            }
	            else {
	                var bestMatch = null;
	                var group = fundingSrvc.getGroup(putCode);
	                for (var idx in group.activitiess) {
	                    if (group[idx].source == orcidVar.orcidId) {
	                        bestMatch = callback(group[idx]);
	                        break;
	                    }
	                }
	                if (bestMatch == null) {
	                    bestMatch = fundingSrvc.createNew(funding);
	                }
	                callback(bestMatch);
	            };
	        },
	        deleteFunding: function(putCode) {
	            var rmFunding;
	            for (var idx in fundingSrvc.groups) {
	                if (fundingSrvc.groups[idx].hasPut(putCode)) {
	                    rmFunding = fundingSrvc.groups[idx].getByPut(putCode);
	                    break;
	                };
	            };
	            // remove work on server
	            fundingSrvc.removeFunding(rmFunding);
	        },
	        deleteGroupFunding: function(putCode) {
	            var idx;
	            var rmWorks;
	            for (var idx in fundingSrvc.groups) {
	                if (fundingSrvc.groups[idx].hasPut(putCode)) {
	                   for (var idj in fundingSrvc.groups[idx].activities) {
	                       fundingSrvc.removeFunding(fundingSrvc.groups[idx].activities[idj]);
	                    }
	                    fundingSrvc.groups.splice(idx,1);
	                    break;
	                }
	            }
	        },
	        fundingCount: function() {
	            var count = 0;
	            for (var idx in fundingSrvc.groups) {
	                count += fundingSrvc.groups[idx].activitiesCount;
	            }
	            return count;
	        },
	        getFunding: function(putCode) {
	            for (var idx in fundingSrvc.groups) {
	                if (fundingSrvc.groups[idx].hasPut(putCode)){
	                    return fundingSrvc.groups[idx].getByPut(putCode);
	                }
	            }
	            return null;
	        },
	        getFundings: function(path) {
	            //clear out current fundings
	            fundingSrvc.loading = true;
	            fundingSrvc.fundingToAddIds = null;
	            //new way
	            fundingSrvc.groups.length = 0;
	            //get funding ids
	            $.ajax({
	                url: getBaseUri() + '/'  + path,
	                dataType: 'json',
	                success: function(data) {
	                    fundingSrvc.fundingToAddIds = data;
	                    fundingSrvc.addFundingToScope('fundings/fundings.json');
	                    $rootScope.$apply();
	                }
	            }).fail(function(e){
	                // something bad is happening!
	                console.log("error fetching fundings");
	                logAjaxError(e);
	            });
	        },
	        getGroup: function(putCode) {
	            for (var idx in fundingSrvc.groups) {
	                if (fundingSrvc.groups[idx].hasPut(putCode)){
	                    return fundingSrvc.groups[idx];
	                }
	            }
	            return null;
	        },
	        makeDefault: function(group, putCode) {
	            group.makeDefault(putCode);
	            $.ajax({
	                url: getBaseUri() + '/fundings/updateToMaxDisplay.json?putCode=' + putCode,
	                dataType: 'json',
	                success: function(data) {
	                }
	            }).fail(function(){
	                // something bad is happening!
	                console.log("some bad is hppending");
	            });
	        },
	        removeFunding: function(funding) {
	            $.ajax({
	                url: getBaseUri() + '/fundings/funding.json',
	                type: 'DELETE',
	                data: angular.toJson(funding),
	                contentType: 'application/json;charset=UTF-8',
	                dataType: 'json',
	                success: function(data) {
	                    if (data.errors.length != 0){
	                       console.log("Unable to delete funding.");
	                    }
	                    else{
	                       groupedActivitiesUtil.rmByPut(funding.putCode.value, GroupedActivities.FUNDING,fundingSrvc.groups);
	                    }
	                    $rootScope.$apply();
	                }
	            }).fail(function() {
	                console.log("Error deleting funding.");
	            });
	        },
	        setIdsToAdd: function(ids) {
	            fundingSrvc.fundingToAddIds = ids;
	        },
	        setGroupPrivacy: function(putCode, priv) {
	            var group = fundingSrvc.getGroup(putCode);
	            for (var idx in group.activities) {
	                var curPutCode = group.activities[idx].putCode.value;
	                fundingSrvc.setPrivacy(curPutCode, priv);
	            }
	        },
	        setPrivacy: function(putCode, priv) {
	            var funding = fundingSrvc.getFunding(putCode);
	            funding.visibility.visibility = priv;
	            fundingSrvc.updateProfileFunding(funding);
	        },
	        updateProfileFunding: function(funding) {
	            $.ajax({
	                url: getBaseUri() + '/fundings/funding.json',
	                type: 'PUT',
	                data: angular.toJson(funding),
	                contentType: 'application/json;charset=UTF-8',
	                dataType: 'json',
	                success: function(data) {
	                    if(data.errors.length != 0){
	                        console.log("Unable to update profile funding.");
	                    }
	                    $rootScope.$apply();
	                }
	            }).fail(function() {
	                console.log("Error updating profile funding.");
	            });
	        }
	    };
	    return fundingSrvc;
	}]);

/***/ },
/* 55 */
/***/ function(module, exports) {

	angular.module('orcidApp').factory(
	    'GroupedActivities', 
	    function( type ) {
	        var GroupedActivities = {
	            _keySet : {},
	            ABBR_WORK : 'abbrWork',
	            activePutCode : null,
	            activities : {},
	            activitiesCount : 0,
	            AFFILIATION : 'affiliation',
	            count : 0,
	            dateSortString : null,
	            defaultPutCode : null,
	            FUNDING : 'funding',
	            groupDescription : null,
	            groupId : this.count,
	            groupRealId : null,
	            groupType : null,
	            PEER_REVIEW : 'peerReview',
	            title : null,
	            type : type,

	            add: function( activity ){
	                // assumes works are added in the order of the display index desc
	                // subsorted by the created date asc
	                var identifiersPath = null;
	                identifiersPath = this.getIdentifiersPath();        

	                if(this.type == GroupedActivities.PEER_REVIEW) {    
	                    var key = this.key(activity[identifiersPath]);
	                    this.addKey(key);
	                } else {
	                    for (var idx in activity[identifiersPath]) {
	                        this.addKey(this.key(activity[identifiersPath][idx]));
	                    }
	                }    

	                this.activities[activity.putCode.value] = activity;
	                if (this.defaultPutCode == null) {
	                    this.activePutCode = activity.putCode.value;
	                    this.makeDefault(activity.putCode.value);
	                }
	                this.activitiesCount++;
	            },

	            addKey : function(key) {
	                if (this.hasKey(key)){
	                    return;
	                } 
	                this._keySet[key] = true;
	                if (this.type == GroupedActivities.PEER_REVIEW) {
	                    this.groupRealId = key;
	                }
	                return;
	            },

	            consistentVis : function() {
	                var vis = null;
	                if (this.type == GroupedActivities.FUNDING)
	                    vis = this.getDefault().visibility.visibility;
	                else
	                    vis = this.getDefault().visibility;

	                for (var idx in this.activities) {
	                    if (this.type == GroupedActivities.FUNDING) {
	                        if (this.activities[idx].visibility.visibility != vis){
	                            return false;
	                        }
	                    } else {
	                        if (this.activities[idx].visibility != vis) {
	                            return false;
	                        }
	                    }
	                }
	                return true;
	            },

	            getActive : function() {
	                return this.activities[this.activePutCode];
	            },

	            getByPut : function(putCode) {
	                return this.activities[putCode];
	            },

	            getDefault : function() {
	                return this.activities[this.defaultPutCode];
	            },

	            getIdentifiersPath : function() {
	                if (this.type == GroupedActivities.ABBR_WORK) {
	                    return 'workExternalIdentifiers';
	                }
	                if (this.type == GroupedActivities.PEER_REVIEW) {
	                    return 'groupId';
	                } 
	                return 'externalIdentifiers';
	            },

	            getInstantiateCount: function() {
	                var id = 0; // This is the private persistent value
	                // The outer function returns a nested function that has access
	                // to the persistent value.  It is this nested function we're storing
	                // in the variable uniqueID above.
	                return function() { 
	                    return id++; 
	                };  // Return and increment
	            }
	        };
	        return GroupedActivities;
	    }
	);


/***/ },
/* 56 */
/***/ function(module, exports) {

	/*
	angular.module('orcidApp').factory(
	    'GroupedActivitiesUtil', 
	    function() {
	        var GroupedActivitiesUtil = {
	            group: function( activity, type, groupsArray ) {
	                var matches = new Array();
	                // there are no possible keys for affiliations    
	                if (type != GroupedActivities.AFFILIATION);
	                   for (var idx in groupsArray) {          
	                       if (groupsArray[idx].keyMatch(activity))
	                           matches.push(groupsArray[idx]);
	                   }           
	                if (matches.length == 0) {
	                    var newGroup = new GroupedActivities(type);
	                    newGroup.add(activity);
	                    groupsArray.push(newGroup);
	                }  else {
	                    var firstMatch = matches.shift();
	                    firstMatch.add(activity);
	                    // combine any remaining groups into the first group we found.
	                    for (var idx in matches) {
	                        var matchIndex = groupsArray.indexOf(matches[idx]);
	                        var curMatch = groupsArray[matchIndex];
	                        for (var idj in curMatch.activities)
	                            firstMatch.add(curMatch.activities[idj]);
	                        groupsArray.splice(matchIndex, 1);
	                    }
	                }
	            },

	            rmByPut: function( putCode, type, groupsArray ) {
	                for (var idx in groupsArray) {
	                    if (groupsArray[idx].hasPut(putCode)) {
	                       groupsArray[idx].rmByPut(putCode);
	                       if (groupsArray[idx].activitiesCount == 0)
	                           groupsArray.splice(idx,1);
	                       else {
	                           var orphans = groupsArray[idx].unionCheck();
	                           for (var idj in orphans)
	                               groupedActivitiesUtil.group(orphans[idj], type, groupsArray);
	                       }
	                    }
	                }
	            }
	        };
	        return GroupedActivitiesUtil;
	    }
	);
	*/

/***/ },
/* 57 */
/***/ function(module, exports) {

	angular.module('orcidApp').factory("initialConfigService", ['$rootScope', '$location', function ($rootScope, $location) {
	    //location requires param after # example: https://localhost:8443/orcid-web/my-orcid#?flag Otherwise it doesn't found the param and returns an empty object
	    var configValues = {
	        propertyManualEditVerificationEnabled: orcidVar.emailVerificationManualEditEnabled,
	        showModalManualEditVerificationEnabled: false
	    };

	    var paramVerifyEditRegex = /.*\?(.*\&)*(verifyEdit){1}(=true){0,1}(?!=false)((\&){1}.+)*/g;
	    var paramVerifyEdit = paramVerifyEditRegex.test( $location.absUrl() ); 

	    var initialConfigService = {
	        getInitialConfiguration: function(){
	            return configValues;
	        }
	    };

	    if( paramVerifyEdit == true ){
	        configValues.showModalManualEditVerificationEnabled = true;
	    } 

	    return initialConfigService;
	}]);

/***/ },
/* 58 */
/***/ function(module, exports) {

	angular.module('orcidApp').factory("notificationsSrvc", ['$rootScope', '$q', function ($rootScope, $q) {
	    var defaultMaxResults = 10;
	    var serv = {
	        loading: true,
	        loadingMore: false,
	        firstResult: 0,
	        maxResults: defaultMaxResults,
	        areMoreFlag: false,
	        notifications: [],
	        displayBody: {},
	        unreadCount: 0,
	        showArchived: false,
	        bulkChecked: false,
	        bulkArchiveMap: [],
	        selectionActive: false,
	        notificationAlerts: [],
	        getNotifications: function() {
	            var url = getBaseUri() + '/inbox/notifications.json?firstResult=' + serv.firstResult + '&maxResults=' + serv.maxResults;             
	            if(serv.showArchived){
	                url += "&includeArchived=true";
	            }
	            $.ajax({
	                url: url,
	                dataType: 'json',
	                success: function(data) {
	                    if(data.length === 0 || data.length < serv.maxResults){
	                        serv.areMoreFlag = false;
	                    }
	                    else{
	                        serv.areMoreFlag = true;
	                    }
	                    for(var i = 0; i < data.length; i++){                       
	                        serv.notifications.push(data[i]);
	                    }
	                    serv.loading = false;
	                    serv.loadingMore = false;
	                    $rootScope.$apply();
	                    serv.resizeIframes();
	                }
	            }).fail(function(e) {
	                serv.loading = false;
	                serv.loadingMore = false;
	                // something bad is happening!
	                console.log("error with getting notifications");
	                logAjaxError(e);
	            });
	        },
	        getNotificationAlerts: function(){
	            $.ajax({
	                url: getBaseUri() + '/inbox/notification-alerts.json',
	                type: 'POST',
	                dataType: 'json',
	                success: function(data) {
	                    serv.notificationAlerts = data;
	                }
	            }).fail(function(e) {
	                // something bad is happening!
	                console.log("getNotificationsAlerts error in notificationsSrvc");
	                logAjaxError(e);
	            });
	        },
	        reloadNotifications: function() {
	            serv.loading = true;
	            serv.notifications.length = 0;
	            serv.firstResult = 0;
	            serv.maxResults = defaultMaxResults;
	            serv.getNotifications();            
	        },
	        retrieveUnreadCount: function() {
	            $.ajax({
	                url: getBaseUri() + '/inbox/unreadCount.json',
	                dataType: 'json',
	                success: function(data) {
	                    serv.unreadCount = data;                   
	                    $rootScope.$apply();
	                }
	            }).fail(function(e) {
	                // something bad is happening!
	                console.log("error with getting count of unread notifications");
	                logAjaxError(e);
	            });
	        },
	        resizeIframes: function(){
	            var activeViews = serv.displayBody;
	            for (key in activeViews){
	                iframeResize(key);              
	            }
	        },
	        getUnreadCount: function() {
	            return serv.unreadCount;
	        },
	        showMore: function() {
	            serv.loadingMore = true;
	            serv.firstResult += serv.maxResults;
	            serv.getNotifications();
	        },
	        areMore: function() {
	            return serv.areMoreFlag;
	        },
	        flagAsRead: function(notificationId) {
	            
	            console.log(notificationId);
	            
	            $.ajax({
	                url: getBaseUri() + '/inbox/' + notificationId + '/read.json',
	                type: 'POST',
	                dataType: 'json',
	                success: function(data) {
	                    var updated = data;
	                    for(var i = 0;  i < serv.notifications.length; i++){
	                        var existing = serv.notifications[i];
	                        if(existing.putCode === updated.putCode){
	                            existing.readDate = updated.readDate;
	                        }
	                    }
	                    serv.retrieveUnreadCount();
	                    $rootScope.$apply();
	                }
	            }).fail(function() {
	                // something bad is happening!
	                console.log("error flagging notification as read");
	            });
	        },
	        archive: function(notificationId) {         
	            $.ajax({
	                url: getBaseUri() + '/inbox/' + notificationId + '/archive.json',
	                type: 'POST',
	                dataType: 'json',
	                success: function(data) {
	                    var updated = data;
	                    for(var i = 0;  i < serv.notifications.length; i++){
	                        var existing = serv.notifications[i];
	                        if(existing.putCode === updated.putCode){
	                            serv.notifications.splice(i, 1);
	                            if(serv.firstResult > 0){
	                                serv.firstResult--;
	                            }
	                            break;
	                        }
	                    }
	                    serv.retrieveUnreadCount();
	                    $rootScope.$apply();
	                }
	            }).fail(function() {
	                // something bad is happening!
	                console.log("error flagging notification as archived");
	            });
	        },
	        suppressAlert: function(notificationId) {         
	            $.ajax({
	                url: getBaseUri() + '/inbox/' + notificationId + '/suppressAlert.json',
	                type: 'POST',
	                dataType: 'json',
	                success: function(data) {
	                    for(var i = 0;  i < serv.notifications.length; i++){
	                        var existing = serv.notifications[i];
	                        if(existing.putCode === notificationId){
	                            serv.notifications.splice(i, 1);
	                            if(serv.firstResult > 0){
	                                serv.firstResult--;
	                            }
	                            break;
	                        }
	                    }
	                    $rootScope.$apply();
	                }
	            }).fail(function() {
	                // something bad is happening!
	                console.log("error flagging notification alert as suppressed");
	            });
	        },
	        toggleArchived: function(){
	            serv.showArchived = !serv.showArchived;
	            serv.reloadNotifications();
	        },
	        swapbulkChangeAll: function(){          
	            serv.bulkChecked = !serv.bulkChecked;
	            if(serv.bulkChecked == false)
	                serv.bulkArchiveMap.length = 0;
	            else
	                for (var idx in serv.notifications)
	                    serv.bulkArchiveMap[serv.notifications[idx].putCode] = serv.bulkChecked;
	                serv.selectionActive = true;
	            
	            
	        },
	        bulkArchive: function(){            
	            var promises = [];
	            var tmpNotifications = serv.notifications;
	            
	            function archive(notificationId){                
	                var defer = $q.defer(notificationId);                
	                $.ajax({
	                    url: getBaseUri() + '/inbox/' + notificationId + '/archive.json',
	                    type: 'POST',
	                    dataType: 'json',
	                    success: function(data) {
	                        defer.resolve(notificationId);
	                    }
	                }).fail(function() {
	                    // something bad is happening!
	                    console.log("error flagging notification as archived");
	                });                
	                return defer.promise;
	            }
	            
	            for (putCode in serv.bulkArchiveMap)
	                if(serv.bulkArchiveMap[putCode])
	                    promises.push(archive(putCode));            
	            
	            $q.all(promises).then(function(){
	                serv.bulkArchiveMap.length = 0;
	                serv.bulkChecked = false;
	                serv.reloadNotifications();
	            });
	            
	        },
	        checkSelection: function(){
	            var count = 0;
	            var totalNotifications = 0;            
	            serv.selectionActive = false;
	            for (putCode in serv.bulkArchiveMap){                
	                if(serv.bulkArchiveMap[putCode] == true){
	                    serv.selectionActive = true;
	                    count++;
	                }
	            }                      
	            for (i = 0; i < serv.notifications.length; i++)                
	                if (serv.notifications[i].archivedDate == null)
	                    totalNotifications++;            
	            
	            totalNotifications == count ? serv.bulkChecked = true : serv.bulkChecked = false;
	        }
	    };
	    return serv;
	}]);

/***/ },
/* 59 */
/***/ function(module, exports) {

	angular.module('orcidApp').factory(
	    'utilsService', 
	    function() {
	        var utilsService = {
	            addComma: function(str) {
	                if (str.length > 0){
	                    return str + ', ';
	                } 
	                return str;
	            },

	            contains: function(arr, obj) {
	                var index = arr.length;
	                while (index--) {
	                    if (arr[index] === obj) {
	                       return true;
	                    }
	                }
	                return false;
	            },

	            emptyTextField: function(field) {
	                if (field != null
	                    && field.value != null
	                    && field.value.trim() != '') {
	                    return false;
	                }
	                return true;
	            },

	            fixZindexIE7: function(target, zindex){
	                if(isIE() == 7){
	                    $(target).each(
	                        function(){
	                            $(this).css('z-index', zindex);
	                            --zindex;
	                        }
	                    );
	                }
	            },

	            formatDate: function(oldDate) {
	                var date = new Date(oldDate);
	                var day = date.getDate();
	                var month = date.getMonth() + 1;
	                var year = date.getFullYear();
	                if(month < 10) {
	                    month = '0' + month;
	                }
	                if(day < 10) {
	                    day = '0' + day;
	                }
	                return (year + '-' + month + '-' + day);
	            },

	            formColorBoxResize: function() {
	                if (isMobile()) {
	                    $.colorbox.resize({width: formColorBoxWidth(), height: '100%'});
	                }
	                else {
	                    // IE8 and below doesn't take auto height
	                    // however the default div height
	                    // is auto anyway
	                    $.colorbox.resize({width:'800px'});
	                    
	                }
	            },

	            formColorBoxWidth: function() {
	                return isMobile()? '100%': '800px';
	            },

	            getParameterByName: function( name ) {
	                var _name = name,
	                    regex = new RegExp("[\\?&]" + _name + "=([^&#]*)"),
	                    results = regex.exec(location.search)
	                ;
	                
	                _name = _name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
	                
	                return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
	            },

	            getScripts: function(scripts, callback) {
	                var progress = 0;
	                var internalCallback = function () {        
	                    if (++progress == scripts.length - 1) {
	                        callback();
	                    }
	                };    
	                scripts.forEach(
	                    function(script) {        
	                        $.getScript(script, internalCallback);        
	                    }
	                );
	            },

	            isEmail: function(email) {
	                var re = /\S+@\S+\.\S+/;
	                return re.test(email);
	            },

	            openImportWizardUrl: function(url) {
	                var win = window.open(url, "_target");
	                setTimeout( function() {
	                    if(!win || win.outerHeight === 0) {
	                        //First Checking Condition Works For IE & Firefox
	                        //Second Checking Condition Works For Chrome
	                        window.location.href = url;
	                    }
	                }, 250);
	                $.colorbox.close();
	            }
	        };
	        return utilsService;
	    }
	);

/***/ },
/* 60 */
/***/ function(module, exports) {

	angular.module('orcidApp').factory("workspaceSrvc", ['$rootScope', function ($rootScope) {
	    var serv = {
	        displayEducation: true,
	        displayEmployment: true,
	        displayFunding: true,
	        displayPersonalInfo: true,
	        displayWorks: true,
	        displayPeerReview: true,
	        toggleEducation: function() {
	            serv.displayEducation = !serv.displayEducation;
	        },
	        toggleEmployment: function() {
	            serv.displayEmployment = !serv.displayEmployment;
	        },
	        toggleFunding: function() {
	            serv.displayFunding = !serv.displayFunding;
	        },
	        togglePersonalInfo: function() {
	            serv.displayPersonalInfo = !serv.displayPersonalInfo;
	        },
	        toggleWorks: function() {
	            serv.displayWorks = !serv.displayWorks;
	        },
	        togglePeerReview: function() {              
	            serv.displayPeerReview = !serv.displayPeerReview;
	        },
	        openEducation: function() {
	            serv.displayEducation = true;
	        },
	        openFunding: function() {
	            serv.displayFunding = true;
	        },
	        openEmployment: function() {
	            serv.displayEmployment = true;
	        },
	        openPersonalInfo: function() {
	            serv.displayPersonalInfo = true;
	        },
	        openWorks: function() {
	            serv.displayWorks = true;
	        },
	        openPeerReview: function() {
	            serv.displayPeerReview = true;
	        },
	        togglePeerReviews : function() {
	            serv.displayPeerReview = !serv.displayPeerReview;
	        }   
	    };
	    return serv;
	}]);

/***/ },
/* 61 */
/***/ function(module, exports) {

	function webpackContext(req) {
		throw new Error("Cannot find module '" + req + "'.");
	}
	webpackContext.keys = function() { return []; };
	webpackContext.resolve = webpackContext;
	module.exports = webpackContext;
	webpackContext.id = 61;


/***/ }
/******/ ]);